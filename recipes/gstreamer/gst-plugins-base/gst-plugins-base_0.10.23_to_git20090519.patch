diff -Naur AUTHORS AUTHORS
--- AUTHORS	2009-04-15 21:18:27.000000000 +0200
+++ AUTHORS	2009-05-19 18:44:45.000000000 +0200
@@ -1,7 +1,7 @@
 Erik Walthinsen <omega@temple-baptist.com>
 Matt Howell <mhowell@users.sourceforge.net>
 Brent Bradburn <bbradburn@users.sourceforge.net>
-Wim Taymans <wim.taymans@chello.be>
+Wim Taymans <wim.taymans@gmail.com>
 Richard Boulton <richard@tartarus.org>
 Zaheer Abbas Merali <zaheerabbas at merali dot org>
 David I. Lehn <dlehn@users.sourceforge.net>
diff -Naur autogen.sh autogen.sh
--- autogen.sh	2009-04-01 13:49:10.000000000 +0200
+++ autogen.sh	2009-05-19 18:44:45.000000000 +0200
@@ -77,8 +77,8 @@
 tool_run "$autopoint --force"
 patch -p0 < common/gettext.patch
 
-tool_run "$aclocal" "-I m4 -I common/m4 $ACLOCAL_FLAGS"
 tool_run "$libtoolize" "--copy --force"
+tool_run "$aclocal" "-I m4 -I common/m4 $ACLOCAL_FLAGS"
 tool_run "$autoheader"
 
 # touch the stamp-h.in build stamp so we don't re-run autoheader in maintainer mode -- wingo
diff -Naur configure.ac configure.ac
--- configure.ac	2009-05-10 23:50:21.000000000 +0200
+++ configure.ac	2009-05-19 18:45:41.000000000 +0200
@@ -3,9 +3,9 @@
 dnl please read gstreamer/docs/random/autotools before changing this file
 
 dnl initialize autoconf
-dnl releases only do -Wall, cvs and prerelease does -Werror too
-dnl use a three digit version number for releases, and four for cvs/prerelease
-AC_INIT(GStreamer Base Plug-ins, 0.10.23,
+dnl releases only do -Wall, git and prerelease does -Werror too
+dnl use a three digit version number for releases, and four for git/prerelease
+AC_INIT(GStreamer Base Plug-ins, 0.10.23.1,
     http://bugzilla.gnome.org/enter_bug.cgi?product=GStreamer,
     gst-plugins-base)
 
@@ -18,7 +18,7 @@
 AS_VERSION
 
 dnl check if this is a release version
-AS_NANO(GST_CVS="no", GST_CVS="yes")
+AS_NANO(GST_GIT="no", GST_GIT="yes")
 
 dnl can autoconf find the source ?
 AC_CONFIG_SRCDIR([gst/audiotestsrc/gstaudiotestsrc.c])
@@ -55,7 +55,7 @@
 AM_PROG_LIBTOOL
 
 dnl *** required versions of GStreamer stuff ***
-GST_REQ=0.10.21.1
+GST_REQ=0.10.23
 
 dnl *** autotools stuff ****
 
@@ -243,7 +243,7 @@
 dnl *** checks for dependency libraries ***
 
 dnl GLib is required
-AG_GST_GLIB_CHECK([2.14])
+AG_GST_GLIB_CHECK([2.16])
 
 dnl liboil is required
 PKG_CHECK_MODULES(LIBOIL, liboil-0.3 >= 0.3.14, HAVE_LIBOIL=yes, HAVE_LIBOIL=no)
@@ -286,10 +286,10 @@
 AG_GST_SET_PLUGINDIR
 
 dnl define an ERROR_CFLAGS Makefile variable
-AG_GST_SET_ERROR_CFLAGS($GST_CVS)
+AG_GST_SET_ERROR_CFLAGS($GST_GIT)
 
 dnl define correct level for debugging messages
-AG_GST_SET_LEVEL_DEFAULT($GST_CVS)
+AG_GST_SET_LEVEL_DEFAULT($GST_GIT)
 
 dnl used in examples
 AG_GST_DEFAULT_ELEMENTS
@@ -566,6 +566,12 @@
   AG_GST_PKG_CHECK_MODULES(PANGO, pango pangoft2)
 ])
 
+dnl *** schroedinger ***
+translit(dnm, m, l) AM_CONDITIONAL(USE_SCHRO, true)
+AG_GST_CHECK_FEATURE(SCHRO, [Schroedinger video codec], schro, [
+  AG_GST_PKG_CHECK_MODULES(SCHRO, schroedinger-1.0 >= 1.0.7)
+])
+
 dnl *** theora ***
 translit(dnm, m, l) AM_CONDITIONAL(USE_THEORA, true)
 AG_GST_CHECK_FEATURE(THEORA, [Xiph Theora video codec], theora, [
@@ -619,6 +625,7 @@
 AM_CONDITIONAL(USE_LIBVISUAL, false)
 AM_CONDITIONAL(USE_OGG, false)
 AM_CONDITIONAL(USE_PANGO, false)
+AM_CONDITIONAL(USE_SCHRO, false)
 AM_CONDITIONAL(USE_THEORA, false)
 AM_CONDITIONAL(USE_VORBIS, false)
 
@@ -652,7 +659,7 @@
 AC_SUBST(PROFILE_CFLAGS)
 
 if test "x$PACKAGE_VERSION_NANO" = "x1"; then
-  dnl Define _only_ during CVS (not pre-releases or releases)
+  dnl Define _only_ when compiling a git version (not pre-releases or releases)
   DEPRECATED_CFLAGS="-DGST_DISABLE_DEPRECATED"
 else
   DEPRECATED_CFLAGS=""
@@ -735,6 +742,7 @@
 ext/libvisual/Makefile
 ext/ogg/Makefile
 ext/pango/Makefile
+ext/schroedinger/Makefile
 ext/theora/Makefile
 ext/vorbis/Makefile
 gst-libs/Makefile
diff -Naur docs/design/draft-keyframe-force.txt docs/design/draft-keyframe-force.txt
--- docs/design/draft-keyframe-force.txt	1970-01-01 01:00:00.000000000 +0100
+++ docs/design/draft-keyframe-force.txt	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,87 @@
+Forcing keyframes
+-----------------
+
+Consider the following use case:
+
+  We have a pipeline that performs video and audio capture from a live source,
+  compresses and muxes the streams and writes the resulting data into a file.
+
+  Inside the uncompressed video data we have a specific pattern inserted at
+  specific moments that should trigger a switch to a new file, meaning, we close
+  the existing file we are writing to and start writing to a new file.
+
+  We want the new file to start with a keyframe so that one can start decoding
+  the file immediatly.
+
+Components:
+
+  1) We need an element that is able to detect the pattern in the video stream.
+
+  2) We need to inform the video encoder that it should start encoding a keyframe
+     starting from exactly the frame with the pattern.
+
+  3) We need to inform the demuxer that it should flush out any pending data and
+     start creating the start of a new file with the keyframe as a first video
+     frame.
+
+  4) We need to inform the sink element that it should start writing to the next
+     file. This requires application interaction to instruct the sink of the new
+     filename. The application should also be free to ignore the boundary and
+     continue to write to the existing file. The application will typically use
+     an event pad probe to detect the custom event.
+
+Implementation:
+
+ The implementation would consist of generating a GST_EVENT_CUSTOM_DOWNSTREAM
+ event that marks the keyframe boundary. This event is inserted into the
+ pipeline by the application upon a certain trigger. In the above use case this
+ trigger would be given by the element that detects the pattern, in the form of
+ an element message.
+ 
+ The custom event would travel further downstream to instruct encoder, muxer and
+ sink about the possible switch.
+
+ The information passed in the event consists of:
+
+  name:  GstForceKeyUnit
+	 (G_TYPE_UINT64)"timestamp"    : the timestamp of the buffer that
+	                                 triggered the event.
+	 (G_TYPE_UINT64)"stream-time"  : the stream position that triggered the
+	                                 event.
+	 (G_TYPE_UINT64)"running-time" : the running time of the stream when the 
+	                                 event was triggered.
+	 ....                          : optional other data fields.
+
+  Note that this event is purely informational, no element is required to
+  perform an action but it should forward the event downstream, just like any
+  other event it does not handle.
+
+  Elements understanding the event should behave as follows:
+
+  1) The video encoder receives the event before the next frame. Upon reception
+     of the event it schedules to encode the next frame as a keyframe. 
+     Before pushing out the encoded keyframe it must push the GstForceKeyUnit
+     event downstream.
+
+  2) The muxer receives the GstForceKeyUnit event and flushes out its current state,
+     preparing to produce data that can be used as a keyunit. Before pushing out
+     the new data it pushes the GstForceKeyUnit event downstream.
+
+  3) The application receives the GstForceKeyUnit on a sink padprobe of the sink
+     and reconfigures the sink to make it perform new actions after receiving
+     the next buffer. 
+
+
+Upstream
+--------
+
+When using RTP packets can get lost or receivers can be added at any time,
+they may request a new key frame.
+
+An downstream element sends an upstream "GstForceKeyUnit" event up the
+pipeline.
+
+When an element produces some kind of key unit in output, but has
+no such concept in its input (like an encoder that takes raw frames),
+it consumes the event (doesn't pass it upstream), and instead sends
+a downstream GstForceKeyUnit event and a new keyframe.
diff -Naur docs/design/part-playbin2.txt docs/design/part-playbin2.txt
--- docs/design/part-playbin2.txt	1970-01-01 01:00:00.000000000 +0100
+++ docs/design/part-playbin2.txt	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,69 @@
+playbin2
+--------
+
+The purpose of this element is to decode and render the media contained in a
+given generic uri. The element extends GstPipeline and is typically used in
+playback situations.
+
+Required features:
+
+ - accept and play any valid uri. This includes
+   - rendering video/audio
+   - overlaying subtitles on the video
+ - optionally read external subtitle files
+ - allow for hardware (non raw) sinks
+ - selection of audio/video/subtitle streams based on language.
+ - perform network buffering/incremental download
+ - gapless playback
+ - support for visualisations with configurable sizes
+ - ability to reject files that are too big, or of a format that would require
+   too much CPU/memory usage.
+ - be very efficient with adding elements such as converters to reduce the
+   amount of negotiation that has to happen.
+ - handle chained oggs. This includes having support for dynamic pad add and
+   remove from a demuxer.
+
+Components
+----------
+
+* decodebin2
+
+ - performs the autoplugging of demuxers/decoders
+ - emits signals when for steering the autoplugging
+   - to decide if a non-raw media format is acceptable as output
+   - to sort the possible decoders for a non-raw format
+ - see also decodebin2 design doc
+
+* uridecodebin
+
+ - combination of a source to handle the given uri, an optional queueing element
+   and one or more decodebin2 elements to decode the non-raw streams.
+
+* playsink
+
+ - handles display of audio/video/text.
+ - has request audio/video/text input pad. There is only one sinkpad per type.
+   The requested pads define the configuration of the internal pipeline. 
+ - allows for setting audio/video sinks or does automatic sink selection.
+ - allows for configuration of visualisation element.
+ - allows for enable/disable of visualisation, audio and video.
+
+* playbin2
+
+ - combination of one or more uridecodebin elements to read the uri and subtitle
+   uri.
+ - support for queuing new media to support gapless playback.
+ - handles stream selection.
+ - uses playsink to display.
+ - selection of sinks and configuration of uridecodebin with raw output formats.
+
+
+Gapless playback
+----------------
+
+playbin2 has an "about-to-finish" signal. The application should configure a new
+uri (and optional suburi) in the callback. When the current media finishes, this
+new media will be played next.
+
+
+    
diff -Naur docs/libs/gst-plugins-base-libs-sections.txt docs/libs/gst-plugins-base-libs-sections.txt
--- docs/libs/gst-plugins-base-libs-sections.txt	2009-05-11 00:53:28.000000000 +0200
+++ docs/libs/gst-plugins-base-libs-sections.txt	2009-05-19 18:44:45.000000000 +0200
@@ -390,6 +390,7 @@
 gst_color_balance_get_value
 gst_color_balance_set_value
 gst_color_balance_value_changed
+gst_color_balance_get_balance_type
 <SUBSECTION Standard>
 GST_COLOR_BALANCE
 GST_COLOR_BALANCE_CLASS
@@ -443,6 +444,7 @@
 gst_mixer_mixer_changed
 
 gst_mixer_get_mixer_flags
+gst_mixer_get_mixer_type
 
 gst_mixer_message_get_type
 gst_mixer_message_parse_mute_toggled
diff -Naur docs/plugins/gst-plugins-base-plugins-overrides.txt docs/plugins/gst-plugins-base-plugins-overrides.txt
--- docs/plugins/gst-plugins-base-plugins-overrides.txt	1970-01-01 01:00:00.000000000 +0100
+++ docs/plugins/gst-plugins-base-plugins-overrides.txt	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,30 @@
+<STRUCT>
+<NAME>GstDecodeBin</NAME>
+struct _GstDecodeBin {
+};
+</STRUCT>
+<STRUCT>
+<NAME>GstDecodeBin2</NAME>
+struct _GstDecodeBin2 {
+};
+</STRUCT>
+<STRUCT>
+<NAME>GstPlayBaseBin</NAME>
+struct _GstPlayBaseBin {
+};
+</STRUCT>
+<STRUCT>
+<NAME>GstPlayBin</NAME>
+struct _GstPlayBin {
+};
+</STRUCT>
+<STRUCT>
+<NAME>GstPlayBin2</NAME>
+struct _GstPlayBin2 {
+};
+</STRUCT>
+<STRUCT>
+<NAME>GstURIDecodeBin</NAME>
+struct _GstURIDecodeBin {
+};
+</STRUCT>
diff -Naur docs/random/ChangeLog-0.8 docs/random/ChangeLog-0.8
--- docs/random/ChangeLog-0.8	1970-01-01 01:00:00.000000000 +0100
+++ docs/random/ChangeLog-0.8	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,15589 @@
+2005-02-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosselement.c: (gst_osselement_class_probe_devices):
+	  Kick the hell out of gcc for not warning me about a symbol conflict.
+
+2005-02-22  Luca Ognibene  <luogni@tin.it>
+
+	Reviewed by: Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/gdk_pixbuf/pixbufscale.c: (gst_pixbufscale_link):
+	  Don't leak caps string (fixes #168134)
+
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_class_init),
+	(gst_jpegenc_init), (gst_jpegenc_finalize),
+	(gst_jpegenc_change_state):
+	  Don't leak line buffers and context struct (fixes #168133).
+
+2005-02-21  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* configure.ac:
+	* ext/dirac/gstdiracdec.cc:
+	(gst_diracdec_chain):
+	  Since dirac 0.5.0 the framerate in dirac is expressed as a
+	  rational number. Fix build and up requirement to 0.5.0, and
+	  also pass parameters to gst_diracdec_link in the right order
+	  (fixes #167959).
+
+2005-02-21  Maciej Katafiasz  <mathrick@freedesktop.org>
+
+	* ext/faad/gstfaad.c: (gst_faad_sinkconnect), (gst_faad_chain):
+	* ext/faad/gstfaad.h:
+	TEH LONGEST DEBUGGING SESSION EVAR is over. Fix interaction with 
+	certain invalid muxed streams, where some packets will contain 
+	junk after decoder data. Partially fixes #149158.
+
+2005-02-21  Jan Schmidt <thaytan@mad.scientist.com>
+	* gst/dvdlpcmdec/gstdvdlpcmdec.c: (gst_dvdlpcmdec_chain):
+          Make sure we only write to writable buffers
+
+2005-02-20  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_audio_caps_with_data):
+	  Do actually fix invalid RIFF fmt header values for alaw
+	  and mulaw audio instead of just saying so.
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_fmt):
+	  Give gst_riff_create_audio_caps_with_data() a chance to
+	  fix up broken format header fields before extracting any
+	  parameters from the header. (fixes #167633)
+
+2005-02-19  Martin Holters  <martin.holters@gmx.de>
+
+	Reviewed by: Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/audioconvert/bufferframesconvert.c:
+	(buffer_frames_convert_link):
+	  Don't leak othercaps. (fixes #167878)
+
+2005-02-19  Arwed v. Merkatz  <v.merkatz@gmx.net>
+
+	* configure.ac:
+	* ext/libvisual/visual.c: (gst_visual_srclink),
+	(gst_visual_change_state):
+	  Support libvisual 0.2.0.
+
+2005-02-18  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/jpeg/gstjpegdec.c: (gst_jpegdec_chain):
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_resync), (gst_jpegenc_chain):
+	  Use same rowstrides for I420 as used everywhere else.
+
+2005-02-17  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_invert):
+	  Declare variables at beginning of block and make gcc-2.95 happy
+	  (fixes # 167482, patch by Gergely Nagy).
+	  
+	* gst/tcp/gsttcpclientsrc.c:
+	* gst/tcp/gsttcpclientsrc.h:
+	  Move some includes into the header, so that struct sockaddr_in is
+	  defined when it should be defined on FreeBSD as well (fixes
+	  #167483).
+	  
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_init_receive):
+	  Don't pass uninitialised values to setsockopt() here either.
+
+2005-02-17  Luca Ognibene  <luogni at tin dot it>
+
+	Reviewed by: Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_init_send):
+	  Don't pass uninitialised values to setsockopt(). (fixes #167704)
+
+2005-02-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybin.c: (add_sink):
+	  Invert bin_add/link order to workaround deadlock in opt.
+
+2005-02-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/modplug/gstmodplug.cc:
+	  Add missing break causing position queries to fail.
+
+2005-02-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_populate):
+	  Granpos can apparently be -1, which screws up calculations...
+
+2005-02-16  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain),
+	(gst_ximagesink_send_pending_navigation),
+	(gst_ximagesink_navigation_send_event), (gst_ximagesink_finalize),
+	(gst_ximagesink_init):
+	* sys/ximage/ximagesink.h:
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain),
+	(gst_xvimagesink_send_pending_navigation),
+	(gst_xvimagesink_navigation_send_event),
+	(gst_xvimagesink_finalize), (gst_xvimagesink_init):
+	* sys/xvimage/xvimagesink.h:
+	  Use a mutex protected list to marshal navigation
+	  events into the stream thread from whichever thread
+	  sends them.
+
+2005-02-15  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/speed/demo-mp3.c: (time_tick_cb), (main):
+	  Display current position and track length; misc. clean-ups.
+	  
+	* gst/speed/gstspeed.c: (speed_get_query_types), (speed_src_query),
+	(speed_init), (speed_chain):
+	  Add query function, so that the stream length and current position
+	  get adjusted when queried (note that current position queries may
+	  still be wrong if the audio sink returns values based on buffer
+	  timestamps instead of passing on the query).
+
+2005-02-13  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link),
+	(gst_audio_convert_channels):
+	  create channel conversion matrix when linking
+	* gst/audioconvert/.cvsignore:
+	* gst/audioconvert/Makefile.am:
+	* gst/audioconvert/channelmixtest.c: (main):
+	  add (ugly) test that ensures stereo <=> mono conversion works
+	  correctly
+
+2005-02-13  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstchannelmix.h:
+	  include missing header file
+	* gst/audioconvert/gstchannelmix.c:
+	(gst_audio_convert_fill_compatible):
+	  use same sign for both channels when converting to/from compatible
+	  channel. Previously used different signs made the signals cancel
+	  each other out and appear like silence. (fixes #167269)
+
+2005-02-12  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/ffmpegcolorspace/avcodec.h:
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_pixfmt_to_caps), (gst_ffmpeg_caps_to_pixfmt),
+	(gst_ffmpegcsp_avpicture_fill):
+	* gst/ffmpegcolorspace/imgconvert.c:
+	  Convert to and from YV12 (fixes #156379).
+
+2005-02-12  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_new),
+	(gst_ximagesink_sink_link), (gst_ximagesink_change_state),
+	(gst_ximagesink_chain), (gst_ximagesink_set_xwindow_id),
+	(gst_ximagesink_expose), (gst_ximagesink_set_property),
+	(gst_ximagesink_finalize), (gst_ximagesink_init): Protect interface
+        methods from chain and negotiation and vice versa (Fixes #166142).
+	* sys/ximage/ximagesink.h: Add stream_lock.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_free),
+	(gst_xvimagesink_buffer_alloc), (gst_xvimagesink_set_xwindow_id),
+	(gst_xvimagesink_expose): Check for xcontext before trying to link.
+
+2005-02-12  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_open):
+	  Don't send "Hey! You gave me a NULL pointer you naughty person" as
+	  error message when we can't open the DVD device (when dvdnav_open()
+	  fails, src->dvdnav is NULL, so dvdnav_err_to_string() will return
+	  the above). Send something more useful instead (fixes #167117).
+
+2005-02-11  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_put),
+	(gst_xvimagesink_sink_link), (gst_xvimagesink_change_state),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_free),
+	(gst_xvimagesink_buffer_alloc), (gst_xvimagesink_set_xwindow_id),
+	(gst_xvimagesink_expose), (gst_xvimagesink_set_property),
+	(gst_xvimagesink_finalize), (gst_xvimagesink_init): Protect interface
+	methods from chain and negotiation and vice versa (Fixes #166142).
+	Fix a possible bug of images in the buffer pool being discarded because
+	we are looking at the wrong geometry.
+	* sys/xvimage/xvimagesink.h: Add stream_lock.
+
+2005-02-11  David Schleef  <ds@schleef.org>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (crop_buffer): Change uint to
+	unsigned int. (fixes #167128)
+
+2005-02-11  David Schleef  <ds@schleef.org>
+
+	* gst/librfb/Makefile.am: Testing stuff before committing is
+	  for wimps... and people with fast machines.  Fix stupid
+	  mistake.
+
+2005-02-11  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Pull in librfb from my CVS tree, because it is
+	  too small and annoying to be separate.  Move rfbsrc plugin
+	  to gst/.
+	* ext/Makefile.am:
+	* ext/librfb/Makefile.am:
+	* ext/librfb/gstrfbsrc.c:
+	* gst/librfb/Makefile.am:
+	* gst/librfb/gstrfbsrc.c:
+	* gst/librfb/rfb.c:
+	* gst/librfb/rfb.h:
+	* gst/librfb/rfbbuffer.c:
+	* gst/librfb/rfbbuffer.h:
+	* gst/librfb/rfbbytestream.c:
+	* gst/librfb/rfbbytestream.h:
+	* gst/librfb/rfbcontext.h:
+	* gst/librfb/rfbdecoder.c:
+	* gst/librfb/rfbdecoder.h:
+	* gst/librfb/rfbutil.h:
+
+2005-02-10  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/speed/Makefile.am:
+	* gst/speed/demo-mp3.c: (main):
+	* gst/speed/filter.func:
+	* gst/speed/gstspeed.c: (speed_link), (speed_parse_caps),
+	(speed_class_init), (speed_init), (speed_chain_int16),
+	(speed_chain_float32), (speed_chain), (speed_set_property),
+	(speed_get_property), (speed_change_state):
+	* gst/speed/gstspeed.h:
+	  Fix speed element and make it chain-based (fixes #156467),
+	  and make it handle more than one channel.
+
+2005-02-10  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dts/gstdtsdec.c: (gst_dtsdec_init), (gst_dtsdec_channels),
+	(gst_dtsdec_handle_event), (gst_dtsdec_handle_frame),
+	(gst_dtsdec_chain), (gst_dtsdec_change_state):
+	* ext/dts/gstdtsdec.h:
+          Don't clobber the stack constructing the channels array.
+	  Make the element chain-based. DTS tracks can now be played.
+	  
+2005-02-09  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst-libs/gst/audio/multichannel.h:
+	* gst-libs/gst/gconf/gconf.h:
+	* gst-libs/gst/idct/idct.h:
+	* gst-libs/gst/media-info/media-info-priv.h:
+	* gst-libs/gst/play/play.h:
+	* gst-libs/gst/resample/private.h:
+	* gst-libs/gst/resample/resample.h:
+	* gst-libs/gst/riff/riff-ids.h:
+	* gst-libs/gst/video/video.h:
+	* gst-libs/gst/video/videosink.h:
+	  Add G_BEGIN_DECLS and G_END_DECLS around headers where
+	  missing, so that they work when included from C++ code.
+
+2005-02-09  David Schleef  <ds@schleef.org>
+
+	* testsuite/gst-lint: Check for non-statically scoped
+	  parent_class variables.  This won't be a problem once
+	  plugins are loaded with RTLD_LOCAL.
+
+2005-02-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mplex/gstmplexibitstream.cc:
+	  gcc madness.
+
+2005-02-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstogmparse.c:
+	* gst/debug/gstnavigationtest.c:
+	  Die, thou faulty symbol pollutors (non-static parent_class).
+
+2005-02-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mplex/gstmplexibitstream.cc:
+	  Fix event handling (#165525).
+
+2005-02-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mikmod/gstmikmod.c:
+	* gst/modplug/gstmodplug.cc:
+	  Add missing endianness to template (fixes #165509).
+
+2005-02-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_handle_data):
+	  Fix wrong order of reading of optional bytes (#165290).
+
+2005-02-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  Implement FILLER event awareness.
+
+2005-02-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_convert):
+	  Fix track calculations (#166208).
+
+2005-02-08  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/libpng/gstpngdec.c: (gst_pngdec_init), (gst_pngdec_chain):
+	* ext/libpng/gstpngenc.c:
+	  Fix byte-order, use proper fixed caps. Fixes #164197.
+
+2005-02-08  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* configure.ac:
+	  Add dvdlpcmdec 
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_reset),
+	(free_all_buffers), (gst_mpeg2dec_alloc_buffer):
+	  Don't push buffers if the src pad isn't negotiated yet.
+	  
+	* gst/audioconvert/gstaudioconvert.c:
+	(gst_audio_convert_buffer_to_default_format),
+	(gst_audio_convert_buffer_from_default_format):
+	  Add support for 24-bit width.
+
+	* gst/dvdlpcmdec/.cvsignore:
+	* gst/dvdlpcmdec/Makefile.am:
+	* gst/dvdlpcmdec/gstdvdlpcmdec.c: (gst_dvdlpcmdec_get_type),
+	(gst_dvdlpcmdec_base_init), (gst_dvdlpcmdec_class_init),
+	(gst_dvdlpcm_reset), (gst_dvdlpcmdec_init), (gst_dvdlpcmdec_link),
+	(gst_dvdlpcmdec_chain), (gst_dvdlpcmdec_change_state),
+	(plugin_init):
+	* gst/dvdlpcmdec/gstdvdlpcmdec.h:
+	  New decoder for rearranging DVD LPCM into our audio/x-raw-int
+	  format. Needs support for the channels maps if someone can find 
+	  a DVD LPCM track with > 2 channels.
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_handle_dvd_event),
+	(gst_dvd_demux_send_discont), (gst_dvd_demux_handle_discont),
+	(gst_dvd_demux_get_audio_stream), (gst_dvd_demux_process_private):
+	* gst/mpegstream/gstdvddemux.h:
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_send_discont),
+	(gst_mpeg_demux_new_output_pad), (gst_mpeg_demux_init_stream),
+	(gst_mpeg_demux_send_subbuffer), (gst_mpeg_demux_handle_src_query):
+	* gst/mpegstream/gstmpegdemux.h:
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_reset),
+	(gst_mpeg_parse_parse_packhead), (gst_mpeg_parse_loop),
+	(gst_mpeg_parse_get_rate), (gst_mpeg_parse_convert_src),
+	(gst_mpeg_parse_handle_src_query),
+	(gst_mpeg_parse_handle_src_event):
+	  Use audio/x-dvd-lpcm for LPCM output.
+	  Add DTS output.
+
+2005-02-08  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/alpha/gstalphacolor.c: (gst_alpha_color_sink_link),
+	(transform_rgb), (transform_bgr), (gst_alpha_color_chain):
+	  Add BGRA handling (#165736).
+
+2005-02-08  Francis Labonte  <francis_labonte@hotmail.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/law/alaw-decode.c: (alawdec_link):
+	* gst/law/alaw-encode.c: (alawenc_link):
+	* gst/law/mulaw-decode.c: (mulawdec_link):
+	* gst/law/mulaw-encode.c: (mulawenc_link):
+	  Fix caps memleaks (#166600).
+
+2005-02-08  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/tarkin/mem.h:
+	* ext/tarkin/wavelet.h:
+	* ext/tarkin/yuv.h:
+	* gst/ffmpegcolorspace/avcodec.h:
+	  Include "_stdint.h" instead of <stdint.h>. Fixes build on
+	  systems that don't have stdint.h, like Solaris9 (fixes #166631).
+
+2005-02-05  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_change_state):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xwindow_clear),
+	(gst_xvimagesink_change_state):
+	  Clear window on PAUSED->READY instead of READY->PAUSED. Stop
+	  Xv video (and thereby regenerate Xv colourkey) in clear() so
+	  that PLAY -> READY -> PLAY works (fixes #162504).
+
+2005-02-05  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_getcaps):
+	  Switch to list instead of range, since MJPEG-devices really just
+	  support decimations, not any size.
+
+2005-02-05  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_open_decoder),
+	(gst_mpeg2dec_reset), (free_all_buffers),
+	(gst_mpeg2dec_alloc_buffer), (handle_sequence):
+	* ext/mpeg2dec/gstmpeg2dec.h:
+	  The libmpeg2 user-allocated buffer management is awkward, 
+	  to say the least. Hopefully this fixes things.
+
+2005-02-04  Andy Wingo  <wingo@pobox.com>
+
+	* gst/audioconvert/bufferframesconvert.c
+	(buffer_frames_convert_fixate): New function, fixates to 256
+	frames per buffer by default. (Much better than 1.)
+	(buffer_frames_convert_init): Set the fixate function for both src
+	and sink pad.
+	(buffer_frames_convert_link): After success setting nonfixed caps,
+	get the negotiated caps so we can know how many buffer-frames it
+	will be. No idea how this worked at all before.
+
+2005-02-05  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_init),
+	(gst_mpeg2dec_close_decoder), (put_buffer), (check_buffer),
+	(free_buffer), (free_all_buffers), (gst_mpeg2dec_alloc_buffer),
+	(handle_sequence), (handle_picture):
+	* ext/mpeg2dec/gstmpeg2dec.h:
+	  Rearrange buffer tracking and refcounting and refactor
+	  a little for readability. 
+
+2005-02-04  Jan Schmidt  <thaytan@mad.scientist.com>
+	* sys/v4l/gstv4l.c: (plugin_init):
+	* sys/v4l/gstv4ljpegsrc.c: (gst_v4ljpegsrc_get_type),
+	(gst_v4ljpegsrc_base_init), (gst_v4ljpegsrc_class_init),
+	(gst_v4ljpegsrc_init), (gst_v4ljpegsrc_src_link),
+	(gst_v4ljpegsrc_getcaps), (gst_v4ljpegsrc_get):
+	* sys/v4l/gstv4ljpegsrc.h:
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_open), (gst_v4lsrc_src_link):
+	* sys/v4l/v4l_calls.h:
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_palette_name),
+	(gst_v4lsrc_get_fps):
+	* sys/v4l/v4lsrc_calls.h:
+	  Add new v4ljpegsrc for handling the ov51x hacky "I'll give
+	  you jpeg inside rgb frames" driver.
+	  Don't error in the v4lsrc link function, just return 
+	  REFUSED.
+
+2005-02-03  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/qcam/gstqcamsrc.c: (gst_qcamsrc_change_state),
+	(gst_qcamsrc_open):
+	  Use GST_ELEMENT_ERROR, not g_warning, if open failed.
+
+2005-02-02  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_video_caps):
+	  Change caps on MJPEG-B so it doesn't interfere with MJPEG/JPEG.
+
+2005-02-02  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/raw1394/gstdv1394src.c: (gst_dv1394src_change_state):
+	  Reset negotiated state on PAUSED->READY.
+
+2005-02-02  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Put DEFAULT_AUDIOSINK in config.h and use
+	whereever possible.  (Fixes #165997)
+	* examples/capsfilter/capsfilter1.c: (main):
+	* examples/dynparams/filter.c: (create_ui):
+	* examples/seeking/cdparanoia.c: (get_track_info), (main):
+	* examples/seeking/chained.c: (main):
+	* examples/seeking/seek.c: (make_mod_pipeline), (make_dv_pipeline),
+	(make_wav_pipeline), (make_flac_pipeline), (make_sid_pipeline),
+	(make_vorbis_pipeline), (make_mp3_pipeline), (make_avi_pipeline),
+	(make_mpeg_pipeline), (make_mpegnt_pipeline):
+	* examples/seeking/spider_seek.c: (make_spider_pipeline):
+	* examples/switch/switcher.c: (main):
+	* ext/dv/demo-play.c: (main):
+	* ext/faad/gstfaad.c: (gst_faad_change_state):
+	* ext/mad/gstmad.c: (gst_mad_chain):
+	* ext/smoothwave/demo-osssrc.c: (main):
+	* gst-libs/gst/gconf/gconf.c: (gst_gconf_set_string),
+	(gst_gconf_render_bin_from_description),
+	(gst_gconf_get_default_audio_sink),
+	(gst_gconf_get_default_video_sink),
+	(gst_gconf_get_default_audio_src),
+	(gst_gconf_get_default_video_src),
+	(gst_gconf_get_default_visualization_element):
+	* gst/level/demo.c: (main):
+	* gst/level/plot.c: (main):
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_audio_element):
+	* gst/playback/test.c: (gen_video_element), (gen_audio_element):
+	* gst/playondemand/demo-mp3.c: (setup_pipeline):
+	* gst/sine/demo-dparams.c: (main):
+	* gst/spectrum/demo-osssrc.c: (main):
+	* gst/speed/demo-mp3.c: (main):
+	* gst/volume/demo.c: (main):
+	* testsuite/embed/embed.c: (main):
+
+2005-02-02  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* gst/tcp/gsttcpclientsink.c: (gst_tcpclientsink_class_init),
+	(gst_tcpclientsink_finalize):
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_class_init),
+	(gst_tcpclientsrc_finalize):
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_class_init),
+	(gst_tcpserversink_init), (gst_tcpserversink_finalize):
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_class_init),
+	(gst_tcpserversrc_init), (gst_tcpserversrc_finalize):
+	  Don't leak the hostname when shutting down.
+	  In tcpserversrc, take a copy of the default hostname.
+
+2005-02-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/raw1394/gstdv1394src.c: (gst_dv1394src_iso_receive):
+	  Set caps to systemstream=TRUE.
+
+2005-02-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* testsuite/Makefile.am:
+	  Fix more OSX buildbots.
+
+2005-02-02  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	  Don't send things to NULL PAD_PEERs
+
+	* gst/deinterlace/gstdeinterlace.c: (gst_deinterlace_chain):
+	  Copy-on-write the incoming buffer.
+
+	* gst/mpegstream/gstdvddemux.h:
+	* gst/mpegstream/gstmpegclock.h:
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead),
+	(normal_seek), (gst_mpeg_demux_handle_src_event):
+	* gst/mpegstream/gstmpegdemux.h:
+	* gst/mpegstream/gstmpegpacketize.h:
+	* gst/mpegstream/gstmpegparse.c:
+	(gst_mpeg_parse_update_streaminfo), (gst_mpeg_parse_reset),
+	(gst_mpeg_parse_handle_discont), (gst_mpeg_parse_parse_packhead),
+	(gst_mpeg_parse_loop), (gst_mpeg_parse_get_rate),
+	(gst_mpeg_parse_convert_src), (gst_mpeg_parse_handle_src_query),
+	(gst_mpeg_parse_handle_src_event), (gst_mpeg_parse_change_state):
+	* gst/mpegstream/gstmpegparse.h:
+	* gst/mpegstream/gstrfc2250enc.h:
+          Various changes to the way time is computed that make seeking and
+	  total time estimation much better here.
+	  Use G_BEGIN/END_DECLS instead of __cplusplus
+
+	* gst/videocrop/gstvideocrop.c: (gst_video_crop_chain):
+	  Use gst_buffer_stamp instead of only copying the TIMESTAMP
+
+2005-02-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/subparse/gstsubparse.c:
+	  Fix OSX buildbot.
+
+2005-01-31  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/theora/theoraenc.c: (theora_buffer_from_packet),
+	(theora_enc_chain), (theora_enc_change_state):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_init),
+	(gst_vorbisenc_buffer_from_packet), (gst_vorbisenc_chain),
+	(gst_vorbisenc_change_state):
+	* ext/vorbis/vorbisenc.h:
+	  Set granulepos and timestamp correctly for streams not
+	  starting at 0, taking into account the initial delay.
+
+2005-01-31  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/mpegstream/gstdvddemux.c:
+	  Add audio/x-dts to audio pad template caps
+
+2005-01-30  David Schleef  <ds@schleef.org>
+
+	* ext/polyp/polypsink.c: (gst_polypsink_base_init),
+	(create_context), (gst_polypsink_link): Fix silly endianness
+	bug.  Add some debugging.  Remove float from caps; it doesn't
+	work.  Attempt to get remote audio working.
+
+2005-01-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_video_caps):
+	  Add 3IV2 fourcc.
+
+2005-01-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_add_stream), (swap_line),
+	(gst_avi_demux_invert), (gst_avi_demux_process_next_entry),
+	(gst_avi_demux_stream_data):
+	* gst/avi/gstavidemux.h:
+	  Invert DIB images. Fixes #132341.
+
+2005-01-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcsp_chain):
+	  D'oh, reference the palette data, not the palette structure.
+	  Fixes color distortion in #132341.
+
+2005-01-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_link):
+	  PAR can be non-fixed when not provided as argument (#162626).
+
+2005-01-29  David Moore  <dcm@acm.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_change_state),
+	(gst_qtdemux_loop_header):
+	  Re-apply patch from #142272 that allows non-seekable sources,
+	  re-proposed by Daniel Drake <dsd@gentoo.org>.
+
+2005-01-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/rtp/gstrtpgsmenc.c: (gst_rtpgsmenc_init):
+	  Use the src template for creating the src pad (#162330).
+
+2005-01-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/musepack/Makefile.am:
+	* ext/musepack/gstmusepackdec.c: (gst_musepackdec_class_init),
+	(gst_musepackdec_init), (gst_musepackdec_dispose),
+	(gst_musepackdec_src_query), (gst_musepackdec_src_convert),
+	(gst_musepack_stream_init), (gst_musepackdec_loop),
+	(gst_musepackdec_change_state):
+	* ext/musepack/gstmusepackdec.cpp:
+	* ext/musepack/gstmusepackdec.h:
+	* ext/musepack/gstmusepackreader.c: (gst_musepack_reader_peek),
+	(gst_musepack_reader_read), (gst_musepack_reader_seek),
+	(gst_musepack_reader_tell), (gst_musepack_reader_get_size),
+	(gst_musepack_reader_canseek), (gst_musepack_init_reader):
+	* ext/musepack/gstmusepackreader.cpp:
+	* ext/musepack/gstmusepackreader.h:
+	  Update to 1.1 API (#165446).
+
+2005-01-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/Makefile.am:
+	  Unbreak buildbot.
+
+2005-01-28  Andy Wingo  <wingo@pobox.com>
+
+	* ext/dv/gstdvdec.c: Change the pixel aspect ratio of dvdec output
+	to reflect a different dubious internet source. Add a reference
+	and some commentary.
+
+2005-01-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gststreamselector.c: (gst_stream_selector_init),
+	(gst_stream_selector_get_caps), (gst_stream_selector_chain):
+	* gst/playback/gststreamselector.h:
+	  Be more selective when we're redoing caps negotiation from
+	  within the chain function on a stream change.
+
+2005-01-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/amrnb/Makefile.am:
+	* ext/amrnb/amrnb.c: (plugin_init):
+	* ext/amrnb/amrnbdec.c: (gst_amrnbdec_get_type),
+	(gst_amrnbdec_base_init), (gst_amrnbdec_class_init),
+	(gst_amrnbdec_init), (gst_amrnbdec_link), (gst_amrnbdec_chain),
+	(gst_amrnbdec_state_change):
+	* ext/amrnb/amrnbdec.h:
+	* ext/amrnb/amrnbparse.c: (gst_amrnbparse_get_type),
+	(gst_amrnbparse_base_init), (gst_amrnbparse_class_init),
+	(gst_amrnbparse_init), (gst_amrnbparse_formats),
+	(gst_amrnbparse_querytypes), (gst_amrnbparse_query),
+	(gst_amrnbparse_handle_event), (gst_amrnbparse_reserve),
+	(gst_amrnbparse_loop), (gst_amrnbparse_state_change):
+	* ext/amrnb/amrnbparse.h:
+	  Add support for AMR-NB (mobile phone audio format; #155163, #163286).
+	* gst/typefind/gsttypefindfunctions.c: (plugin_init):
+	  Add AMR-NB/-WB raw formats.
+	* ext/alsa/gstalsa.c: (gst_alsa_link):
+	  Keep valid time when changing format.
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(qtdemux_parse_trak):
+	  Add some more format-specific options (#140141, #143555, #155163).
+
+2005-01-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_blockgroup):
+	  Fix logic error in timing of subtitle stream synchronization.
+	* gst/typefind/gsttypefindfunctions.c: (qt_type_find):
+	  Add skip-chunk, which is found in kodak-camera streams.
+
+2005-01-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/vi.po:
+	  Adding Vietnamese translation (submitted by Clytie Siddall)
+
+2005-01-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstdecodebin.c: (try_to_link_1):
+	  Use realpad for signal.
+
+2005-01-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstid3demuxbin.c: (gst_id3demux_bin_base_init):
+	  Fix category so decodebin picks it up.
+
+2005-01-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/Makefile.am:
+	* ext/mad/gstid3demuxbin.c: (gst_id3demux_bin_get_type),
+	(gst_id3demux_bin_base_init), (gst_id3demux_bin_class_init),
+	(gst_id3demux_bin_init), (gst_id3demux_bin_remove_pad),
+	(found_type), (gst_id3demux_bin_change_state):
+	* ext/mad/gstid3tag.c: (gst_id3_tag_add_src_pad),
+	(gst_id3_tag_init), (gst_id3_tag_handle_event),
+	(gst_id3_tag_src_link), (gst_id3_tag_chain),
+	(gst_id3_tag_change_state), (plugin_init):
+	* ext/mad/gstmad.h:
+	  Add id3demuxbin (which is a simple bin consisting of id3demux
+	  and typefind), take over rank from id3demux, remove typefind
+	  code from id3demux. Makes all broken mp3s that I know of work,
+	  and thereby fixes #152688.
+
+2005-01-27  Edward Hervey  <bilboed@bilboed.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstmad.c: (gst_mad_src_event):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_event):
+	  Allow seeks on audio pad, make mad forward those (#164826).
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_chain):
+	  Set duration (#165335).
+
+2005-01-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_init),
+	(gst_asf_demux_commit_taglist), (gst_asf_demux_process_comment),
+	(gst_asf_demux_process_ext_content_desc),
+	(gst_asf_demux_change_state), (gst_asf_demux_add_audio_stream),
+	(gst_asf_demux_add_video_stream), (gst_asf_demux_setup_pad):
+	* gst/asfdemux/gstasfdemux.h:
+	  Improve metadata display, e.g. if the metadata comes before the
+	  streams are loaded (which is perfectly valid).
+
+2005-01-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* tools/gst-launch-ext-m.m:
+	  Fix AVI/ASF pipelines (#165340).
+
+2005-01-26  Amaury Jacquot  <sxpert@esitcom.org>
+	* ext/cairo/gsttextoverlay.c: include  string.h and strings.h to fix
+	build failure on amd64
+
+2005-01-26  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/mad/gstid3tag.c: (mad_id3_parse_latin1_string),
+	(mad_id3_parse_comment_frame), (gst_mad_id3_to_tag_list):
+	  Check environment variables GST_ID3V2_TAG_ENCODING,
+	  GST_ID3_TAG_ENCODING and GST_TAG_ENCODING for a colon-separated
+	  list of character encodings to force interpretation of non-unicode
+	  strings stored in an ID3v2 tag to a particular encoding. If none
+	  is specified, try to use current locale's encoding, then fall back
+	  to ISO-8859-1 (which will always succeed). (Resolves #149274)
+	* gst/tags/gstid3tag.c: (gst_tag_from_id3_tag),
+	(gst_tag_extract_id3v1_string), (gst_tag_list_new_from_id3v1):
+	  Check environment variables GST_ID3V1_TAG_ENCODING,
+	  GST_ID3_TAG_ENCODING and GST_TAG_ENCODING for a colon-separated
+	  list of character encodings to use in case a string encountered
+	  in an ID3v1 tag is not valid UTF-8 already. If no encoding is
+	  specified, try to use the current locale's encoding, then fall
+	  back to ISO-8859-1 (which will always succeed).
+
+2005-01-25  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstmad.c: (gst_mad_check_caps_reset), (gst_mad_chain):
+	  - on half framerate, compute the rate in advance so the comparisons
+	    don't compare wrong values
+	  - don't use mad_synth/frame_mute anymore, this mirrors mad_decoder
+	    behaviour
+	  - don't use mad_header_decode anymore, mad_frame_decode does that
+	    automatically
+	  - when getting rid of consumed bytes, reset the stream's skiplen
+	  (fixes #163867)
+
+2005-01-26  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_class_init)
+	  Use 1/2 a second for default max_discont, as PES streams from DVB
+	  seem to have larger spacings in the SCR. 
+	  Fix a typo.
+
+2005-01-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (group_commit):
+	  Notify delayed stream-info availability.
+
+2005-01-26  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_push),
+	(gst_a52dec_handle_event), (gst_a52dec_chain):
+	Add some debug output. Check that a discont has a valid
+	time associated.
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event),
+	(gst_alsa_sink_loop):
+	Ignore TAG events. A little extra debug for broken timestamps.
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_init), (dvdnavsrc_loop),
+	(dvdnavsrc_change_state):
+	Ensure we send a discont to engage the link before we send any
+	other events.
+	* ext/dvdread/dvdreadsrc.c: (dvdreadsrc_init),
+	(dvdreadsrc_finalize), (_close), (_open), (_seek_title),
+	(_seek_chapter), (seek_sector), (dvdreadsrc_get),
+	(dvdreadsrc_uri_get_uri), (dvdreadsrc_uri_set_uri):
+	Handle URI of the form dvd://title[,chapter[,angle]]. Currently only
+	dvd://title works in totem because typefinding sends a seek that ends
+	up going back to chapter 1 regardless.
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	* ext/mpeg2dec/gstmpeg2dec.h:
+	Output correct timestamps and handle disconts.
+	* ext/ogg/gstoggdemux.c: (get_relative):
+	Small guard against a null dereference.
+	* ext/pango/gsttextoverlay.c: (gst_textoverlay_finalize),
+	(gst_textoverlay_set_property):
+	Free memory when done. Don't call gst_event_filler_get_duration on
+	EOS events. Use GST_LOG and GST_WARNING instead of g_message and
+	g_warning.
+	* ext/smoothwave/gstsmoothwave.c: (gst_smoothwave_init),
+	(draw_line), (gst_smoothwave_dispose), (gst_sw_sinklink),
+	(gst_sw_srclink), (gst_smoothwave_chain):
+	Draw solid lines, prettier colours.
+	* gst/mpeg2sub/gstmpeg2subt.c: (gst_mpeg2subt_init):
+	Add a default palette that'll work for some movies.
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_init),
+	(gst_dvd_demux_handle_dvd_event), (gst_dvd_demux_send_discont),
+	(gst_dvd_demux_send_subbuffer), (gst_dvd_demux_reset):
+	* gst/mpegstream/gstdvddemux.h:
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_send_discont),
+	(gst_mpeg_demux_parse_syshead), (gst_mpeg_demux_parse_pes):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_init),
+	(gst_mpeg_parse_handle_discont), (gst_mpeg_parse_parse_packhead):
+	* gst/mpegstream/gstmpegparse.h:
+	Use PTM/NAV events when for timestamp adjustment when connected to 
+	dvdnavsrc. Don't use many discont events where one suffices.
+	* gst/playback/gstplaybasebin.c: (group_destroy),
+	(gen_preroll_element), (gst_play_base_bin_add_element):
+	* gst/playback/gstplaybasebin.h:
+	Make sure we remove subtitles from the same bin we put them in.
+	* gst/subparse/gstsubparse.c: (convert_encoding), (parse_subrip),
+	(gst_subparse_buffer_format_autodetect),
+	(gst_subparse_change_state):
+	Fix some memleaks and invalid accesses.
+	* gst/typefind/gsttypefindfunctions.c: (ogganx_type_find),
+	(oggskel_type_find), (cmml_type_find), (plugin_init):
+	Some typefind functions for Annodex v3.0 files
+	* gst/wavparse/gstwavparse.h:
+	GstRiffReadClass is the correct parent class.
+
+2005-01-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data):
+	  Add extradata to huffyuv (fixes #165013).
+	* gst-libs/gst/riff/riff-read.c:
+	(gst_riff_read_strf_vids_with_data):
+	  Fix extradata extraction if it is in the chunk size.
+
+2005-01-25  Edward Hervey  <bilboed@bilboed.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/effectv/gstquark.c: (gst_quarktv_class_init),
+	(gst_quarktv_change_state), (gst_quarktv_dispose):
+	  Memory free'ing location fix (#164708).
+
+2005-01-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (group_commit),
+	(gen_preroll_element), (probe_triggered), (gen_source_element),
+	(setup_source), (gst_play_base_bin_change_state),
+	(gst_play_base_bin_add_element):
+	  Don't block for streams.
+	* gst/playback/gststreaminfo.c: (stream_info_change_state),
+	(gst_stream_info_set_mute):
+	  Use gst_pad_set_active_recursive.
+
+2005-01-25  Andy Wingo  <wingo@pobox.com>
+
+	* sys/v4l/gstv4lelement.c (gst_v4l_iface_supported): Fix compile
+	for #ifndef HAVE_XVIDEO.
+
+2005-01-24  Jeffrey C. Ollie
+
+	reviewed by: Maciej Katafiasz  <mathrick@freedesktop.org>
+
+	* ext/gsm/gstgsmdec.c: (gst_gsmdec_init), (gst_gsmdec_chain):
+	* ext/gsm/gstgsmdec.h:
+	* ext/gsm/gstgsmenc.c: (gst_gsmenc_init), (gst_gsmenc_chain):
+	* ext/gsm/gstgsmenc.h:
+	Fix rate to 8kHz as per spec, removes obscure errors when no rate
+	was given by property. Add proper buffer timestamps and offsets.
+
+2005-01-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_audio_caps_with_data):
+	  Audio can be <8000Hz.
+
+2005-01-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_change_state):
+	  Explicit state change to workaround refcount bugs.
+
+2005-01-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavimux.c: (gst_avimux_write_tag),
+	(gst_avimux_riff_get_avi_header):
+	  Fix...
+
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_element_data),
+	(gst_riff_read_element_data):
+	* gst-libs/gst/riff/riff-read.h:
+	  Add _peek version (req'ed in CDXA).
+	* gst/cdxaparse/gstcdxaparse.c: (gst_cdxaparse_init),
+	(gst_cdxaparse_loop):
+	  Fix parsing in playbin.
+	* gst/playback/gstdecodebin.c: (close_pad_link):
+	  Ignore current_ pads, they cause major annoyance.
+
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  Safety guard.
+
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavimux.c: (gst_avimux_write_tag):
+	  Fix padding...
+
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/ebml-read.c: (gst_ebml_read_buffer):
+	  Allow for 0-sized buffers. Fixes length query problems in
+	  starwars.mkv from the testsuite.
+
+2005-01-19  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* gst/videobox/gstvideobox.c: (gst_video_box_copy_plane_i420),
+	(gst_video_box_i420), (gst_video_box_chain):
+	  Fix row strides for I420 (fixes #163159)
+	  
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_parse_packhead):
+	  MPEG2 has a useful rate property, so we can actually use that.
+	  For MPEG-1, continue using the bytes/time properties.
+
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_video_template_caps):
+	  Add intel-h263.
+
+2005-01-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstmad.c: (gst_mad_check_caps_reset), (gst_mad_chain):
+	  Fail if caps negotiation fails. Should fix #162184, and should
+	  definately be in there regardless of it fixing the actual bug.
+	* gst/avi/gstavimux.c: (gst_avimux_get_type), (gst_avimux_init),
+	(gst_avimux_write_tag), (gst_avimux_riff_get_avi_header),
+	(gst_avimux_riff_get_avix_header),
+	(gst_avimux_riff_get_video_header),
+	(gst_avimux_riff_get_audio_header), (gst_avimux_write_index),
+	(gst_avimux_start_file), (gst_avimux_handle_event),
+	(gst_avimux_change_state):
+	* gst/avi/gstavimux.h:
+	  Refactor structure writing to use GST_WRITE_UINT macros, add
+	  metadata writing support.
+
+2005-01-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gststreaminfo.c: (gst_stream_info_dispose):
+	  Elements may already be destroyed when this function is called.
+
+2005-01-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_change_state),
+	(gst_qtdemux_loop_header), (gst_qtdemux_handle_esds):
+	  More memory leak fixes (#149162).
+
+2005-01-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_change_state),
+	(gst_qtdemux_add_stream):
+	  Fix two memleaks.
+
+2005-01-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faad/gstfaad.c: (gst_faad_srcgetcaps):
+	  Argh...
+
+2005-01-17  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faad/gstfaad.c: (gst_faad_srcgetcaps):
+	  Fix off-by-one bug. Fixes warnings during playback of sincity.mp4
+	  when fixating to six channels in Totem.
+
+2005-01-17  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/dvdread/dvdreadsrc.c: (get_next_cell_for):
+	  Fix compile warnings on Solaris 10 buildbot
+
+2005-01-17  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/dvdread/dvdreadsrc.c: (_read):
+	  Don't read beyond the last cell in a chapter (fixes 
+	  invalid memory access)
+
+2005-01-17  Tim-Philipp Müller  <tim at centricular dot net>
+
+	* ext/dvdread/stream_labels.c:
+	(dvdreadsrc_get_audio_stream_labels):
+	  Use NULL for an empty GList instead of g_list_alloc(); fix 
+	  memory leaks; s/LCPM/LPCM/; use g_strdup_printf() instead 
+	  of GString (easier to bulk free later)
+
+2005-01-17  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_pixfmt_to_caps):
+	  Fix BGRA32 caps (#164209).
+
+2005-01-17  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_caps_to_pixfmt):
+	  alpha_mask can be RGBA/ABGR. Fixes #164265.
+
+2005-01-17  Francis Labonte  <francis_labonte@hotmail.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (crop_buffer),
+	(gst_mpeg2dec_alloc_buffer):
+	* ext/mpeg2dec/gstmpeg2dec.h:
+	  Crop if decoding size is not the actual image size (#163676).
+
+2005-01-17  Steve Baker  <steve@stevebaker.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c: (aiff_type_find),
+	(svx_type_find), (sds_type_find), (ircam_type_find), (plugin_init):
+	  Add libsndfile typefind functions (#163309).
+
+2005-01-17  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* tools/gst-launch-ext-m.m:
+	  Add .aac, fix .m1v/.m2v (#163891).
+
+2005-01-17  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsaclock.c: (gst_alsa_clock_wait):
+	  Sanity check, don't wait endlessly since the clock might not
+	  actually run at this point (which is a deadlock). Fixes #164069.
+
+2005-01-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (probe_triggered):
+	  Of course, only pause if group is done...
+
+2005-01-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (probe_triggered):
+	  Thread safety.
+
+2005-01-16  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/swfdec/gstswfdec.c: (gst_swfdec_change_state):
+	  Don't return state change success when the parent
+	  failed.
+
+2005-01-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavimux.c: (gst_avimux_handle_event):
+	  Free events (fix memleak in #162905).
+
+2005-01-15  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_caps_to_pixfmt):
+	  Fix for depth = 15. Fixes #161675.
+
+2005-01-14  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_getcaps):
+	  Set FPS correctly, even for webcams and the like.
+	* sys/v4l/v4l_calls.c: (gst_v4l_set_chan_norm):
+	  Don error on setting while capturing.
+
+2005-01-14  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dv/gstdvdec.c:
+	* gst/subparse/gstsubparse.c: (parse_mdvdsub):
+	* gst/y4m/gsty4mencode.c: (gst_y4mencode_sinkconnect):
+	  I'm a bad boy. using /1001. to force C to do float division
+	  and not integer division (as it did in my last commit)
+	  Thanks to David I. Lehn for pointing this mistake.
+
+2005-01-14  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lelement.c: (gst_v4l_iface_supported):
+	  Revert Johan´s 1.35->1.36 since it breaks compat.
+
+2005-01-14  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dv/gstdvdec.c:
+	* ext/libfame/gstlibfame.c:
+	* gst/subparse/gstsubparse.c: (parse_mdvdsub):
+	* gst/y4m/gsty4mencode.c: (gst_y4mencode_sinkconnect):
+          replace framerate aproximations by their real value
+          (24000/1001, 30000/1001, 60000/1001)
+          Finish fixing bug #164049
+
+2005-01-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/ogg/gstoggmux.c:
+	  eos/bos debugging
+	* gst/tcp/gstmultifdsink.c:
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcp.c:
+	* gst/tcp/gsttcp.h:
+	* gst/tcp/gsttcpclientsink.c:
+	* gst/tcp/gsttcpclientsrc.c:
+	* gst/tcp/gsttcpserversink.c:
+	* gst/tcp/gsttcpserversrc.c:
+	  improve reusability of elements after state changes and errors
+	  make multifdsink throw away streamheaders when receiving new ones
+
+2005-01-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_rates_probe):
+	  Fix for if items are already in list...
+
+2005-01-12  Benjamin Otte  <otte@gnome.org>
+
+	* gst/adder/gstadder.c: (gst_adder_loop):
+	  fix adder a bit so it doesn't screw up with events as much anymore
+
+2005-01-12  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/gdk_pixbuf/pixbufscale.c: (gst_pixbufscale_link),
+	(pixbufscale_scale), (gst_pixbufscale_chain):
+	* ext/gdk_pixbuf/pixbufscale.h:
+	  Incorporate changes from Tim-Philipp Mueller <t.i.m@orange.net>
+	  to ensure rowstrides are calculated the same way as 
+	  ffmpegcolorspace
+	  Use gst_buffer_stamp instead of copying TIMESTAMP manually, so
+	  that we pick up duration and offset also.
+
+2005-01-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavimux.c: (gst_avimux_class_init),
+	(gst_avimux_pad_unlink), (gst_avimux_release_pad):
+	  Reusability fixes.
+
+2005-01-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_update),
+	(gst_alsa_mixer_get_volume), (gst_alsa_mixer_set_volume),
+	(gst_alsa_mixer_set_mute), (gst_alsa_mixer_set_record),
+	(gst_alsa_mixer_set_option), (gst_alsa_mixer_get_option):
+	  Update flags when requested.
+
+2005-01-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_rates_probe):
+	  Fix dmix.
+
+2005-01-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init),
+	(gst_play_base_bin_init), (gst_play_base_bin_dispose),
+	(probe_triggered), (new_decoded_pad), (gen_source_element),
+	(gst_play_base_bin_set_property), (gst_play_base_bin_get_property):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gst_play_bin_class_init),
+	(gst_play_bin_init), (group_switch), (remove_sinks), (setup_sinks),
+	(gst_play_bin_change_state):
+	  Implement group-switch signal for use in apps to clear metadata
+	  cache, clean up subtitle, add suburi property instead of # hack,
+	  some error-out fixes.
+
+2005-01-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+	  Debug.
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_grab_frame):
+	  If we got a state change in the _get handler, don't return success.
+
+2005-01-10  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/jpeg/gstjpegdec.c: (gst_jpegdec_my_output_message),
+	(gst_jpegdec_my_emit_message), (gst_jpegdec_init):
+	  Make jpegdec quiet on MJPEG decoding
+	* gst/asfdemux/README:
+	  Fix mimetypes for MJPEG and H263
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	  Fix broken code generation by gcc by swapping arguments.
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_src_query):
+	  Fix \n in debug.
+
+2005-01-10  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* TODO:
+	  delete this file, it is by far outdated
+	* ext/alsa/gstalsa.1: remove
+	* ext/alsa/gstalsa.c: (add_rates), (add_channels), (gst_alsa_caps),
+	(gst_alsa_check_sample_rates), (gst_alsa_rates_probe),
+	(gst_alsa_get_caps):
+	  Add HW probing for supported sample rates. Fixes #161704
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_chain):
+	  Don't crash, biatch! :).
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/musepack/gstmusepackreader.cpp:
+	* gst/apetag/apedemux.c: (gst_ape_demux_stream_data):
+	  Some work on tags - still doesn't work in playbin...
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_chain):
+	  Handle events...
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse_tree):
+	  Also shove tags on kid pads.
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_use_event):
+	  Don't bail on unknown events.
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_chain):
+	  Don't crash on events before negotiation.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_add_stream):
+	  Send tags on pads, too.
+	* gst/playback/gststreamselector.c:
+	(gst_stream_selector_request_new_pad):
+	  Forward events on first pad if no input was selected yet.
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (setup_substreams):
+	  Don't disable streamtype if the stream doesn't exist, since
+	  then playing a video after audio will disable both and nothing
+	  will happen. Fixes the testsuite.
+
+2005-01-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lxoverlay.c: (gst_v4l_xoverlay_interface_init),
+	(gst_v4l_xoverlay_set_xwindow_id):
+	* sys/v4l2/gstv4l2xoverlay.c: (gst_v4l2_xoverlay_interface_init),
+	(gst_v4l2_xoverlay_set_xwindow_id):
+	  Add debug categories, fix overlay disabling.
+
+2005-01-10  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_class_init), (gst_alsa_get_caps):
+	* ext/alsa/gstalsa.h:
+	  Add HW probing for period_count/size and buffer_size MIX/MAX
+	  Adjust default/user defined value if out of bounds
+	  Should fix bug #162024
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_handle_sink_event):
+	  Fix warning (#161191).
+
+2005-01-09  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dvdread/stream_labels.c:
+	(dvdreadsrc_get_audio_stream_labels):
+	  Fix warning (init the good variable in switch default)
+
+2005-01-09  Koop Mast  <kwm@rainbow-runner.nl>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/tta/gstttaparse.c: (gst_tta_src_event):
+	  Fix gcc-2.95 compile (#163485).
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/flac/gstflacenc.c: (gst_flacenc_init),
+	(gst_flacenc_seek_callback), (gst_flacenc_write_callback),
+	(gst_flacenc_tell_callback), (gst_flacenc_chain),
+	(gst_flacenc_change_state):
+	* ext/flac/gstflacenc.h:
+	  Update for API change in flac-1.1.1. Update requirement in
+	  configure.ac. Fixes #162974.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (group_destroy):
+	  Remove hack to get rid of assert and get rid of unlinked
+	  signals properly.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (setup_source):
+	  Set source to NULL so that resources are free'ed. Fixes issues
+	  with playback of CDDA and similar device-accessing things.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* testsuite/embed/Makefile.am:
+	  test->noinst, fix make test in buildbot.
+
+2005-01-09  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dvdread/stream_labels.c: new file
+	* ext/dvdread/stream_labels.h: new file
+	* ext/dvdread/Makefile.am:
+	* ext/dvdread/dvdreadsrc.c: (_seek_title):
+	  Extract audio stream label from DVD IFO files.
+	  It only dump them on the console for now, still have to
+	  make playbin aware of them.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (setup_source):
+	  Fix hanging subs.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_init),
+	(gen_preroll_element), (remove_groups), (setup_subtitle),
+	(gen_source_element), (setup_source):
+	* gst/playback/gstplaybasebin.h:
+	  Multiple .sub files is just a stupid idea... Fix some threading
+	  mistakes. Interestingly, external .sub files cause playbin to
+	  hang, I don't know why... Parsing fixes contributed by François
+	  Kooman <fkooman@tuxed.net>.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* testsuite/embed/Makefile.am:
+	  Fix buildbot.
+
+2005-01-09  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/libpng/gstpngenc.c: (gst_pngenc_class_init),
+	(gst_pngenc_init), (gst_pngenc_chain), (gst_pngenc_get_property),
+	(gst_pngenc_set_property):
+	* ext/libpng/gstpngenc.h:
+	  Add compression level property (#163323).
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* examples/capsfilter/capsfilter1.c: (main):
+	* examples/seeking/spider_seek.c: (make_spider_pipeline):
+	* ext/dvdread/Makefile.am:
+	* ext/dvdread/demo-play:
+	* ext/dvdread/demo-play.c:
+	* gconf/gstreamer.schemas.in:
+	* gst-libs/gst/gconf/gconf.c:
+	* sys/v4l/TODO:
+	* testsuite/Makefile.am:
+	* testsuite/embed/Makefile.am:
+	* testsuite/embed/embed.c: (cb_expose), (main):
+	  Remove all references to xvideosink, fix examples (#140845).
+	* gst/playback/gstplaybasebin.c: (group_destroy):
+	  Apparently, disposal does not unlink - so do explicitely.
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  Add debug.
+
+2005-01-09  Maciej Katafiasz <mathrick@freedesktop.org>
+
+	* README: fix PKG_CONFIG_PATH instructions, what was there
+	previously was breaking default search path, not nice. 
+	Fixes #163358
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_init),
+	(gst_audioscale_chain):
+	  %#^@^#@^@#^#@^#@^@#^@#^@#^@#^#@^#@^#@^@#^#@ fix seeking
+	  when resampling - how the ^@$^!@^! is this possible?!?
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state):
+	  Reset variables on READY.
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_request_new_pad),
+	(gst_matroska_mux_loop):
+	  Require data before writing header.
+
+2005-01-09  Francis Labonte  <francis_labonte@hotmail.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstmad.c: (gst_mad_chain):
+	  Don't call mad_stream_sync() directly after recovering sync.
+	  Fixes #151661.
+
+2005-01-09  Martin Eikermann  <meiker@upb.de>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/snapshot/gstsnapshot.c: (gst_snapshot_class_init),
+	(snapshot_handler), (gst_snapshot_sinkconnect),
+	(gst_snapshot_chain):
+	  Allocate resources when required, fix recursive signal emission
+	  and fix caps. Fixes #161667.
+
+2005-01-09  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/libpng/gstpngdec.c: (gst_pngdec_src_getcaps),
+	(gst_pngdec_chain):
+	  Handle only 8-bppc (bits-per-pixel-component) images, better
+	  error handling and correct strides. Fixes #163177.
+	* ext/libpng/gstpngenc.c: (gst_pngenc_sinklink),
+	(gst_pngenc_chain):
+	  Better error handling. Fixes #163348.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_get_type),
+	(dvdnavsrc_uri_get_type), (dvdnavsrc_uri_get_protocols),
+	(dvdnavsrc_uri_get_uri), (dvdnavsrc_uri_set_uri),
+	(dvdnavsrc_uri_handler_init):
+	  Add DVD-nav URI (dvdnav://) for Totem testing purposes.
+	* gst/playback/gstplaybasebin.c: (gen_source_element):
+	  Add MMS to streaming URIs.
+
+2005-01-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_navigation_send_event):
+	* sys/xvimage/xvimagesink.c:
+	(gst_xvimagesink_navigation_send_event):
+	  Check for pad availability before sending event.
+
+2005-01-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-plugins.spec.in:
+	  Add subparse.
+
+2005-01-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	  Since we use functions from CVS, up requirement.
+
+2005-01-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/Makefile.am:
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init),
+	(group_destroy), (group_commit), (group_is_muted),
+	(gen_preroll_element), (add_stream), (unknown_type),
+	(probe_triggered), (preroll_unlinked), (mute_stream),
+	(silence_stream), (new_decoded_pad), (setup_substreams),
+	(setup_source), (get_active_source), (mute_group_type),
+	(muted_group_change_state), (set_active_source),
+	(gst_play_base_bin_set_property), (gst_play_base_bin_get_property),
+	(play_base_eos), (gst_play_base_bin_change_state):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (add_sink), (setup_sinks):
+	* gst/playback/gststreaminfo.c: (gst_stream_info_class_init),
+	(gst_stream_info_dispose), (stream_info_mute_pad),
+	(stream_info_change_state), (gst_stream_info_set_mute):
+	* gst/playback/gststreamselector.c: (gst_stream_selector_get_type),
+	(gst_stream_selector_base_init), (gst_stream_selector_class_init),
+	(gst_stream_selector_init), (gst_stream_selector_dispose),
+	(gst_stream_selector_get_linked_pad),
+	(gst_stream_selector_get_caps), (gst_stream_selector_link),
+	(gst_stream_selector_get_linked_pads),
+	(gst_stream_selector_request_new_pad), (gst_stream_selector_chain):
+	* gst/playback/gststreamselector.h:
+	  Adding stream selection support plus required properties for
+	  applications to use this. Fully fixes #100931.
+
+2005-01-08  Benjamin Otte  <otte@gnome.org>
+
+	* gst/games/gstpuzzle.c: (nav_event_handler):
+	  - handle nav events differently: forward every event no matter if it
+	    was handled or not.
+	  - translate events
+	  You can now cheat by using navigationtest ! puzzle and moving the
+	  mouse close to the edge of a tile. ;)
+
+2005-01-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_new):
+	* ext/ogg/gstogmparse.c: (gst_ogm_text_parse_get_type),
+	(gst_ogm_text_parse_base_init), (gst_ogm_text_parse_init),
+	(gst_ogm_parse_get_sink_querytypes), (gst_ogm_parse_sink_convert),
+	(gst_ogm_parse_sink_query), (gst_ogm_parse_chain),
+	(gst_ogm_parse_plugin_init):
+	* ext/pango/gsttextoverlay.c: (gst_textoverlay_linkedpads),
+	(gst_textoverlay_link), (gst_textoverlay_getcaps),
+	(gst_textoverlay_event), (gst_textoverlay_video_chain),
+	(gst_textoverlay_loop), (gst_textoverlay_init), (plugin_init):
+	* ext/pango/gsttextoverlay.h:
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_add_stream),
+	(gst_matroska_demux_handle_seek_event),
+	(gst_matroska_demux_sync_streams),
+	(gst_matroska_demux_parse_blockgroup),
+	(gst_matroska_demux_subtitle_caps),
+	(gst_matroska_demux_plugin_init):
+	* gst/matroska/matroska-ids.h:
+	* gst/playback/gstdecodebin.c: (close_pad_link):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_init),
+	(gen_preroll_element), (remove_groups), (add_stream),
+	(new_decoded_pad), (setup_subtitles), (gen_source_element),
+	(setup_source):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gen_text_element), (setup_sinks):
+	* gst/subparse/Makefile.am:
+	* gst/subparse/gstsubparse.c: (gst_subparse_get_type),
+	(gst_subparse_base_init), (gst_subparse_class_init),
+	(gst_subparse_init), (gst_subparse_formats),
+	(gst_subparse_eventmask), (gst_subparse_event),
+	(gst_subparse_handle_event), (convert_encoding), (get_next_line),
+	(parse_mdvdsub), (parse_mdvdsub_init), (parse_subrip),
+	(parse_subrip_deinit), (parse_subrip_init), (parse_mpsub),
+	(parse_mpsub_deinit), (parse_mpsub_init),
+	(gst_subparse_buffer_format_autodetect),
+	(gst_subparse_format_autodetect), (gst_subparse_loop),
+	(gst_subparse_change_state), (gst_subparse_type_find),
+	(plugin_init):
+	* gst/subparse/gstsubparse.h:
+	* gst/typefind/gsttypefindfunctions.c: (ogmtext_type_find),
+	(plugin_init):
+	  Add subtitle support, .sub parser (supports SRT and MPsub),
+	  OGM text support, Matroska UTF-8 text support, deadlock fixes
+	  all over the place, subtitle awareness in decodebin/playbin
+	  and some fixes to textoverlay to handle subtitles in a stream
+	  correctly. Fixes #100931.
+
+2005-01-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_src_query):
+	  Check for pad availability before doing a query on it.
+
+2005-01-08  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dv/gstdvdec.c:
+	  really fix bpp24/32 dvdec caps (classic rgba indeed)
+	* gst/asfdemux/gstasfdemux.c:
+	(gst_asf_demux_process_ext_content_desc):
+	  don't send text tags if they are empty (bis repetita)
+
+2005-01-08  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dv/gstdvdec.c:
+	 remove unneeded comment from dvdec
+	  (related to DV 4CC codes in AVI files)
+	  moved them in gstreamer/docs/random/mimetypes
+	* gst/asfdemux/gstasfdemux.c:
+	(gst_asf_demux_process_ext_content_desc):
+	 don't send text tags if they are empty
+	 fix mem leak on error path
+	* gst/ffmpegcolorspace/avcodec.h:
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_pixfmt_to_caps), (gst_ffmpeg_caps_to_pixfmt),
+	(gst_ffmpegcsp_avpicture_fill):
+	* gst/ffmpegcolorspace/imgconvert.c: (img_get_alpha_info):
+	* gst/ffmpegcolorspace/imgconvert_template.h:
+	 adds BGR32 and BGRA32 to ffmpegcolorspace
+	  (still bad colors, fixing it on next commit)
+	  helps with dvdec outputing BGR32
+
+2005-01-08  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dv/gstdvdec.c:
+	 Fix audio caps i just broke (missing ',')
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_get_type),
+	(gst_matroska_mux_reset):
+	 Fix typo + add FIXME about old "x-gst-metadata" crap
+
+2005-01-07  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* ext/dv/demo-play.c: (main):
+	 xvideosink -> xvimagesink
+	* ext/dv/gstdvdec.c:
+	 change rgb 32/32 caps to 24/32 (no alpha)
+	 change nb of channels to be a list (2 or 4, not 2)
+	 change sample rate to be a list (32, 44.1, 48 kHz) not a range
+	* gst/asfdemux/gstasfdemux.c:
+	(gst_asf_demux_process_ext_content_desc):
+	 Add 'date/year' to extracted metadata list
+
+2005-01-07  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_fixate):
+	  The return value of fixate_to does not imply that the requested
+	  value was set, so don't assume.
+
+2005-01-07  Gergely Nagy  <algernon@bonehunter.rulez.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/libpng/gstpngdec.c:
+	* ext/libpng/gstpngenc.c: (gst_pngenc_base_init),
+	(gst_pngenc_sinklink), (gst_pngenc_init), (gst_pngenc_chain):
+	* ext/libpng/gstpngenc.h:
+	  Alpha support (encoder; #163161), mime fixage.
+
+2005-01-07  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faac/gstfaac.c: (gst_faac_outputformat_get_type),
+	(gst_faac_class_init), (gst_faac_init), (gst_faac_srcconnect),
+	(gst_faac_set_property), (gst_faac_get_property):
+	* ext/faac/gstfaac.h:
+	  Allow for ADTS output (#153434).
+
+2005-01-07  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_getcaps):
+	  Fix against template (#150576).
+
+2005-01-06  Benjamin Otte  <otte@gnome.org>
+
+	* gst/games/gstpuzzle.c: (draw_puzzle):
+	  don't draw a puzzle if either width or height of tiles would be 0.
+
+2005-01-06  Benjamin Otte  <otte@gnome.org>
+
+	* gst/games/gstpuzzle.c: (gst_puzzle_get_type),
+	(gst_puzzle_class_init), (gst_puzzle_finalize):
+	  no memleaks, please
+	(gst_puzzle_create), (gst_puzzle_init),
+	(gst_puzzle_set_property), (gst_puzzle_setup):
+	  change initialization code around so we don't reshuffle on resize
+	(draw_puzzle):
+	  fix another stupid typo
+
+2005-01-06  Benjamin Otte  <otte@gnome.org>
+
+	* gst/games/gstvideoimage.c: (copy_hline_YUY2):
+	  fix stupid typo that borked copying on YUY2
+
+2005-01-06  Benjamin Otte  <otte@gnome.org>
+
+	* gst/games/gstpuzzle.c: (draw_puzzle):
+	  fix edges when image sizes aren't multiples of tile sizes
+
+2005-01-06  Benjamin Otte  <otte@gnome.org>
+
+	* gst/games/gstpuzzle.c: (gst_puzzle_base_init):
+	  make RGB endianness work correctly
+	(gst_puzzle_show), (gst_puzzle_swap), (gst_puzzle_move):
+	  refactor and fix race with initial shuffling
+	(nav_event_handler):
+	  allow using the mouse to puzzle
+	(draw_puzzle):
+	  insist on tiles having width and height as multiples of 4 to get
+	  clean YUV image handling
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_new),
+	(gst_xvimagesink_handle_xevents), (gst_xvimagesink_buffer_alloc):
+	  s/DEBUG/LOG/ for common messages
+	(gst_xvimagesink_navigation_send_event):
+	  fix mouse event translation to not include screen PAR
+	* sys/ximage/ximagesink.c: (gst_ximagesink_navigation_send_event):
+	  fix mouse event translation to actually work
+
+2005-01-06  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* gst/asfdemux/gstasfdemux.c:
+	(gst_asf_demux_process_ext_content_desc):
+	 Extract TrackNumber metadata + clean up code
+	* gst/games/gstvideoimage.c: (gst_video_image_draw_rectangle):
+	 Hope this is the good fix (var used unitialised)
+
+2005-01-06  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faad/gstfaad.c: (gst_faad_chain):
+	  Only increment timestamp if it's valid. Fixes raw AAC streams.
+
+2005-01-06  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	* gst/games/Makefile.am:
+	* gst/games/gstpuzzle.c:
+	  add a puzzle game with...
+	* gst/games/gstvideoimage.c:
+	* gst/games/gstvideoimage.h:
+	  ... full colorspace support (that includes YUV9 and RGB16)) stolen
+	  from videotestsrc and made into something that would be a nice
+	  library for a lot of other plugins.
+
+2005-01-06  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* configure.ac:
+	 don't compile faad plugin if a RC of 2.0 is found
+	 Fixes #155346 (and FC1 buildbot)
+	* gst/asfdemux/gstasfdemux.c:
+	(gst_asf_demux_process_ext_content_desc):
+	 try to make Solaris compiler happier
+
+2005-01-06  Paul Jack  <pjack@sfaf.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/snapshot/gstsnapshot.c: (gst_snapshot_class_init):
+	  Fix segfault (#161667).
+
+2005-01-05  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_getcaps):
+	  Fix framerate reporting.
+
+2005-01-05  Stephane LOEUILLET  <stephane.loeuillet@tiscali.fr>
+
+	* gst-libs/gst/riff/riff-ids.h:
+	* gst/wavenc/riff.h:
+	 Add AMR (VBR and CBR) ids to riff.h audio codec list
+	* gst/asfdemux/gstasfdemux.c:
+	(gst_asf_demux_process_ext_content_desc),
+	(gst_asf_demux_process_object):
+	  Retrieve more tags from ASF files (Genre, AlbumTitle, Artist)
+
+2005-01-05  Martin Eikermann  <meiker@upb.de>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_class_init),
+	(gst_dvd_demux_handle_discont):
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_class_init),
+	(gst_mpeg_demux_handle_discont):
+	  Recreate pads on new-media (#160730).
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_new_pad):
+	  Send discont even if manager changes timestamps (#161929).
+
+2005-01-05  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/resample/resample.c: (gst_resample_sinc_ft_s16):
+	  Fix invalid memory access (#159211).
+
+2005-01-05  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* examples/gstplay/player.c: (main):
+	  Don't iterate.
+	* examples/seeking/seek.c: (fixate), (make_playerbin_pipeline):
+	  Add visualizations.
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_push),
+	(gst_a52dec_handle_frame):
+	  Set duration.
+	* ext/dvdnav/gst-dvd:
+	  Add audioconvert. Fixes #161325.
+	* ext/dvdread/dvdreadsrc.c: (dvdreadsrc_get):
+	  Explicitely case to gint64. Possible valgrind error.
+	* gst-libs/gst/play/play.c: (caps_set), (setup_size),
+	(gst_play_tick_callback), (gst_play_change_state),
+	(gst_play_dispose), (gst_play_init), (gst_play_class_init),
+	(gst_play_set_location), (gst_play_get_location),
+	(gst_play_seek_to_time), (gst_play_set_data_src),
+	(gst_play_set_video_sink), (gst_play_set_audio_sink),
+	(gst_play_set_visualization), (gst_play_connect_visualization),
+	(gst_play_get_framerate), (gst_play_get_all_by_interface),
+	(gst_play_new):
+	  Use playbin. Fixes #139749 and #147744.
+	* gst/apetag/apedemux.c: (gst_ape_demux_parse_tags):
+	  Add genre tag.
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_method_get_type),
+	(audioscale_get_type), (gst_audioscale_base_init),
+	(gst_audioscale_class_init), (gst_audioscale_expand_caps),
+	(gst_audioscale_getcaps), (gst_audioscale_fixate),
+	(gst_audioscale_link), (gst_audioscale_get_buffer),
+	(gst_audioscale_decrease_rate), (gst_audioscale_increase_rate),
+	(gst_audioscale_init), (gst_audioscale_dispose),
+	(gst_audioscale_chain), (gst_audioscale_set_property),
+	(gst_audioscale_get_property), (plugin_init):
+	  Indent properly.
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_process_private):
+	  Fix LPCM.
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse_udta),
+	(qtdemux_tag_add_str), (qtdemux_tag_add_num),
+	(qtdemux_tag_add_gnre), (qtdemux_video_caps):
+	  Add more metadata (fixes #162656).
+
+2005-01-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  back to cvs
+
+=== release 0.8.7 ===
+
+2005-01-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* NEWS:
+	* RELEASE:
+	* configure.ac:
+	  releasing 0.8.7, "Hyperspace"
+
+2005-01-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	* gst/playback/gstplaybasebin.c:
+	 Fix for #162924 - free caps after use, not before
+
+2005-01-04  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Ronald Bultje <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c:
+	* gst/wavparse/gstwavparse.c:
+	  Fix for #154773 - fixes playback of small .wav files
+
+2005-01-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Ronald Bultje <rbultje@ronald.bitfreak.net>
+
+	* gst/audioscale/gstaudioscale.c:
+	  Fix for #162819 - make audioscale reusable
+	  Fixes playback of more than one file with playbin/totem
+
+2004-12-29  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/avcodec.h:
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	* gst/ffmpegcolorspace/imgconvert.c:
+	  clean up the mess that made me cry and avoid needless duplication
+
+2004-12-29  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/imgconvert.c:
+	  give some indication of why we're segfaulting
+
+2004-12-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	  Fix indentation, fix v4l2 plugin detection.
+	* ext/Makefile.am:
+	  Fix libmms location (Maciej, use diff -u!).
+	* ext/alsa/gstalsa.c: (gst_alsa_init):
+	  Initialize caps cache to NULL.
+	* gst/playback/gstplaybin.c: (gst_play_bin_change_state):
+	  Only change state on audiosink if it exists.
+
+2004-12-28  Maciej Katafiasz  <mathrick@mathrick.org>
+
+	* gst/matroska/matroska-demux.c:
+	* gst/matroska/matroska-ids.h:
+	* gst/matroska/matroska-demux.h:
+	Fix Vorbis streams failing to decode in some files, where cluster_time
+	isn't 0, because then it doesn't send codec_priv before actual data.
+	Remove time-based test and replace it with marker set on beginning of
+	new stream
+
+2004-12-28  David Schleef  <ds@schleef.org>
+
+	Merge patch from Ronald fixing problems with streaming
+	text.
+	* ext/cairo/gstcairo.c: (plugin_init):
+	* ext/cairo/gsttextoverlay.c: (gst_textoverlay_render_text),
+	(gst_text_overlay_blit_1), (gst_text_overlay_blit_sub2x2),
+	(gst_textoverlay_video_chain), (gst_textoverlay_loop),
+	(gst_textoverlay_font_init), (gst_textoverlay_init),
+	(gst_textoverlay_set_property):
+	* ext/cairo/gsttextoverlay.h:
+
+2004-12-27  David Schleef  <ds@schleef.org>
+
+	* ext/cairo/gsttextoverlay.c: (gst_textoverlay_render_text),
+	(gst_text_overlay_blit_1), (gst_text_overlay_blit_sub2x2),
+	(gst_textoverlay_video_chain), (gst_textoverlay_loop),
+	(gst_textoverlay_font_init), (gst_textoverlay_init),
+	(gst_textoverlay_set_property): Improvements to actually
+	render text as white on black outline on video, including
+	font selection and horizontal/vertical alignment.  (Ronald's
+	christmas present)
+	* ext/cairo/gsttextoverlay.h:
+
+2004-12-26  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* ext/ogg/gstogg.c:
+	* ext/ogg/gstogmparse.c:
+	  fix ogm[audio/video]parse plugin registration
+	  (riff won't load if bytestream is already loaded)
+
+2004-12-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/audioconvert/gstchannelmix.c:
+	  fix for GLIB < 2.4
+
+2004-12-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* configure.ac:
+	  disable docs again until it actually passes make distcheck.
+
+2004-12-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_type_get), (qtdemux_audio_caps):
+	* gst/typefind/gsttypefindfunctions.c: (q3gp_type_find),
+	(plugin_init):
+	  Add 3GP (variables name Q3GP because they can't start with a
+	  number). Add samr audio fourcc (used in .3gp files), decoder
+	  is work in progress. Also do a GST_WARNING instead of ERROR
+	  in case of unknown nodes, to decrease output.
+
+2004-12-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	  really fix dist
+
+2004-12-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* ext/speex/gstspeexdec.h:
+	* ext/speex/gstspeexenc.h:
+	  Fixes #158382.  Make speex plugin compatible with both 1.0 and 1.1.
+	  Fix detection code in configure.ac
+
+2004-12-23  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_blockgroup):
+	  Save position, so that queries give proper return values. Don't
+	  know how this could ever have worked before...
+
+2004-12-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  Put additional LAME check inside the conditional.  Fixes #152339
+
+2004-12-23  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_index),
+	(gst_avi_demux_stream_scan):
+	  Add some more debug. Fix logic error when setting movi offset
+	  while reading index.
+
+2004-12-23  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_index),
+	(gst_avi_demux_stream_scan), (gst_avi_demux_handle_seek),
+	(gst_avi_demux_process_next_entry):
+	  Add some debugging. Better detection of broken indexes and the
+	  accompanying index recovery. No infinite loops on state changes
+	  when we're still in our loopfunction.
+
+2004-12-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	  Fix up.
+
+2004-12-22  Archana Shah  <archana.shah@wipro.com>
+
+	Reviewed by:  Ronald S. Bultje <rbultje@ronald.bitfreak.net>
+
+	* sys/sunaudio/gstsunmixer.c: (gst_sunaudiomixer_set_volume):
+	  Normalizing the value before setting
+	(gst_sunaudiomixer_get_volume):
+	  Normalizing the value after getting. Fixes bug# 161980
+
+2004-12-22  Christian Fredrik Kalager Schaller  <uraeus@gnome.org>
+
+	* Makefile.am: Make sure docs gets disted
+	* docs/Makefile.am: Make sure all needed files get disted
+	* gst-plugins.spec.in: latest updates
+
+2004-12-22  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_add_element):
+	Revert patch 1.38 as clock distribution over schedulers does
+	not work correcly in the core yet.
+
+2004-12-21  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* sys/oss/README: remove this file, which predates my birth
+	  (and which content is by far outdated)
+
+2004-12-20  Stefan Kost  <ensonic@users.sf.net>
+
+	* Makefile.am:
+	* configure.ac:
+	* docs/Makefile.am:
+	* docs/libs/Makefile.am:
+	* docs/libs/gst-plugins-libs-docs.sgml:
+	* docs/libs/gst-plugins-libs-sections.txt:
+	* docs/libs/tmpl/gstgconf.sgml:
+	* docs/upload.mak:
+	* docs/version.entities.in:
+	  Added boilerplate gtk-doc files for plugin-libs documentation.
+
+2004-12-19  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/auparse/gstauparse.c: fix int and float audio caps
+
+2004-12-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lelement.c: (gst_v4l_iface_supported):
+	* sys/v4l2/gstv4l2element.c: (gst_v4l2_iface_supported):
+	  g_assert() can be a macro, don't use #ifdef inside it.
+
+2004-12-19  Edward Hervey  <bilboed@bilboed.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/videorate/gstvideorate.c: (gst_videorate_blank_data),
+	(gst_videorate_init), (gst_videorate_chain),
+	(gst_videorate_change_state):
+	  Event handling (fixes #159986).
+
+2004-12-19  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data):
+	  Add BLZ0 (Blizzard's version of DivX) fourcc.
+
+2004-12-18  David Schleef  <ds@schleef.org>
+
+	* gst/tta/gstttadec.c: (gst_tta_dec_link): And yet another
+	portability fix.
+
+2004-12-18  David Schleef  <ds@schleef.org>
+
+	* gst/tta/ttadec.h: Disable some header code that isn't used
+	and clearly isn't portable.
+
+2004-12-18  David Schleef  <ds@schleef.org>
+
+	* gst/ffmpegcolorspace/imgconvert.c: (get_pix_fmt_info),
+	(avcodec_get_chroma_sub_sample), (avcodec_get_pix_fmt_name),
+	(avcodec_get_pix_fmt), (avpicture_layout),
+	(avcodec_get_pix_fmt_loss), (avg_bits_per_pixel), (img_copy),
+	(get_convert_table_entry), (img_convert), (img_get_alpha_info):
+	Fix code to not use GCC extensions (and c99 extensions that
+	Forte does not like.)
+
+2004-12-19  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/deinterlace/gstdeinterlace.c: (gst_deinterlace_link),
+	(gst_deinterlace_chain):
+	  Rowstride fixes. Fixes #161039.
+	* gst/videocrop/gstvideocrop.c: (gst_video_crop_init),
+	(gst_video_crop_get_property), (gst_video_crop_add_to_struct_val),
+	(gst_video_crop_getcaps), (gst_video_crop_link),
+	(gst_video_crop_i420), (gst_video_crop_chain),
+	(gst_video_crop_change_state):
+	  Rework of negotiation. Actually works now. Fixes #158650.
+
+2004-12-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_ebmlnum_sint):
+	  That was very stupid.
+
+2004-12-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_blockgroup):
+	  Fix possible crasher.
+
+2004-12-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_ebmlnum_uint),
+	(gst_matroska_ebmlnum_sint), (gst_matroska_demux_parse_blockgroup):
+	  Lace sizes can be zero.
+
+2004-12-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/musepack/gstmusepackdec.cpp:
+	  Fetch error return values. Fixes #161624.
+	* gst/apetag/apedemux.c: (gst_ape_demux_stream_data):
+	  Really EOS.
+
+2004-12-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_index):
+	  Work for truncated (unfinished download etc.) files. Fixes #160514.
+
+2004-12-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  Fix for integer overflow. Makes #156001 not crash. Probably masks
+	  the real bug.
+
+2004-12-17  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ac3parse/gstac3parse.c: (plugin_init):
+	  Parsers never have ranks. Fixes #159651.
+
+2004-12-17  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/playback/gstdecodebin.c: (compare_ranks):
+	  make sure the facotries are ordered the same every time even if they
+	  have the same rank by using the name
+	* gst/playback/gstdecodebin.c: (find_compatibles):
+	  make sure we don't add factories to the list twice
+
+2004-12-16  David Schleef  <ds@schleef.org>
+
+	* configure.ac: look for musepack headers as musepack/*.h
+	(fixes #159847)
+	* ext/musepack/gstmusepackdec.h: use <musepack/*.h>
+	* ext/musepack/gstmusepackreader.h: same
+
+2004-12-17  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c:
+	(gst_riff_read_strf_auds_with_data):
+	  Read extradata correctly (fixes #155879).
+
+2004-12-16  David Schleef  <ds@schleef.org>
+
+	* gst/audioscale/gstaudioscale.c: allow passthru of >2 channel
+	audio.  does _not_ attempt or allow conversion unless channels
+	is 1 or 2.
+
+2004-12-16  Christian Fredrik Kalager Schaller  <uraeus@gnome.org>
+
+	* tools/gst-launch-ext-m.m: fix mpeg and vob pipelines
+
+2004-12-16  David Schleef  <ds@schleef.org>
+
+	* gst/audioscale/gstaudioscale.c: the resample library only
+	handles 1 or 2 channels.  Change caps to compensate.
+
+2004-12-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (aac_rate_idx), (aac_profile_idx),
+	(gst_matroska_demux_audio_caps):
+	  Some MPEG-AAC hacks, because else it doesn't work...
+
+2004-12-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_video_template_caps):
+	  Add h264.
+
+2004-12-16  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/audio/Makefile.am:
+	  Try to fix buildbot.
+
+2004-12-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gstmultifdsink.c:
+	  Clean up and uniformize debugging.
+
+2004-12-16  Edward Hervey  <bilboed@bilboed.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_class_init),
+	(gst_dvd_demux_reset), (gst_dvd_demux_change_state):
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_reset),
+	(gst_mpeg_demux_change_state):
+	  Reset on ready. Fixes 160276.
+
+2004-12-16  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcsp_pad_link):
+	  Fix memleak (#154815).
+
+2004-12-16  James Bowes  <bowes@cs.dal.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/musicbrainz/gsttrm.c: (gst_musicbrainz_class_init),
+	(gst_musicbrainz_init), (gst_musicbrainz_chain),
+	(gst_musicbrainz_set_property), (gst_musicbrainz_get_property):
+	* ext/musicbrainz/gsttrm.h:
+	  Add support for using a proxy server when getting a trm id from
+	  the MusicBrainz database (#149613).
+
+2004-12-16  Christophe Fergeau  <teuf@gnome.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstdecodebin.c: (new_pad), (close_link):
+	* gst/playback/gstplaybasebin.c: (new_decoded_pad):
+	  Fix memleaks (#157233).
+
+2004-12-16  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/resample/resample.c: (gst_resample_close):
+	* gst-libs/gst/resample/resample.h:
+	* gst/audioscale/gstaudioscale.c:
+	  Fix memleak (#159215).
+
+2004-12-16  Toni Willberg  <toniw@iki.fi>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosselement.c: (gst_osselement_probe_caps):
+	* sys/oss/oss_probe.c: (main):
+	  Check for mono/stereo support (similar to samplerate probing),
+	  fixes #159433. Also add missing copyright header to oss_probe.c.
+
+2004-12-15  David Schleef  <ds@schleef.org>
+
+	* configure.ac: add audioresample and cairo plugins.  Remove
+	HAVE_MMX stuff, because it's not used.
+	* ext/Makefile.am: same
+	* ext/audioresample/Makefile.am: You are not ready for an
+	audio resampling element based on audioresample.
+	* ext/audioresample/gstaudioresample.c:
+	* ext/audioresample/gstaudioresample.h:
+	* ext/cairo/Makefile.am: You are not ready for overlay elements
+	based on cairo.  Don't look too closely, these elements kinda
+	suck right now.
+	* ext/cairo/gstcairo.c: new
+	* ext/cairo/gsttextoverlay.c: new
+	* ext/cairo/gsttextoverlay.h: new
+	* ext/cairo/gsttimeoverlay.c: new
+	* ext/cairo/gsttimeoverlay.h: new
+	* gst-libs/gst/media-info/media-info-priv.h: fix compile
+	problem with compilers that don't support variadic macros.
+
+2004-12-15  Balamurali Viswanathan  <balamurali.viswanathan@wipro.com>
+
+	Reviewed by:  David Schleef  <ds@schleef.org>
+
+	* sys/sunaudio/gstsunaudio.c: (plugin_init):  Apply patch from
+	Bala, registering sunaudiosrc (oops!), and cleaning up code a
+	bit.  Also ran indent-gst.
+	* sys/sunaudio/gstsunaudiosrc.c: (gst_sunaudiosrc_init),
+	(gst_sunaudiosrc_change_state), (gst_sunaudiosrc_get),
+	(gst_sunaudiosrc_setparams):
+
+2004-12-14  David Schleef  <ds@schleef.org>
+
+	* gst/festival/gstfestival.c: (gst_festival_chain): Set the
+	output rate to 16000.  Should fix #160235.
+
+2004-12-14  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/typefind/gsttypefindfunctions.c: (mpeg2_sys_type_find):
+	Add typefinding for mpeg2 pes streams
+
+2004-12-13  David Schleef  <ds@schleef.org>
+
+	* configure.ac:  Applied patch from bug #143659, making default
+	sources and sinks OS-dependent (for Solaris), and added code
+	for OS/X.
+	* gconf/gstreamer.schemas.in: use OS-dependent sinks in gconf.
+
+2004-12-13  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst-libs/gst/riff/riff-media.c:
+	  forgot to add h2.64 to avidemux template caps
+
+2004-12-13  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/wavenc/riff.h:
+	* gst-libs/gst/riff/riff-media.c:
+	* gst-libs/gst/riff/riff-ids.h:
+	* gst/avi/gstavimux.c
+	add 4CC code for VideoSoft h264 in AVI (VSSH)
+	  fixes bug #160655
+	remove s323 from riff, it's quicktime specific :(
+
+2004-12-13  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/asfdemux/README
+	* gst/wavenc/riff.h
+	* gst-libs/gst/riff/riff-ids.h
+	* gst-libs/gst/riff/riff-media.c
+	* gst/qtdemux/qtdemux.c:
+	  add new 4CC codes for h263 related codecs
+	  fixes partially bug #155163
+
+2004-12-12  Christian Fredrik Kalager Schaller  <christian at fluendo dot com>
+
+	* configure.ac: Update polyaudio requirement to 0.7
+	* ext/polyp/polypsink.c: (create_stream): add patch from iain (158258)
+
+2004-12-11  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/interleave/deinterleave.c:
+	fix my name's spelling! :)
+
+2004-12-11  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* AUTHORS ChangeLog
+	* gst/auparse/gstauparse.c
+	* gst/interleave/deinterleave.c
+	* gst/law/:
+		alaw-decode.c alaw-encode.c
+		mulaw-decode.c mulaw-encode.c
+	* gst/oneton/gstoneton.c
+	* sys/osxaudio/:
+		gstosxaudioelement.c gstosxaudiosink.c gstosxaudiosrc.c
+	* sys/osxvideo/:
+		cocoawindow.h cocoawindow.m
+		osxvideosink.h osxvideosink.m
+
+	put the same mail address for Zaheer Abbas Merali everywhere
+
+2004-12-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_loop):
+	  Align by packetsize, and assert that we a packet available before
+	  playing. The first makes webstreams work (they often include
+	  trailing padding data in a packet), the second allows pausing a
+	  ASF stream in totem without getting demux errors afterwards.
+
+2004-12-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (get_relative):
+	  Check for non-NULL before accessing member (end-of-chain).
+
+2004-12-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_class_init),
+	(cdparanoia_set_property), (cdparanoia_get_property):
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_class_init),
+	(dvdnavsrc_set_property), (dvdnavsrc_get_property):
+	* ext/dvdread/dvdreadsrc.c: (dvdreadsrc_class_init),
+	(dvdreadsrc_init), (dvdreadsrc_set_property),
+	(dvdreadsrc_get_property):
+	* sys/vcd/vcdsrc.c: (gst_vcdsrc_class_init),
+	(gst_vcdsrc_set_property), (gst_vcdsrc_get_property):
+	  Synchronize property names where not yet the case. Devices are
+	  now device=X, other versions are deprecated (but still exist).
+	  Also use g_free() unconditionally.
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init),
+	(setup_source), (gst_play_base_bin_get_property):
+	  Expose source.
+
+2004-12-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: move GCONF macro outside conditional for the am
+	  conditional. Fixes #160439
+
+2004-12-08  David Schleef  <ds@schleef.org>
+
+	* tools/gst-visualise-m.m: Switch to elements that currently
+	exist.
+
+2004-12-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstogmparse.c: (gst_ogm_parse_chain):
+	  We love wrong commas.
+
+2004-12-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_handle_src_query):
+	  Don't set DEFAULT, unsupported - makes length display incorrectly
+	  in some cases.
+
+2004-12-07  Christian Fredrik Kalager Schaller  <uraeus@gnome.org>
+
+	* gst/monoscope/README: remove blurb about files being GPL
+	* gst/monoscope/gstmonoscope.c: Change license field to LGPL
+	* gst/monoscope/monoscope.c: Change license to BSD with explanation
+	  monoscope is now effectively LGPL licensed
+
+2004-12-07  Christian Fredrik Kalager Schaller  <uraeus@gnome.org>
+
+	* gst/monoscope/README: Update information to be more correct
+	* gst/monoscope/convolve.c: Relicense to LGPL
+	* gst/monoscope/convolve.h: Relicense to LGPL
+
+2004-12-06  Arwed v. Merkatz <v.merkatz@gmx.net>
+
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (gst_mp3parse_chain):
+	  set BUFFER_DURATION to correct values (mpeg1 audio frame length is fixed)
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_audio_pad_link):
+	  set default_duration for mpeg1 audio
+
+2004-12-06  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_caps), (gst_alsa_close_audio):
+	* ext/alsa/gstalsa.h:
+	  refactor big chunks of the core caps negotiation code to make it
+	  a lot faster, because people claim it's really slow
+	  (actually, just cache the getcaps when the device is opened)
+
+2004-12-06  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_init),
+	(gst_a52dec_handle_event), (gst_a52dec_update_streaminfo),
+	(gst_a52dec_handle_frame), (gst_a52dec_chain),
+	(gst_a52dec_change_state), (plugin_init):
+	* ext/a52dec/gsta52dec.h:
+	  Do something useful with timestamps. Make chain-based (since
+	  there's really no reason to be loopbased).
+	* gst/avi/gstavidemux.c: (gst_avi_demux_process_next_entry):
+	  Update current_byte/frame correctly.
+
+2004-12-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/apetag/apedemux.c: (gst_ape_demux_parse_tags),
+	(gst_ape_demux_stream_init):
+	  Forward tags, too.
+
+2004-12-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/apetag/apedemux.c: (gst_ape_demux_stream_init):
+	  Let's make sure we're done typefinding when detecting tags.
+
+2004-12-03  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/ebml-read.c: (gst_ebml_read_class_init),
+	(gst_ebml_read_init), (gst_ebml_read_use_event),
+	(gst_ebml_read_element_id), (gst_ebml_peek_id),
+	(gst_ebml_read_seek), (gst_ebml_read_skip),
+	(gst_ebml_read_reserve), (gst_ebml_read_buffer),
+	(gst_ebml_read_master):
+	* gst/matroska/ebml-read.h:
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_contents),
+	(gst_matroska_demux_loop_stream), (gst_matroska_demux_audio_caps):
+	  Disgustingly evil hack for working around INTERRUPT events and
+	  their extremely annoying habit of being a pain in the ass. We
+	  simply peek a cluster before reading any of it.
+
+2004-12-03  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/musepack/gstmusepackdec.cpp:
+	  There's also floating point libmusepacks.
+
+2004-12-03  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faad/gstfaad.c: (gst_faad_chanpos_from_gst),
+	(gst_faad_chanpos_to_gst), (gst_faad_chain):
+	  Set DURATION even if source buffer didn't. Also use increasing
+	  timestamps.
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_audio_caps_with_data):
+	  Block_align can have larger values than 8192.
+
+2004-12-02  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/law/alaw-decode.c: (alawdec_getcaps), (alawdec_link):
+	* gst/law/alaw-encode.c: (alawenc_getcaps), (alawenc_link):
+	* gst/law/mulaw-decode.c: (mulawdec_getcaps), (mulawdec_link):
+	* gst/law/mulaw-encode.c: (mulawenc_getcaps), (mulawenc_link):
+	  Fix caps.
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/v4l_calls.c: (gst_v4l_get_chan_names):
+	  Fix logic bug.
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_type_find):
+	  Yay, another one.
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/esd/esdsink.c: (gst_esdsink_chain):
+	  Make error actually say something useful (fixes #156798).
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_video_template_caps):
+	  Add Intel Video 5.0 fourcc (IV50).
+
+2004-12-01  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/mad/gstmad.c: (mpg123_parse_xing_header): fix xing header
+	detection on mono and stereo mp3 files.
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_change_state):
+	  Don't crash on EMPTY caps (e.g. when the demuxer didn't recognize
+	  the contained stream).
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faad/gstfaad.c: (gst_faad_srcconnect), (gst_faad_chain):
+	  Oops, remove debug.
+
+2004-12-01  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/law/alaw-decode.c: (alawdec_getcaps):
+	* gst/law/mulaw-decode.c: (mulawdec_getcaps):
+	  Prevent warnings when negotiating caps (fixes #159338).
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcsp_chain):
+	  Remove old leftover that shouldn't be there...
+
+2004-12-01  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_use_event):
+	  Don't forward DISCONT events (fixes #159684).
+
+2004-12-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybin.c: (remove_sinks), (setup_sinks):
+	  Unlink manually since sometimes bin disposal (and therefore
+	  pad unlinking) is delayed, which will cause a new media file
+	  to not be able to start playing instantly.
+
+2004-11-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gststreaminfo.c: (stream_info_mute_pad):
+	  On mute of an unlinked stream, check for pad availability so
+	  we don't crash on unlinked pad.
+
+2004-11-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_index),
+	(gst_avi_demux_massage_index):
+	  Fix quite humiliating bug in omitting 0-sized index chunks but
+	  forgetting to count them for timestamps.
+
+2004-11-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_loop):
+	  Actually leave the loop if we failed to sync. Don't crash.
+
+2004-11-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_get_audio_stream),
+	(gst_dvd_demux_process_private):
+	* gst/mpegstream/gstdvddemux.h:
+	  Fix crash (#159759). Doesn't work, though. :-(.
+
+2004-11-28  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstchannelmix.c: (gst_audio_convert_mix):
+	  more overwriting protection due to modifying channels one by one
+	  instead of all at once
+
+2004-11-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/audioconvert/gstchannelmix.c:
+	(gst_audio_convert_fill_normalize):
+	  Normalize using absolute values.
+
+2004-11-28  Julien MOUTTE  <julien@moutte.net>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/directfb/Makefile.am:
+	* ext/directfb/directfbvideosink.c: (gst_directfbvideosink_create),
+	(gst_directfbvideosink_get_pixel_format),
+	(gst_directfbvideosink_get_format_from_fourcc),
+	(gst_directfbvideosink_fixate), (gst_directfbvideosink_getcaps),
+	(gst_directfbvideosink_sink_link),
+	(gst_directfbvideosink_change_state),
+	(gst_directfbvideosink_chain), (gst_directfbvideosink_buffer_free),
+	(gst_directfbvideosink_buffer_alloc),
+	(gst_directfbvideosink_interface_supported),
+	(gst_directfbvideosink_interface_init),
+	(gst_directfbvideosink_navigation_send_event),
+	(gst_directfbvideosink_navigation_init),
+	(gst_directfbvideosink_set_property),
+	(gst_directfbvideosink_get_property),
+	(gst_directfbvideosink_finalize), (gst_directfbvideosink_init),
+	(gst_directfbvideosink_base_init),
+	(gst_directfbvideosink_class_init),
+	(gst_directfbvideosink_get_type), (plugin_init):
+	* ext/directfb/directfbvideosink.h: Adding a first version of
+	directfbvideosink.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_init): Initializing some
+	more.
+
+2004-11-28  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstchannelmix.c: (gst_audio_convert_mix):
+	  walk the samples backwards if out_channels > in_channels so we don't
+	  overwrite data
+
+2004-11-28  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/audioconvert/Makefile.am:
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_init),
+	(gst_audio_convert_link), (gst_audio_convert_change_state),
+	(gst_audio_convert_channels):
+	* gst/audioconvert/gstchannelmix.c:
+	(gst_audio_convert_unset_matrix),
+	(gst_audio_convert_fill_identical),
+	(gst_audio_convert_fill_compatible),
+	(gst_audio_convert_detect_pos), (gst_audio_convert_fill_one_other),
+	(gst_audio_convert_fill_others),
+	(gst_audio_convert_fill_normalize),
+	(gst_audio_convert_fill_matrix), (gst_audio_convert_setup_matrix),
+	(gst_audio_convert_passthrough), (gst_audio_convert_mix):
+	* gst/audioconvert/gstchannelmix.h:
+	  Implement a channel mixer.
+
+2004-11-28  Martin Soto  <martinsoto@users.sourceforge.net>
+
+	* ext/alsa/gstalsasink.c (gst_alsa_sink_loop):
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsa.c (gst_alsa_set_clock):
+	Make alsasink actually honor gst_element_set_clock and use that
+	clock instead of its internal one.
+
+2004-11-27  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/playback/gstplaybasebin.c: (setup_source): fixed a caps leak
+	(gst_play_base_bin_change_state): nullify source and decoder when
+	going from READY to NULL so that we don't try to do weird stuff with
+	them when going from NULL to READY
+	* gst/playback/gstplaybin.c: (gst_play_bin_init): use gst_object_unref
+	instead of g_object_unref
+	(gen_video_element), (gen_audio_element): more refcounting fixes, now
+	it should be correct
+	(gst_play_bin_change_state): don't call remove_sinks if we are
+	currently disposing the object
+
+2004-11-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_loop):
+	  Don't forget bass if it's there. Else left channel is silent...
+
+2004-11-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_loop),
+	(gst_a52dec_change_state):
+	  Don't do sample adjusting anymore, we use float audio now.
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_fixate):
+	  Don't fixate to non-existing properties.
+
+2004-11-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_channels),
+	(gst_a52dec_change_state):
+	  Advertise that we can do surround sound.
+
+2004-11-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_reneg):
+	  Add buffer-frames=0.
+	* ext/dvdread/dvdreadsrc.c: (dvdreadsrc_get_type),
+	(dvdreadsrc_init), (dvdreadsrc_get_event_mask),
+	(dvdreadsrc_get_query_types), (dvdreadsrc_get_formats),
+	(dvdreadsrc_srcpad_event), (dvdreadsrc_srcpad_query),
+	(_seek_title), (_seek_chapter), (get_next_cell_for), (_read),
+	(seek_sector), (dvdreadsrc_get), (dvdreadsrc_open_file),
+	(dvdreadsrc_change_state), (dvdreadsrc_uri_get_type),
+	(dvdreadsrc_uri_get_protocols), (dvdreadsrc_uri_get_uri),
+	(dvdreadsrc_uri_set_uri), (dvdreadsrc_uri_handler_init):
+	* ext/dvdread/dvdreadsrc.h:
+	  Add seeking, querying for bytes, sectors, title, angle and
+	  chapter. Handle multiple chapters. Relicense to LGPL because
+	  Billy agreed on that (thanks Billy!).
+
+2004-11-27  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_dispose):
+	call parent dispose method
+
+2004-11-27  Martin Soto  <martinsoto@users.sourceforge.net>
+
+	* gst-libs/gst/audio/audioclock.c (gst_audio_clock_set_active)
+	(gst_audio_clock_get_internal_time):
+	Fix active <-> inactive transitions: ensure time value always
+	grows and avoid abrupt value changes.
+
+2004-11-27  Arwed v. Merkatz <v.merkatz@gmx.net>
+
+	* configure.ac:
+	* gst/tta/Makefile.am:
+	* gst/tta/crc32.h:
+	* gst/tta/filters.h:
+	* gst/tta/gsttta.c:
+	* gst/tta/gstttadec.c:
+	* gst/tta/gstttadec.h:
+	* gst/tta/gstttaparse.c:
+	* gst/tta/gstttaparse.h:
+	* gst/tta/ttadec.h:
+	  added TTA parser and decoder
+
+2004-11-26  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init),
+	(probe_triggered), (check_queue), (buffer_underrun),
+	(buffer_running), (buffer_overrun), (gen_source_element),
+	(setup_source):
+	* gst/playback/gstplaybasebin.h:
+	  Implement buffering. Needs some more work.
+
+2004-11-26  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	  Fix ilog mask range overflow.
+
+2004-11-26  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_caps):
+	  Don't omit the last (which in case of dmix is the only :) )
+	  channel count. Don't set channels if <= 2.
+
+2004-11-26  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_audio_element): Removed 2 obsolete comments
+
+2004-11-26  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/vorbis/oggvorbisenc.c
+	* ext/vorbis/vorbisenc.c :
+	  change description fields of those plugins to differentiate them
+	  (pitivi show Encoders by description, they had the same one)
+
+2004-11-25  Christophe Fergeau  <teuf@gnome.org>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybin.c: (gst_play_bin_dispose),
+	(gst_play_bin_set_property), (gen_video_element),
+	(gen_audio_element):
+	  Refcounting fixes for provided audio-/videosinks.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_audio_element), (setup_sinks), (gst_play_bin_change_state):
+	  Don't reference all sinks, but only the video- and audiosinks.
+	  The vis. element should be disposed when we're done with it.
+	  We don't have any reason to keep it around. This fixes warnings
+	  when reusing playbin for playing multiple audio files with
+	  vis. enabled. Also release audio device on pause - idea stolen
+	  from Rhythmbox.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_channels), (gst_a52dec_push),
+	(gst_a52dec_reneg), (gst_a52dec_loop), (plugin_init):
+	* ext/alsa/gstalsa.c: (gst_alsa_get_caps):
+	* ext/alsa/gstalsaplugin.c: (plugin_init):
+	* ext/dts/gstdtsdec.c: (gst_dtsdec_channels),
+	(gst_dtsdec_renegotiate), (gst_dtsdec_loop), (plugin_init):
+	* ext/faad/gstfaad.c: (gst_faad_init), (gst_faad_chanpos_from_gst),
+	(gst_faad_chanpos_to_gst), (gst_faad_sinkconnect),
+	(gst_faad_srcgetcaps), (gst_faad_srcconnect), (gst_faad_chain),
+	(gst_faad_change_state), (plugin_init):
+	* ext/faad/gstfaad.h:
+	* ext/vorbis/vorbis.c: (plugin_init):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+	* gst-libs/gst/audio/Makefile.am:
+	* gst-libs/gst/audio/audio.c: (plugin_init):
+	* gst-libs/gst/audio/multichannel.c:
+	(gst_audio_check_channel_positions),
+	(gst_audio_get_channel_positions),
+	(gst_audio_set_channel_positions),
+	(gst_audio_set_structure_channel_positions_list),
+	(add_list_to_struct), (gst_audio_set_caps_channel_positions_list),
+	(gst_audio_fixate_channel_positions):
+	* gst-libs/gst/audio/multichannel.h:
+	* gst-libs/gst/audio/testchannels.c: (main):
+	* gst/audioconvert/gstaudioconvert.c:
+	(gst_audio_convert_class_init), (gst_audio_convert_init),
+	(gst_audio_convert_dispose), (gst_audio_convert_getcaps),
+	(gst_audio_convert_parse_caps), (gst_audio_convert_link),
+	(gst_audio_convert_fixate), (gst_audio_convert_channels):
+	* gst/audioconvert/plugin.c: (plugin_init):
+	  Surround sound support.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_push):
+	  Fix position for discont if we're close as well. Nitpicking, but
+	  saves a few milliseconds of extra waiting or skipping.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_factory_filter):
+	  We sometimes need parsers for playback, so add those too.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* gst/apetag/Makefile.am:
+	* gst/apetag/apedemux.c: (gst_ape_demux_get_type),
+	(gst_ape_demux_base_init), (gst_ape_demux_class_init),
+	(gst_ape_demux_init), (gst_ape_demux_get_src_formats),
+	(gst_ape_demux_get_src_query_types),
+	(gst_ape_demux_handle_src_query), (gst_ape_demux_get_event_mask),
+	(gst_ape_demux_handle_src_event), (gst_ape_demux_handle_event),
+	(gst_ape_demux_typefind_peek), (gst_ape_demux_typefind_get_length),
+	(gst_ape_demux_typefind_suggest), (gst_ape_demux_typefind),
+	(gst_ape_demux_parse_tags), (gst_ape_demux_stream_init),
+	(gst_ape_demux_stream_data), (gst_ape_demux_loop),
+	(gst_ape_demux_change_state):
+	* gst/apetag/apedemux.h:
+	* gst/apetag/apetag.c: (plugin_init):
+	* gst/typefind/gsttypefindfunctions.c: (apetag_type_find),
+	(plugin_init):
+	  APE v1/2 tag reader plus typefind function.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_add_element):
+	* gst/typefind/gsttypefindfunctions.c: (mp3_type_find):
+	  Remove hacks for older core. Require newer core version
+	  accordingly.
+
+2004-11-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/cdxaparse/Makefile.am:
+	* gst/cdxaparse/gstcdxaparse.c: (gst_cdxaparse_get_type),
+	(gst_cdxaparse_class_init), (gst_cdxaparse_init),
+	(gst_cdxaparse_loop), (gst_cdxaparse_change_state), (plugin_init):
+	* gst/cdxaparse/gstcdxaparse.h:
+	* gst/cdxaparse/gstcdxastrip.c: (gst_cdxastrip_get_type),
+	(gst_cdxastrip_base_init), (gst_cdxastrip_class_init),
+	(gst_cdxastrip_init), (gst_cdxastrip_get_src_formats),
+	(gst_cdxastrip_get_src_query_types),
+	(gst_cdxastrip_handle_src_query), (gst_cdxastrip_get_event_mask),
+	(gst_cdxastrip_handle_src_event), (gst_cdxastrip_strip),
+	(gst_cdxastrip_sync), (gst_cdxastrip_handle_event),
+	(gst_cdxastrip_chain), (gst_cdxastrip_change_state):
+	* gst/cdxaparse/gstcdxastrip.h:
+	  SVCD/VCD header stripping separated from CDXA image parsing.
+	* gst/typefind/gsttypefindfunctions.c: (mp3_type_find),
+	(plugin_init):
+	  Add VCD/SVCD header typefinding for VCD/SVCD.
+	* sys/vcd/vcdsrc.c: (gst_vcdsrc_get_type), (gst_vcdsrc_base_init),
+	(gst_vcdsrc_class_init), (gst_vcdsrc_init),
+	(gst_vcdsrc_set_property), (gst_vcdsrc_get_property),
+	(gst_vcdsrc_get_event_mask), (gst_vcdsrc_get_query_types),
+	(gst_vcdsrc_get_formats), (gst_vcdsrc_srcpad_event),
+	(gst_vcdsrc_srcpad_query), (gst_vcdsrc_get),
+	(gst_vcdsrc_open_file), (gst_vcdsrc_close_file),
+	(gst_vcdsrc_change_state), (gst_vcdsrc_msf),
+	(gst_vcdsrc_recalculate), (gst_vcdsrc_uri_get_type),
+	(gst_vcdsrc_uri_get_protocols), (gst_vcdsrc_uri_get_uri),
+	(gst_vcdsrc_uri_set_uri), (gst_vcdsrc_uri_handler_init):
+	* sys/vcd/vcdsrc.h:
+	  Fix up, add seeking, querying, URI interface. Works in totem now.
+
+2004-11-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  back to CVS
+
+=== release 0.8.6 ===
+
+2004-11-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* NEWS:
+	* RELEASE:
+	* configure.ac:
+	* po/af.po:
+	* po/az.po:
+	* po/cs.po:
+	* po/en_GB.po:
+	* po/hu.po:
+	* po/it.po:
+	* po/nb.po:
+	* po/nl.po:
+	* po/or.po:
+	* po/sq.po:
+	* po/sr.po:
+	* po/sv.po:
+	* po/uk.po:
+	  releasing 0.8.6, "IOU Love"
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Ronald Bultje <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c:
+	  Fix unplayable files error handling.  Fixes #158365
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Ronald Bultje <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c:
+	  Fix broken mp3 typefinding.  Fixes #158375
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Ronald Bultje <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c:
+	  Fix sync on broken files.  Fixes #158976
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Edward Hervey <bilboed@bilboed.com>
+
+	* ext/libpng/gstpngenc.c:
+	  Copy over buffer properties.  Fixes #158832
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Tim-Philipp Müller <t.i.m@zen.co.uk>
+
+	* ext/dvdread/dvdreadsrc.c:
+	  Fixes invalid reads (#158462)
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lsrc.c:
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/v4lsrc_calls.c:
+	  Probe less and cache it.  Fixes #159187.
+
+2004-11-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videorate/gstvideorate.c:
+	  Handle all video formats. Fixes #159186.
+
+2004-11-16  Jan Schmidt  <thaytan@mad.scientist.com>
+	* gst/synaesthesia/gstsynaesthesia.c:
+	(gst_synaesthesia_class_init), (gst_synaesthesia_init),
+	(gst_synaesthesia_dispose), (gst_synaesthesia_finalize),
+	(gst_synaesthesia_sink_link), (gst_synaesthesia_src_getcaps),
+	(gst_synaesthesia_src_link), (gst_synaesthesia_chain),
+	(gst_synaesthesia_change_state), (plugin_init):
+	Fix up synaesthesia to work under different samplerates/ buffer sizes.
+	Force 320x200 output, as that's the only thing the underlying
+	synaesthesia implementation supports. Still needs to be made
+	re-entrant.
+
+2004-11-14  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	  Fix mpeg2enc configure check (similar to mplex check below).
+
+2004-11-14  Koop Mast  <kwm@rainbow-runner.nl>
+
+	reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	  Fix for gcc-2.95 (fixes #158221).
+
+2004-11-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_add_element):
+	  Re-add clock distribution hack (until new core is released).
+	  Fixes #158125.
+
+2004-11-13  Arwed v. Merkatz  <v.merkatz@gmx.net>
+	* configure.ac:
+	  fix mplex configure check segfaulting on some systems (bug #140994)
+
+2004-11-13  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_pcm_wait):
+	  add debugging
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  do a wait when we enter the loop func with no data available to
+	  write instead of getting into an 100% CPU loop by just returning and
+	  being called again by the scheduler
+
+2004-11-13  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* configure.ac:
+	* ext/libvisual/visual.c: (gst_visual_get_type),
+	(libvisual_log_handler), (gst_visual_getcaps),
+	(gst_visual_srclink), (gst_visual_change_state), (make_valid_name),
+	(plugin_init):
+	  Update libvisual to 0.1.7. Link in the debug handling to gstreamer
+	* ext/smoothwave/Makefile.am:
+	* ext/smoothwave/demo-osssrc.c: (main):
+	* ext/smoothwave/gstsmoothwave.c: (gst_smoothwave_class_init),
+	(gst_smoothwave_init), (gst_smoothwave_dispose), (gst_sw_sinklink),
+	(gst_sw_srclink), (gst_smoothwave_chain), (gst_sw_change_state),
+	(plugin_init):
+	* ext/smoothwave/gstsmoothwave.h:
+	  Make gstsmoothwave a working element in the 20th century.
+
+	* gst/chart/gstchart.c: (gst_chart_init), (gst_chart_srcconnect):
+	  Fix incorrect link function
+
+2004-11-12  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/volume/gstvolume.c:
+	  Allow buffer-frames=0.
+
+2004-11-12 Iain <iaingnome@gmail.com>
+
+	* configure.ac: Check for polypaudio
+
+	* ext/Makefile.am: Build the polyp dir
+
+	* ext/polyp: The polypsink sources.
+
+2004-10-30 Iain <iaingnome@gmail.com>
+
+	* gst/interleave/interleave.c (interleave_unlink): Change the src pads
+	caps to reflect the new number of channels.
+
+2004-11-12  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  Fix for negotiation order problem. This would show when the
+	  ALSA loopfuction was called before any other function. ALSA
+	  wouldn't do anything because we're not negotiated yet, leading
+	  to an infinite loop. Showed in e.g. Rhythmbox. Fixes #158006.
+
+2004-11-11  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_src_query):
+	  No warnings (#157986).
+
+2004-11-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c: (plugin_init):
+	  Prefer apev1/2 and id3v1 (at end of file) over musepack.
+
+2004-11-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_loop_stream):
+	  Signal no-more-pads (so it works in playbin).
+
+2004-11-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/musepack/gstmusepackreader.cpp:
+	  Workaround for older core.
+
+2004-11-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/imgconvert.c: (yuv420p_to_yuv422):
+	  Actually test for odd width/height rather than testing whether
+	  a temporary variable that was 0 before we subtracted 1 is now
+	  not equal to zero (which it always is).
+
+2004-11-11  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* sys/v4l2/gstv4l2element.c: (gst_v4l2_iface_supported):
+	Fix compilation if HAVE_XVIDEO is not defined
+
+2004-11-11  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* sys/v4l/gstv4lelement.c: (gst_v4l_iface_supported):
+	Fix compilation if HAVE_XVIDEO is not defined
+
+2004-11-11  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* gst/goom/gstgoom.c: (gst_goom_class_init), (gst_goom_init),
+	(gst_goom_dispose), (gst_goom_sinkconnect), (gst_goom_chain),
+	(gst_goom_change_state), (plugin_init):
+	Use the bytestream adapter so goom doesn't depend on the input
+	buffer size.
+	Add a debug category
+
+2004-11-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state):
+	  Only set hardware parameters *after* negotiation. Before
+	  negotiation, it will set ANY and that seems to cause crashes
+	  (see e.g. #151288, #153227).
+
+2004-11-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_get_time):
+	  This seems to be antique leftover. It needs to pass error
+	  checking.
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_init),
+	(gst_sdlvideosink_deinitsdl), (gst_sdlvideosink_initsdl),
+	(gst_sdlvideosink_destroy), (gst_sdlvideosink_create),
+	(gst_sdlvideosink_sinkconnect), (gst_sdlvideosink_chain):
+	  Fix GstXOverlay implementation (#151059).
+
+2004-11-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_change_state):
+	  Don't assert (#157853).
+
+2004-11-10  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event),
+	  Fix bytes/samples confustion.
+	(gst_alsa_sink_mmap), (gst_alsa_sink_loop):
+	  Fix for underrun (#144389).
+
+2004-11-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c: (mp3_type_find):
+	  Disable halfway-seek for pending release (since it needs a new
+	  core release).
+
+2004-11-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lsrc.c:
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/v4lsrc_calls.c:
+	  add autoprobe-fps property so we can separate autoprobing parts
+
+2004-11-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lsrc.c:
+	* sys/v4l/v4lsrc_calls.c:
+	initialise fourcc to catch unset fourcc's, and debug
+
+2004-11-09  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/README:
+	* gst/playback/gstdecodebin.c: (close_pad_link), (try_to_link_1):
+	* gst/playback/gstplaybin.c: (gst_play_bin_init),
+	(gst_play_bin_dispose), (gst_play_bin_set_property),
+	(remove_sinks), (setup_sinks), (gst_play_bin_change_state),
+	(gst_play_bin_get_event_masks), (gst_play_bin_send_event),
+	(gst_play_bin_get_formats), (gst_play_bin_convert),
+	(gst_play_bin_get_query_types), (gst_play_bin_query):
+	Cleanups and some more documentation.
+
+2004-11-09  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/libcaca/gstcacasink.c: (gst_cacasink_class_init),
+	(gst_cacasink_init), (gst_cacasink_chain):
+	* ext/libcaca/gstcacasink.h:
+	Cacasink inherits from VideoSink, so let that store the clock.
+
+2004-11-09  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/README:
+	* gst/playback/gstplaybasebin.c: (group_destroy), (group_is_muted),
+	(add_stream), (unknown_type), (add_element_stream), (no_more_pads),
+	(probe_triggered), (preroll_unlinked), (new_decoded_pad),
+	(gst_play_base_bin_change_state), (gst_play_base_bin_found_tag):
+	* gst/playback/gstplaybin.c: (gen_vis_element), (remove_sinks),
+	(setup_sinks):
+	* gst/playback/gststreaminfo.c: (gst_stream_info_set_mute),
+	(gst_stream_info_is_mute), (gst_stream_info_set_property):
+	* gst/playback/gststreaminfo.h:
+	Updated README.
+	Only switch groups if all streams have muted (EOSed).
+	Send Tags in sync with the stream playback instead of in
+	the playback/preroll phase.
+	Some cleanups, free the fakesrc elements.
+
+2004-11-09  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_caps_internal):
+	  buffer-frames property was missing
+	* ext/arts/gst_arts.c:
+	  rate missing from sinkcaps
+	* ext/audiofile/gstafparse.c:
+	* ext/audiofile/gstafsink.c:
+	* ext/audiofile/gstafsrc.c:
+	* ext/swfdec/gstswfdec.c:
+	  int audio doesn't know buffer-frames
+	* ext/cdparanoia/gstcdparanoia.c:
+	  int audio doesn't know chunksize either
+	* ext/nas/nassink.c:
+	  it's endianness, not endianess
+	* gst-libs/gst/audio/audio.h:
+	  make float standard pad template caps really describe float
+	* gst/law/mulaw.c: (linear_factory):
+	  signed only, please
+	* gst/mpegstream/gstdvddemux.c:
+	  widths of 20 are not valid
+
+2004-11-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	Submitted by: Luca Ferretti <elle.uca@infinito.it>
+
+	* po/LINGUAS:
+	* po/it.po:
+	  Add Italian
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/README:
+	* gst/playback/gstdecodebin.c: (close_pad_link), (try_to_link_1):
+	* gst/playback/gstplaybasebin.c: (probe_triggered),
+	(gst_play_base_bin_change_state):
+	Updated README, added more comments for fixmes etc..
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_add_element):
+	We can remove this hack now.
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videomixer/videomixer.c: (gst_videomixer_blend_ayuv_ayuv),
+	(gst_videomixer_fill_checker), (gst_videomixer_fill_color),
+	(gst_videomixer_blend_buffers), (gst_videomixer_loop):
+	Only mix AYUV for maximum quality.
+
+2004-11-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (get_relative), (gst_ogg_demux_src_query),
+	(gst_ogg_demux_push), (gst_ogg_pad_push):
+	  Let's act as if we're synchronized now! :).
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	  Add some debug.
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/alpha/gstalpha.c: (gst_alpha_method_get_type),
+	(gst_alpha_set_property), (gst_alpha_sink_link),
+	(gst_alpha_set_ayuv), (gst_alpha_set_i420),
+	(gst_alpha_chroma_key_ayuv), (gst_alpha_chroma_key_i420),
+	(gst_alpha_init_params), (gst_alpha_chain):
+	Implement alpha functions for AYUV too, this increases
+	accuracy quite a bit.
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/ffmpegcolorspace/avcodec.h:
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_pixfmt_to_caps), (gst_ffmpeg_caps_to_pixfmt),
+	(gst_ffmpegcsp_avpicture_fill):
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcsp_caps_remove_format_info):
+	* gst/ffmpegcolorspace/imgconvert.c: (avpicture_get_size),
+	(shrink12), (img_get_alpha_info), (deinterlace_line),
+	(deinterlace_line_inplace):
+	* gst/ffmpegcolorspace/imgconvert_template.h:
+	Added AYUV colorspace and handle RGBA a bit more respectful.
+
+2004-11-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	  Actually always send a discont (cornercase when resending the
+	  same serial-tagged chain twice).
+
+2004-11-08  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_clear),
+	(gst_ximagesink_finalize):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_clear),
+	(gst_xvimagesink_finalize): Some more cleanups, leaks fixed and checks.
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/typefind/gsttypefindfunctions.c: (aac_type_find):
+	Don't segfault on NULL data.
+
+2004-11-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (unlinked):
+	* gst/playback/gstplay-marshal.list:
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init),
+	(gst_play_base_bin_init), (group_create), (get_active_group),
+	(get_building_group), (group_destroy), (group_commit),
+	(queue_overrun), (remove_groups), (add_stream), (unknown_type),
+	(add_element_stream), (no_more_pads), (probe_triggered),
+	(preroll_unlinked), (new_decoded_pad), (removed_decoded_pad),
+	(state_change), (setup_source), (gst_play_base_bin_get_property),
+	(gst_play_base_bin_change_state), (gst_play_base_bin_add_element),
+	(gst_play_base_bin_link_stream),
+	(gst_play_base_bin_get_streaminfo):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gst_play_bin_class_init),
+	(remove_sinks), (setup_sinks), (gst_play_bin_change_state):
+	Add support for chained ogg files. Prepare for playlist
+	support. This patch introduces the concept of pad groups, which
+	together compose one playable media file.
+
+2004-11-07  David Schleef  <ds@schleef.org>
+
+	* testsuite/gst-lint: Check for pad templates that aren't statically
+	scoped.
+
+2004-11-07  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/musepack/Makefile.am:
+	* ext/musepack/gstmusepackdec.cpp:
+	* ext/musepack/gstmusepackdec.h:
+	* ext/musepack/gstmusepackreader.cpp:
+	* ext/musepack/gstmusepackreader.h:
+	  Add musepack decoder.
+	* ext/faad/gstfaad.c: (gst_faad_base_init):
+	  Make pad templates static.
+	* gst/typefind/gsttypefindfunctions.c: (mp3_type_find),
+	(plugin_init):
+	  Add musepack typefinder, make mp3 typefinding work halfway stream,
+	  which doesn't actually work yet because id3demux doesn't implement
+	  _get_length().
+
+2004-11-07  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_queue_pads), (gst_ogg_mux_loop):
+	  Fix interrupt event handling (#144436).
+
+2004-11-07  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_do_typefind):
+	  Hide unused glory.
+
+2004-11-06  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/vorbis/vorbisenc.c: (raw_caps_factory):
+	  Fix weird caps (#157548).
+
+2004-11-06  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	Reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/rtp/gstrtpgsmparse.c: (gst_rtpgsm_caps_nego):
+	  Add missing NULL terminator (#157543).
+
+2004-11-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcp.h:
+	* gst/tcp/gsttcpclientsink.c:
+	* gst/tcp/gsttcpclientsrc.c:
+	* gst/tcp/gsttcpserversink.c:
+	* gst/tcp/gsttcpserversrc.c:
+	  ports can go up to 65535.  Move common defines to gsttcp.h
+
+2004-11-05  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videotestsrc/videotestsrc.c: (paint_setup_Y41B),
+	(paint_hline_Y41B), (paint_setup_Y42B), (paint_hline_Y42B):
+	Added two more colorspaces.
+
+2004-11-05  Wim Taymans  <wim@fluendo.com>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpegcsp_avpicture_fill):
+	* gst/ffmpegcolorspace/imgconvert.c: (avpicture_get_size),
+	(yuv422p_to_yuv422), (yuv420p_to_yuv422), (shrink12),
+	(img_convert), (deinterlace_line), (deinterlace_line_inplace):
+	More stride fixes.
+
+2004-11-05  Wim Taymans  <wim@fluendo.com>
+
+	* gst/alpha/gstalpha.c: (gst_alpha_set_property), (gst_alpha_add),
+	(gst_alpha_chroma_key), (gst_alpha_init_params), (gst_alpha_chain):
+	* gst/videomixer/videomixer.c: (gst_videomixer_blend_ayuv_i420),
+	(gst_videomixer_fill_checker), (gst_videomixer_blend_buffers),
+	(gst_videomixer_loop):
+	More stride fixes.
+
+2004-11-05  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstmad.c: (gst_mad_chain):
+	  don't overflow data buffer. Flush not needed sync data when syncing
+	  failed.
+
+2004-11-04  Wim Taymans  <wim@fluendo.com>
+
+	* gst/alpha/gstalpha.c: (gst_alpha_method_get_type),
+	(gst_alpha_class_init), (gst_alpha_init), (gst_alpha_set_property),
+	(gst_alpha_get_property), (gst_alpha_add), (gst_alpha_chroma_key),
+	(gst_alpha_init_params), (gst_alpha_chain),
+	(gst_alpha_change_state):
+	Updated the chroma keying algorithm with something more
+	sophisticated.
+
+2004-11-03  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videomixer/videomixer.c: (gst_videomixer_blend_ayuv_i420),
+	(gst_videomixer_fill_checker), (gst_videomixer_fill_color),
+	(gst_videomixer_blend_buffers), (gst_videomixer_loop):
+	Fix stride issues. Does not completely work for odd
+	heights.
+
+2004-11-03  Wim Taymans  <wim@fluendo.com>
+
+	* gst/alpha/gstalpha.c: (gst_alpha_method_get_type),
+	(gst_alpha_chroma_key), (gst_alpha_chain):
+	Fix stride issues. Does not completely work for odd
+	heights.
+
+2004-11-03  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_getcaps):
+	* gst/videoscale/videoscale.c: (videoscale_find_by_structure):
+	leak fixes
+
+2004-11-03  Wim Taymans  <wim@fluendo.com>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpegcsp_avpicture_fill):
+	* gst/ffmpegcolorspace/imgconvert.c: (avpicture_get_size),
+	(avpicture_alloc):
+	* gst/ffmpegcolorspace/imgconvert_template.h:
+	Use correct _fill function to get correct strides.
+
+2004-11-02  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(gst_qtdemux_add_stream), (qtdemux_parse), (qtdemux_parse_tree),
+	(qtdemux_parse_udta), (qtdemux_tag_add), (gst_qtdemux_handle_esds):
+	Change all g_print()s to debugging.  Add a bunch of consistency
+	checks.
+
+2004-11-02  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_class_init),
+	(try_to_link_1), (get_our_ghost_pad), (remove_element_chain),
+	(unlinked), (no_more_pads), (close_link):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_init),
+	(unknown_type), (add_element_stream), (new_decoded_pad),
+	(removed_decoded_pad), (setup_source):
+	* gst/playback/gststreaminfo.c: (gst_stream_info_get_type),
+	(gst_stream_info_class_init), (gst_stream_info_init),
+	(gst_stream_info_new), (gst_stream_info_dispose),
+	(stream_info_mute_pad), (gst_stream_info_set_property),
+	(gst_stream_info_get_property):
+	* gst/playback/gststreaminfo.h:
+	Fix playback of multiple files.
+	a slightly different approach to handling dynamic pad removals.
+	This one only looks at pads that we have linked.
+
+2004-11-01  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_finalize): fix an "invalid
+	free" warning from libc.
+
+2004-11-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_class_init),
+	(get_unconnected_element), (remove_starting_from), (pad_removed),
+	(close_link):
+	  Implement support for dynamic pad changing. We listen to "live"
+	  pad removals (i.e. while playing) and re-setup autoplugging
+	  after that. Playbasebin/playbin need some more work for this
+	  to finally work, but decodebin supports (and replugs) chained
+	  ogg now.
+
+2004-11-02  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_class_init), (gst_alsa_dispose),
+	(gst_alsa_finalize):
+	* ext/cdaudio/gstcdaudio.c: (gst_cdaudio_class_init),
+	(gst_cdaudio_finalize):
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_class_init),
+	(cdparanoia_finalize):
+	* ext/divx/gstdivxdec.c: (gst_divxdec_dispose):
+	* ext/divx/gstdivxenc.c: (gst_divxenc_dispose):
+	* ext/dvdread/dvdreadsrc.c: (dvdreadsrc_class_init),
+	(dvdreadsrc_finalize):
+	* ext/flac/gstflacdec.c: (gst_flacdec_class_init),
+	(gst_flacdec_finalize):
+	* ext/flac/gstflacenc.c: (gst_flacenc_class_init),
+	(gst_flacenc_finalize):
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_class_init),
+	(gst_gnomevfssink_finalize):
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_class_init),
+	(gst_gnomevfssrc_finalize):
+	* ext/libfame/gstlibfame.c: (gst_fameenc_class_init),
+	(gst_fameenc_finalize):
+	* ext/nas/nassink.c: (gst_nassink_class_init),
+	(gst_nassink_finalize):
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_finalize),
+	(gst_sdlvideosink_class_init):
+	* ext/sndfile/gstsf.c: (gst_sf_dispose):
+	* gst-libs/gst/mixer/mixertrack.c: (gst_mixer_track_dispose):
+	* gst-libs/gst/tuner/tunerchannel.c: (gst_tuner_channel_dispose):
+	* gst-libs/gst/tuner/tunernorm.c: (gst_tuner_norm_dispose):
+	* gst-libs/gst/xwindowlistener/xwindowlistener.c:
+	(gst_x_window_listener_dispose):
+	* gst/audioscale/gstaudioscale.c:
+	* gst/playondemand/gstplayondemand.c: (play_on_demand_class_init),
+	(play_on_demand_finalize):
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_dispose):
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_chain):
+	* sys/cdrom/gstcdplayer.c: (cdplayer_class_init),
+	(cdplayer_finalize):
+	* sys/glsink/glimagesink.c: (gst_glimagesink_finalize),
+	(gst_glimagesink_class_init):
+	* sys/oss/gstosselement.c: (gst_osselement_class_init),
+	(gst_osselement_finalize):
+	* sys/oss/gstosssink.c: (gst_osssink_dispose):
+	* sys/oss/gstosssrc.c: (gst_osssrc_dispose):
+	* sys/v4l/gstv4lelement.c: (gst_v4lelement_dispose):
+	  Fixes a bunch of problems with finalize and dispose functions,
+	  either assumptions that dispose is only called once, or not calling
+	  the parent class dispose/finalize function
+
+2004-11-01  Stefan Kost  <ensonic@users.sf.net>
+
+	* ext/esd/esdsink.c: (gst_esdsink_init), (gst_esdsink_link):
+	  added two api precondition guards
+	  use g_strdup with getenv to fix crash when using ENVVAR
+
+2004-11-01  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/esd/esdsink.c: (gst_esdsink_class_init),
+	(gst_esdsink_finalize):
+	Use a finalize function, not dispose, and more importantly,
+	call the parent class finalize function too
+
+2004-11-01  Johan Dahlin  <johan@gnome.org>
+
+	* ext/ogg/gstoggdemux.c:
+	* gst/tags/gstvorbistag.c:
+	Plug leaks.
+
+2004-10-31  Benjamin Otte  <otte@gnome.org>
+
+	* gst/tags/gstvorbistag.c: (gst_vorbis_tag_chain):
+	  lotsa memleaks today. But they're all small...
+
+2004-10-31  Benjamin Otte  <otte@gnome.org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	  another memleak crushed
+
+2004-10-31  Benjamin Otte  <otte@gnome.org>
+
+	* gst/tags/gstvorbistag.c: (gst_tag_to_vorbis_comments):
+	  fix memleak
+
+2004-10-31  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	  Hack to prevent crash when going to READY inside signal handler
+	  while this function is active.
+
+2004-10-31  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/ffmpegcolorspace/Makefile.am:
+	* gst/ffmpegcolorspace/avcodec.h:
+	* gst/ffmpegcolorspace/common.h:
+	* gst/ffmpegcolorspace/dsputil.c: (dsputil_static_init):
+	* gst/ffmpegcolorspace/dsputil.h:
+	* gst/ffmpegcolorspace/gstffmpeg.c: (plugin_init):
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_get_palette), (gst_ffmpeg_set_palette),
+	(gst_ffmpeg_pixfmt_to_caps), (gst_ffmpeg_smpfmt_to_caps),
+	(gst_ffmpegcsp_codectype_to_caps), (gst_ffmpeg_caps_to_smpfmt),
+	(gst_ffmpeg_caps_to_pixfmt), (gst_ffmpegcsp_caps_with_codectype),
+	(gst_ffmpegcsp_avpicture_fill):
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.h:
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcsp_caps_remove_format_info), (gst_ffmpegcsp_getcaps),
+	(gst_ffmpegcsp_pad_link), (gst_ffmpegcsp_get_type),
+	(gst_ffmpegcsp_base_init), (gst_ffmpegcsp_class_init),
+	(gst_ffmpegcsp_init), (gst_ffmpegcsp_chain),
+	(gst_ffmpegcsp_change_state), (gst_ffmpegcsp_set_property),
+	(gst_ffmpegcsp_get_property), (gst_ffmpegcolorspace_register):
+	* gst/ffmpegcolorspace/imgconvert.c:
+	(avcodec_get_chroma_sub_sample), (avcodec_get_pix_fmt_name),
+	(avcodec_get_pix_fmt), (avpicture_fill), (avpicture_layout),
+	(avpicture_get_size), (avcodec_get_pix_fmt_loss),
+	(avg_bits_per_pixel), (avcodec_find_best_pix_fmt1),
+	(avcodec_find_best_pix_fmt), (img_copy_plane), (img_copy),
+	(yuv422_to_yuv420p), (uyvy422_to_yuv420p), (uyvy422_to_yuv422p),
+	(yuv422_to_yuv422p), (yuv422p_to_yuv422), (yuv422p_to_uyvy422),
+	(uyvy411_to_yuv411p), (yuv420p_to_yuv422), (C_JPEG_TO_CCIR),
+	(img_convert_init), (img_apply_table), (shrink41), (shrink21),
+	(shrink12), (shrink22), (shrink44), (grow21_line), (grow41_line),
+	(grow21), (grow22), (grow41), (grow44), (conv411),
+	(gif_clut_index), (build_rgb_palette), (bitcopy_n), (mono_to_gray),
+	(monowhite_to_gray), (monoblack_to_gray), (gray_to_mono),
+	(gray_to_monowhite), (gray_to_monoblack), (avpicture_alloc),
+	(avpicture_free), (is_yuv_planar), (img_convert),
+	(get_alpha_info_pal8), (img_get_alpha_info), (deinterlace_line),
+	(deinterlace_line_inplace), (deinterlace_bottom_field),
+	(deinterlace_bottom_field_inplace), (avpicture_deinterlace):
+	* gst/ffmpegcolorspace/imgconvert_template.h:
+	* gst/ffmpegcolorspace/mem.c: (av_malloc), (av_realloc), (av_free):
+	* gst/ffmpegcolorspace/mmx.h:
+	* gst/ffmpegcolorspace/utils.c: (av_mallocz), (av_strdup),
+	(av_fast_realloc), (av_mallocz_static), (av_free_static),
+	(av_freep), (avcodec_get_context_defaults),
+	(avcodec_alloc_context), (avcodec_init):
+	  Sync back from gst-ffmpeg. Deprecates ffcolorspace. Adds palette
+	  handling plus update from ffmpeg CVS. Large clean-up.
+
+2004-10-31  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/Makefile.am:
+	  We need the marshallers for decodebin, too.
+
+2004-10-30  David Schleef  <ds@schleef.org>
+
+	* gst/typefind/gsttypefindfunctions.c: (qt_type_find): Make
+	  quicktime typefinding work with 64-bit offsets.
+
+2004-10-30  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_handle_sink_event):
+	  Set EOS on the element when processing an EOS event.
+	* ext/speex/gstspeexdec.h:
+	* ext/speex/gstspeexenc.h:
+	  Only keep a const ptr to the mode
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_audio_caps_with_data),
+	(gst_riff_create_audio_template_caps):
+	  Allow WMAV3, with up to 6 channels.
+	* gst/asfdemux/gstasfmux.c: (gst_asfmux_request_new_pad):
+	  Don't call gst_pad_set_event_function on a sink pad.
+	* gst/mpegstream/gstdvddemux.c:
+	(gst_dvd_demux_get_subpicture_stream),
+	(gst_dvd_demux_set_cur_audio), (gst_dvd_demux_set_cur_subpicture):
+	  Copy the explicit caps that were set across to the cur_* pads,
+	  instead of trying to use a possibly non-existent negotiated caps.
+	  Reset the type of subpicture pads to UNKNOWN after calling
+	  init_stream, so that the caps get set.
+
+2004-10-29  Martin Pitt  <martin.pitt@canonical.com>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_chunk):
+	  Don't touch buffer if it is of size 0 (fixes #151064).
+
+2004-10-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_push), (gst_ogg_pad_push):
+	  Synchronized discont handling.
+
+2004-10-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_event),
+	(gst_ogg_demux_push):
+	  Make seeking sort-of exact again (fixes #156387).
+
+2004-10-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (unknown_type),
+	(add_element_stream), (new_decoded_pad),
+	(gst_play_base_bin_change_state):
+	* gst/playback/gststreaminfo.c: (gst_stream_info_class_init),
+	(gst_stream_info_init), (gst_stream_info_new),
+	(gst_stream_info_dispose), (gst_stream_info_get_property):
+	* gst/playback/gststreaminfo.h:
+	  Make caps explicitely available. Makes testing for unsupported
+	  types possible. Improves error reporting.
+
+2004-10-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/audioconvert/gstaudioconvert.c:
+	(gst_audio_convert_buffer_to_default_format):
+	  Really don't touch read-only buffers (#156563).
+
+2004-10-29  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewd by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_fmt):
+	  Fix memleak (#155223).
+
+2004-10-29  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/.cvsignore:
+	* gst/tcp/gstmultifdsink.c: (gst_sync_method_get_type),
+	(gst_multifdsink_class_init), (gst_multifdsink_init),
+	(gst_multifdsink_add), (gst_multifdsink_remove),
+	(gst_multifdsink_remove_client_link), (is_sync_frame),
+	(gst_multifdsink_new_client),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_set_property),
+	(gst_multifdsink_get_property):
+	* gst/tcp/gstmultifdsink.h:
+	Added burst on connect sync_method, deprecated sync_clients,
+	streamlined the sync code some more.
+
+2004-10-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (thread_error), (setup_source),
+	(gst_play_base_bin_change_state):
+	  Improve error reporting.
+
+2004-10-28  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/Makefile.am:
+	* gst/tcp/fdsetstress.c: (mess_some_more), (run_test), (main):
+	* gst/tcp/gstfdset.c: (nearest_pow), (resize), (ensure_size),
+	(gst_fdset_new), (gst_fdset_free), (gst_fdset_set_mode),
+	(gst_fdset_fd_ctl_write), (gst_fdset_fd_ctl_read),
+	(gst_fdset_fd_has_closed), (gst_fdset_fd_has_error),
+	(gst_fdset_fd_can_read), (gst_fdset_fd_can_write),
+	(gst_fdset_wait):
+	Added more locks around fdset structures. Fixed/reworked
+	the poll array resizing code.
+	Added stress test for fdset.
+
+2004-10-28  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst-libs/gst/audio/gstaudiofilter.c: (gst_audiofilter_link):
+	fix build
+
+2004-10-28  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/audio/gstaudiofilter.c: (gst_audiofilter_link):
+	  fix link function to always query channels and query width for
+	  floats
+	* configure.ac:
+	  add equalizer dir
+	* gst/equalizer/Makefile.am:
+	* gst/equalizer/gstiirequalizer.c: (gst_iir_equalizer_get_type),
+	(gst_iir_equalizer_base_init), (gst_iir_equalizer_class_init),
+	(gst_iir_equalizer_init), (gst_iir_equalizer_finalize),
+	(arg_to_scale), (setup_filter),
+	(gst_iir_equalizer_compute_frequencies),
+	(gst_iir_equalizer_set_property), (gst_iir_equalizer_get_property),
+	(gst_iir_equalizer_filter_inplace), (gst_iir_equalizer_setup),
+	(plugin_init):
+	  add an equalizer
+
+2004-10-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	Submitted by: Kjartan Maraas <kmaraas@broadpark.no>
+
+	* po/LINGUAS:
+	* po/nb.po:
+	  Added Norwegian Bokmaal translation
+
+2004-10-27  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_build_list):
+	  Don't break on options (fixes #156488).
+
+2004-10-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* ext/cdaudio/Makefile.am:
+	* sys/Makefile.am:
+	  fix build on older automake
+
+2004-10-26  Wim Taymans  <wim@fluendo.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_video_getcaps),
+	(gst_dvdec_video_link), (gst_dvdec_push), (gst_dvdec_loop):
+	Allow a little margin when negotiating the framerate.
+
+2004-10-26  Stefan Kost  <ensonic@users.sf.net>
+
+	* gst/level/gstlevel.c:
+	  synchonised naming of pads and pad-templates
+
+2004-10-26  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_event),
+	(gst_ogg_demux_handle_event), (_find_chain_get_unknown_part),
+	(_find_streams_check), (gst_ogg_demux_push):
+	Fix EOS again. Needs to be done in a better way. We should not
+	remove the pad if there is no new chained stream.
+
+2004-10-26 Iain <iaingnome@gmail.com>
+
+	* ext/ogg/gstoggdemux.c (gst_ogg_pad_new): Free the tag list.
+	* gst/audioscale/gstaudioscale.c (gst_audioscale_link): Free the copy
+	of the caps.
+	* gst/interleave/interleave.c (interleave_class_init): Hook up release
+	pad.
+	(interleave_release_pad): Remove the pad.
+	* gst/level/gstlevel.c: Allow the level to take 1 or 2 channels.
+	* sys/sunaudio/gstsunaudio.c (gst_sunaudio_setparams): Pay attention to
+	the set device.
+	* sys/xvimage/xvimagesink.c (gst_xvimagesink_get_xv_support): Free the
+	attrs
+	(gst_xvimagesink_xcontext_clear): Free the xcontext.
+	(gst_xvimagesink_finalize): Free the par.
+
+2004-10-26  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavimux.c: (gst_avimux_audsinkconnect),
+	(gst_avimux_stop_file):
+	  First calculate the rate, and only then use it. Hdr.rate is a
+	  multiple and not a derivative of hdr.scale. Scale is not the
+	  same as blockalign but is solely related to rate.
+
+2004-10-26  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_init),
+	(gst_gnomevfssink_handle_event), (gst_gnomevfssink_chain):
+	  Implement seeking.
+
+2004-10-25  James Henstridge  <james@jamesh.id.au>
+
+	Reviewed by:  David Schleef  <ds@schleef.org>
+
+	* examples/gstplay/player.c: (got_stream_length), (main):
+	* examples/seeking/cdplayer.c: (update_scale):
+	* examples/seeking/seek.c: (format_value), (update_scale):
+	* examples/seeking/spider_seek.c: (format_value), (update_scale),
+	(stop_seek):
+	Build fixes on AMD64.
+
+2004-10-25  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	reviewed by: Ronald Bultje <rbultje at gnome dot org>
+
+	* sys/v4l/v4l_calls.c: (gst_v4l_get_chan_names):
+	Fix for some v4l cards which hang in v4lsrc
+
+2004-10-25  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_remove),
+	(gst_ogg_demux_push), (gst_ogg_chains_clear):
+	Make sure to remove the pad when a new chain is
+	encountered. Set some vars to NULL so we don't try
+	to reference freed memory.
+
+2004-10-25  Wim Taymans  <wim@fluendo.com>
+
+	* examples/seeking/Makefile.am:
+	* examples/seeking/cdplayer.c: (update_scale):
+	* examples/seeking/chained.c: (unlinked), (new_pad), (main):
+	* examples/seeking/playbin.c: (make_playerbin_pipeline),
+	(format_value), (update_scale), (iterate), (start_seek),
+	(stop_seek), (print_media_info), (play_cb), (pause_cb), (stop_cb),
+	(print_usage), (main):
+	Added some more examples, update others.
+
+2004-10-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/flac/gstflacdec.c: (gst_flacdec_update_metadata):
+	* ext/speex/gstspeexdec.c: (speex_dec_chain):
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+	  Add codec-name metadata.
+
+2004-10-25  Takao Fujiwara  <Takao.Fujiwara@Sun.COM>
+
+	Reviewd by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_build_list):
+	* ext/alsa/gstalsamixertrack.c: (gst_alsa_mixer_track_new):
+	* ext/alsa/gstalsamixertrack.h:
+	* po/POTFILES.in:
+	  ALSA mixer track label internationalization (#154054).
+
+2004-10-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	  Export bitrate as metadata.
+
+2004-10-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_build_list):
+	* ext/alsa/gstalsamixertrack.c: (gst_alsa_mixer_track_new):
+	* ext/alsa/gstalsamixertrack.h:
+	  Fix names, fix loop.
+
+2004-10-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/speex/gstspeexdec.c: (gst_speex_dec_init),
+	(speex_dec_convert):
+	  sinkconvert function so oggdemux can get the file length (totem).
+
+2004-10-25  James Morrison  <ja2morri@csclub.uwaterloo.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_chunk):
+	  Don't push incomplete packets.
+	* gst/typefind/gsttypefindfunctions.c: (m4a_type_find):
+	  Fix MPEG-4 audio typefinding.
+
+2004-10-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/Makefile.am:
+	* sys/v4l/gstv4l.c: (plugin_init):
+	* sys/v4l/gstv4lelement.c: (gst_v4lelement_get_type),
+	(gst_v4lelement_init), (gst_v4lelement_dispose),
+	(gst_v4lelement_change_state):
+	* sys/v4l/gstv4lelement.h:
+	* sys/v4l/gstv4lxoverlay.c: (gst_v4l_xoverlay_open),
+	(gst_v4l_xoverlay_close), (idle_refresh),
+	(gst_v4l_xoverlay_set_xwindow_id):
+	* sys/v4l/gstv4lxoverlay.h:
+	* sys/v4l/v4l-overlay_calls.c:
+	* sys/v4l/v4l_calls.h:
+	* sys/v4l2/Makefile.am:
+	* sys/v4l2/gstv4l2.c: (plugin_init):
+	* sys/v4l2/gstv4l2element.c: (gst_v4l2element_get_type),
+	(gst_v4l2element_init), (gst_v4l2element_dispose),
+	(gst_v4l2element_change_state):
+	* sys/v4l2/gstv4l2element.h:
+	* sys/v4l2/gstv4l2xoverlay.c: (gst_v4l2_xoverlay_open),
+	(gst_v4l2_xoverlay_close), (idle_refresh),
+	(gst_v4l2_xoverlay_set_xwindow_id):
+	* sys/v4l2/gstv4l2xoverlay.h:
+	* sys/v4l2/v4l2-overlay_calls.c:
+	* sys/v4l2/v4l2_calls.h:
+	  Remove client-side overlay handling, use the X-server v4l plugin
+	  for that. Nicer overlay, less code. Also make the plugin
+	  compileable without X (but then without overlay, obviously).
+	  Makes xwindowlistener obsolete, should we remove that?
+
+2004-10-25  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosssrc.c: (gst_osssrc_get_time), (gst_osssrc_get),
+	(gst_osssrc_src_query):
+	* sys/oss/gstosssrc.h:
+	  OK, so people want offset in DEFAULT. This time, actually fix all
+	  cases.
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_getcaps):
+	  Add FPS properly.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfmux.c:
+	* gst/avi/gstavimux.c:
+	  Framerate.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/gstv4l2element.c: (gst_v4l2element_set_property):
+	  Fix properties (channel, norm, frequency).
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/gstv4l2element.c: (gst_v4l2element_get_property):
+	  Flag typo.
+	* sys/v4l2/v4l2_calls.c: (gst_v4l2_set_defaults):
+	  No warnings.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/v4l2src_calls.c: (gst_v4l2src_clear_format_list):
+	  Fix hang.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/gstv4l2element.h:
+	  Yet Another Hack (tm) for kernel header borkedness.
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_init),
+	(gst_v4l2src_v4l2fourcc_to_caps), (gst_v4l2_fourcc_from_structure),
+	(gst_v4l2src_link), (gst_v4l2src_getcaps),
+	(gst_v4l2src_change_state):
+	* sys/v4l2/gstv4l2src.h:
+	* sys/v4l2/v4l2src_calls.c: (gst_v4l2src_capture_init),
+	(gst_v4l2src_capture_start), (gst_v4l2src_capture_stop):
+	  Fix caps, keep track of state, work.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_getcaps):
+	  Quiet.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosssrc.c: (gst_osssrc_get):
+	  Don't mix bytes and samples.
+
+2004-10-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggmux.c:
+	  Basic pad template which accepts OGM tracks, speex, flac, vorbis
+	  and theora. Any is incorrect.
+	* gst/asfdemux/gstasfmux.c: (gst_asfmux_vidsink_link):
+	  Fix caps.
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_base_init):
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_base_init),
+	(gst_v4lmjpegsrc_init), (gst_v4lmjpegsrc_srcconnect),
+	(gst_v4lmjpegsrc_getcaps), (gst_v4lmjpegsrc_change_state):
+	* sys/v4l/gstv4lmjpegsrc.h:
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_src_link), (gst_v4lsrc_getcaps),
+	(gst_v4lsrc_change_state):
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_capture_start),
+	(gst_v4lmjpegsrc_capture_stop):
+	  Fix caps. Keep track of internal state. Work.
+
+2004-10-23  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/Makefile.am:
+	  Fix the build fixes.
+
+2004-10-23  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query),
+	(gst_ogg_demux_src_event), (_find_chain_seek),
+	(gst_ogg_pad_push):
+	  Check for pad availability before using it.
+	* ext/ogg/gstoggdemux.c: (_find_chain_process):
+	  Fix parsing of chained ogg. Needs more work on the decoder side.
+
+2004-10-22  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/spectrum/Makefile.am:
+	* gst/spectrum/demo-osssrc.c: (spectrum_chain), (main),
+	(idle_func):
+	  Fix demo and reenable it. Yes, I'm currently playing with audio
+	  analysis tools
+
+2004-10-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	  We love it if files that start at zero work too...
+
+2004-10-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_iterate):
+	  Handle files with missing EOS headers.
+
+2004-10-21  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/tcp/gsttcpserversink.c:
+	(gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_init_send):
+	Zero some variables first (need for accept not to return EINVAL)
+
+2004-10-20  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query),
+	(gst_ogg_demux_src_event), (gst_ogg_pad_push):
+	* ext/theora/theoradec.c: (theora_dec_sink_convert),
+	(theora_dec_chain):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_get_formats),
+	(gst_vorbis_dec_init), (vorbis_dec_convert), (vorbis_dec_chain):
+	  Seeking and querying finetune.
+
+2004-10-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/raw1394/Makefile.am:
+	  fix the build
+
+2004-10-20  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_iterate):
+	  Wrong return.
+	* gst/playback/Makefile.am:
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_class_init):
+	* gst/playback/gstplay-marshal.list:
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init):
+	  Fix marshallers.
+
+2004-10-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_event):
+	  Silence.
+
+2004-10-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query),
+	(gst_ogg_demux_src_event), (gst_ogg_pad_populate),
+	(gst_ogg_pad_push):
+	  Yay for non-lineair granulepos in theora.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_init), (gst_dvdec_video_getcaps),
+	(gst_dvdec_video_link), (gst_dvdec_push), (gst_dvdec_loop):
+	* ext/dv/gstdvdec.h:
+	Make sure we renegotiate aspect ratio when the camera switches.
+
+2004-10-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query),
+	(gst_ogg_demux_src_event), (gst_ogg_pad_push):
+	  Start at zero.
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	  Skip headers. Bad idea for chained ogg, but fixes seeking.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* configure.ac:
+	I swear, this is the last time I touch this.
+
+2004-10-18  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query),
+	(gst_ogg_demux_src_event), (gst_ogg_pad_populate),
+	(_read_bos_process), (gst_ogg_demux_iterate), (gst_ogg_pad_new):
+	  Faster seeking.
+	* ext/theora/theoradec.c: (theora_dec_sink_convert):
+	  Time-to-default conversion.
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+	  Don't error on unknown packets, just skip. We should probably
+	  read them if we want to support chained ogg.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* configure.ac:
+	Added cdaudio to wrong list.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* configure.ac:
+	Revive cdaudio.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_video_getcaps),
+	(gst_dvdec_video_link), (gst_dvdec_push):
+	* ext/jpeg/gstsmokeenc.c: (gst_smokeenc_class_init),
+	(gst_smokeenc_resync), (gst_smokeenc_chain):
+	Fix mimetype on smoke encoder.
+	Add aspect ratio to dvdec. Not sure if these
+	values are correct though....
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_class_init):
+	Fix vorbis property descriptions and ranges.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_iterate):
+	Really do nothing when no data is available.
+	Go to the playing state when the stream is not seekable
+	instead of failing.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/cdaudio/gstcdaudio.c: (_do_init), (gst_cdaudio_base_init),
+	(gst_cdaudio_get_event_masks), (gst_cdaudio_send_event),
+	(gst_cdaudio_query), (plugin_init), (cdaudio_uri_get_type),
+	(cdaudio_uri_get_protocols), (cdaudio_uri_get_uri),
+	(cdaudio_uri_set_uri), (cdaudio_uri_handler_init):
+	Added uri handler for cd://
+	Port to new API.
+
+2004-10-18  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_class_init),
+	(gst_decode_bin_init), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (no_more_pads), (close_link), (type_found):
+	* gst/playback/gstplaybasebin.c: (gen_preroll_element),
+	(remove_prerolls), (unknown_type), (add_element_stream),
+	(new_decoded_pad), (setup_source), (gst_play_base_bin_add_element),
+	(gst_play_base_bin_remove_element),
+	(gst_play_base_bin_link_stream):
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_vis_element), (remove_sinks), (setup_sinks):
+	* gst/playback/gststreaminfo.c: (gst_stream_type_get_type),
+	(gst_stream_info_get_type), (gst_stream_info_class_init),
+	(gst_stream_info_init), (gst_stream_info_new),
+	(gst_stream_info_dispose), (stream_info_mute_pad),
+	(gst_stream_info_set_property), (gst_stream_info_get_property):
+	* gst/playback/gststreaminfo.h:
+	Add sink padtemplate to decodebin.
+	Added some more comments.
+	Make queue size configurable in playbasebin.
+	Added possibility to use elements as sinks (ex cdaudio).
+
+2004-10-15  Wim Taymans  <wim@fluendo.com>
+
+	* ext/speex/gstspeexenc.c: (gst_speexenc_class_init),
+	(gst_speexenc_chain):
+	Fix speex timestamps so that it gets muxed properly.
+
+2004-10-15  Wim Taymans  <wim@fluendo.com>
+
+	* ext/raw1394/gstdv1394src.c: (gst_dv1394src_get_type),
+	(gst_dv1394src_base_init), (gst_dv1394src_class_init),
+	(gst_dv1394src_init), (gst_dv1394src_dispose),
+	(gst_dv1394src_iso_receive), (gst_dv1394src_discover_avc_node),
+	(gst_dv1394src_change_state), (gst_dv1394src_get_event_mask),
+	(gst_dv1394src_event), (gst_dv1394src_get_formats),
+	(gst_dv1394src_convert), (gst_dv1394src_get_query_types),
+	(gst_dv1394src_query), (gst_dv1394src_uri_get_type),
+	(gst_dv1394src_uri_get_protocols), (gst_dv1394src_uri_get_uri),
+	(gst_dv1394src_uri_set_uri), (gst_dv1394src_uri_handler_init):
+	* ext/raw1394/gstdv1394src.h:
+	Added conversion/query functions.
+	Update buffer timestamps,
+	Added signals.
+	Added uri dv:// so it might play from the firewire in playbin.
+	Fix a possible leak.
+	Added debugging.
+
+2004-10-15  Wim Taymans  <wim@fluendo.com>
+
+	* ext/raw1394/gstdv1394src.c: (gst_dv1394src_class_init),
+	(gst_dv1394src_init), (gst_dv1394src_set_property),
+	(gst_dv1394src_get_property), (gst_dv1394src_iso_receive),
+	(gst_dv1394src_discover_avc_node), (gst_dv1394src_change_state):
+	* ext/raw1394/gstdv1394src.h:
+	Added AV/C VTR control support needed for some cameras.
+	Added automatic port detection.
+	Added properties for selecting the channel.
+	The configure.ac script is not yet updated to reflect the
+	new libavc1394 and librom1394 dependencies.
+
+2004-10-15  Wim Taymans  <wim@fluendo.com>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(qtdemux_parse), (gst_qtdemux_handle_esds):
+	An esds box is not a container.
+	Fix parsing of mp4v boxes.
+	Do not try to renegotiate fps for each frame. Need to
+	find a better method. This should fix mp4 playback.
+
+2004-10-14  David Schleef  <ds@schleef.org>
+
+	* configure.ac: update for swfdec-0.3 and liboil-0.2
+	* ext/swfdec/gstswfdec.c: update for swfdec-0.3
+	* ext/swfdec/gstswfdec.h: same
+	* gst/videofilter/gstvideobalance.c: update for liboil-0.2
+	* gst/videotestsrc/videotestsrc.c: same
+
+2004-10-14  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_add),
+	(gst_multifdsink_remove), (gst_multifdsink_remove_client_link),
+	(is_sync_frame), (gst_multifdsink_new_client),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_change_state):
+	Turn warnings into info.
+	Don't allow a state change in the streaming thread.
+
+2004-10-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/oggvorbisenc.c:
+	* ext/vorbis/vorbisdec.c:
+	  fix template sample rate
+
+2004-10-13  Wim Taymans  <wim@fluendo.com>
+
+	* ext/mad/gstmad.c: (gst_mad_check_caps_reset), (gst_mad_chain):
+	Decoding the header first fixes some problems in resyncing
+	in more mp3s.
+
+2004-10-12  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_vis_element), (remove_sinks), (setup_sinks):
+	Added vis plugin support, need to configure the vis
+	element to activate it.
+
+2004-10-12  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_get),
+	(gst_gnomevfssrc_srcpad_query), (gst_gnomevfssrc_srcpad_event):
+	  Some debug.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_reset),
+	(gst_avi_demux_handle_src_event), (gst_avi_demux_read_superindex),
+	(gst_avi_demux_read_subindexes), (gst_avi_demux_add_stream),
+	(gst_avi_demux_stream_index), (gst_avi_demux_skip),
+	(gst_avi_demux_sync), (gst_avi_demux_stream_scan),
+	(gst_avi_demux_massage_index), (gst_avi_demux_stream_header):
+	* gst/avi/gstavidemux.h:
+	  Support for openDML-2.0 indx/ix## chunks. Support for broken index
+	  recovery (where, if part of the index is broken, we will still read
+	  the rest of the index and recover the broken part by stream
+	  scanning). More broken media support. EOS workarounds. General AVI
+	  braindamage headache recovery. Aspirin included.
+
+2004-10-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_open),
+	(cdparanoia_event), (cdparanoia_query):
+	  Get rid of hideous lead-in.
+
+2004-10-11  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (setup_source):
+	Wrong var used to get g_list_next.
+
+2004-10-11  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_class_init),
+	(cdparanoia_get), (cdparanoia_open):
+	  Report discid as metadata, add duration.
+
+2004-10-11  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (setup_source):
+	Cleanup the previous pipeline a little earlier for the
+	case that a source element provides raw data.
+
+2004-10-11  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_chain):
+	  reset v1 tag offset when there is no v1 tag. Fixes id3demux always
+	  consuming the last 128 bytes, even though it was valid mp3 data.
+
+2004-10-10  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_palette_to_caps),
+	(gst_v4lsrc_getcaps), (gst_v4lsrc_get):
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_overlay):
+	Change g_warnings to GST_WARNING_OBJECT and fix colourspace issue
+
+2004-10-10  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_src_link), (gst_v4lsrc_getcaps):
+	Fix for webcams that support only specific width or height
+
+2004-10-09  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_stop_file):
+	  Fix wrong discont event setup (fixes #154967).
+
+2004-10-09  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by:  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/auparse/gstauparse.c: (gst_auparse_chain):
+	  Error out on invalid data (fixes #154807).
+
+2004-10-09  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	Reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/dvdread/dvdreadsrc.c: (_read):
+	  Make titles > 0 work again (fixes #154834).
+
+2004-10-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_template_caps):
+	  WMV3 missing in template caps.
+
+2004-10-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_massage_index):
+	  OK, so the original code was too strict. It makes random AVI files
+	  hang for seconds upon opening, which is unacceptable and is far
+	  beyond the original goal of getting multiple chunks for one-chunk
+	  sounc stream files. So now do just that.
+
+2004-10-09  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (setup_source),
+	(gst_play_base_bin_change_state):
+	  Actually clean up streaminfo if output fails. This would trigger
+	  if, for example, there was no CD in the drive. No preroll, so
+	  a streaminfo structure is created, but the subsequent state change
+	  of the thread fails.
+	* gst/playback/gstplaybin.c: (gst_play_bin_change_state):
+	  Don't change state if parent failed.
+
+2004-10-08  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybin.c: (gst_play_bin_class_init),
+	(gst_play_bin_init), (gst_play_bin_get_property), (handoff),
+	(gen_video_element), (remove_sinks):
+	  Add small bits of code for screenshot handling.
+
+2004-10-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybin.c: (gst_play_bin_set_property),
+	(gen_video_element), (gen_audio_element), (setup_sinks):
+	Don't assume the user provided sinks are named "sink"...
+
+2004-10-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (gen_preroll_element),
+	(unknown_type), (setup_source), (gst_play_base_bin_remove_element),
+	(gst_play_base_bin_link_stream):
+	Do not try to autoplug sources that generate raw streams like
+	cdparanoia.
+	disconnect the preroll overrun signal when we don't need it anymore.
+
+2004-10-08  Milosz Derezynski  <internalerror.rez@fhtw-berlin.de>
+
+	* ext/cdparanoia/gstcdparanoia.c: (_do_init),
+	Added reworked patch from #154903 from milosz derezynski (deadchip).
+
+2004-10-08  Wim Taymans  <wim@fluendo.com>
+
+	* ext/cdparanoia/gstcdparanoia.c: (_do_init),
+	(cdparanoia_base_init), (cdparanoia_class_init), (cdparanoia_init),
+	(cdparanoia_dispose), (cdparanoia_get), (cdparanoia_change_state),
+	(cdparanoia_convert), (cdparanoia_uri_get_type),
+	(cdparanoia_uri_get_protocols), (cdparanoia_uri_get_uri),
+	(cdparanoia_uri_set_uri), (cdparanoia_uri_handler_init):
+	* ext/cdparanoia/gstcdparanoia.h:
+	This adds the cdda://<tracknum> uri.
+
+2004-10-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_class_init),
+	(gst_decode_bin_init), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (no_more_pads), (close_link), (type_found):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_class_init),
+	(unknown_type), (gst_play_base_bin_remove_element),
+	(gst_play_base_bin_link_stream):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gst_play_bin_init),
+	(gst_play_bin_set_property), (gen_video_element),
+	(gen_audio_element), (setup_sinks):
+	* gst/playback/gststreaminfo.c: (gst_stream_type_get_type),
+	(gst_stream_info_get_type), (gst_stream_info_class_init),
+	(gst_stream_info_init), (gst_stream_info_new),
+	(gst_stream_info_dispose), (stream_info_mute_pad),
+	(gst_stream_info_set_property), (gst_stream_info_get_property):
+	* gst/playback/gststreaminfo.h:
+	Reuse the audio and video bins.
+	Some internal cleanups in the stream selection code.
+
+2004-10-08  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sink_link),
+	(gst_ximagesink_set_xwindow_id), (gst_ximagesink_init):
+	* sys/ximage/ximagesink.h:
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_set_xwindow_id), (gst_xvimagesink_init):
+	* sys/xvimage/xvimagesink.h: Reverting Ronald's changes as the issue is
+	not coming from those elements. Moreover these elements should not keep
+	the xid they have been given when in NULL state.
+
+2004-10-07  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sink_link),
+	(gst_ximagesink_set_xwindow_id), (gst_ximagesink_init):
+	* sys/ximage/ximagesink.h:
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_set_xwindow_id), (gst_xvimagesink_init):
+	* sys/xvimage/xvimagesink.h:
+	  Actually only create a new toplevel window if we're not gonna
+	  embed it right after.
+
+2004-10-07  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (play_base_bin_mute_pad),
+	(gst_play_base_bin_mute_stream), (gst_play_base_bin_link_stream):
+	* gst/playback/gstplaybin.c: (setup_sinks):
+	Implement muting/unmuting of streams, mute streams that are not
+	used.
+
+2004-10-07  Wim Taymans  <wim@fluendo.com>
+
+	* gst/typefind/gsttypefindfunctions.c: (ac3_type_find),
+	(plugin_init):
+	Added lame audio/x-ac3 typefind function.
+
+2004-10-06  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* configure.ac:
+	  bump nano to cvs
+
+=== release 0.8.5 ===
+
+2004-10-06  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* NEWS:
+	* RELEASE:
+	* configure.ac:
+	  releasing 0.8.5, "Take You On"
+
+2004-10-06  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_init),
+	(find_compatibles), (close_pad_link), (try_to_link_1), (new_pad),
+	(no_more_pads), (close_link), (type_found):
+	* gst/playback/gstplaybasebin.c: (new_decoded_pad):
+	* gst/playback/gstplaybin.c: (gen_video_element):
+	Do not signal the no_more_pads after the first pad when
+	we are plugging a non dynamic element with multiple
+	output pads (like swfdec, dvdec, ...).
+
+2004-10-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  bump for prerelease
+
+2004-10-06  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/wavparse/gstwavparse.c:
+	  add ATRAC3 to STATIC CAPS to fix a warning
+
+	* gst/matroska/ebml-read.c:
+	* gst-libs/gst/riff/riff-read.c:
+	  fix typos
+
+2004-10-06  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst-libs/gst/riff/riff-media.c:
+	  generate caps for ATRAC3 audio streams
+
+	* gst/realmedia/rmdemux.c:
+	  generate caps for ATRAC3 audio streams
+
+2004-10-06  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/wavparse/Makefile.am
+	* gst/wavparse/riff.h
+	* gst/wavparse/wavparse.vcproj
+	  riff.h removal (unused and duplication with riff-ids.h)
+
+2004-10-06  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/wavparse/gstwavparse.h
+	  remove duplicated defines for audio codec codes
+
+	* gst-libs/gst/riff/riff-ids.h
+	* gst/wavenc/riff.h:
+	  add "4CC" code for ATRAC3 audio streams
+	  add "4CC" code for ITU_G721_ADPCM (unused for now)
+
+2004-10-06  Wim Taymans  <wim@fluendo.com>
+
+	* gst/flx/gstflxdec.c: (gst_flxdec_init), (gst_flxdec_loop):
+	Actually _do_ negotiation. Pass gdouble as arg instead
+	of guint64 for the framerate.
+
+2004-10-06  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_init),
+	(find_compatibles), (close_pad_link), (try_to_link_1),
+	(no_more_pads), (close_link), (type_found):
+	* gst/playback/gstplaybasebin.c: (new_decoded_pad):
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_audio_element):
+	Set state on newly added element to READY so that negotiation
+	can happen ASAP.
+	Addes some more debug info.
+	Do not try to plug pads with multiple caps structures or ANY
+	because it is too dangerous since we do not do dynamic
+	replugging.
+
+2004-10-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	written by: Gora Mohanty <gora_mohanty@yahoo.co.in>
+
+	* po/LINGUAS:
+	* po/or.po:
+	  add Oriya translation
+
+2004-10-05  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_massage_index):
+	  Prevent overwrite of size member. Makes audio sound crappy.
+
+2004-10-05  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst/typefind/gsttypefindfunctions.c: (plugin_init):
+	Add rmvb to the list of known RealMedia extensions
+
+2004-10-05  Wim Taymans  <wim@fluendo.com>
+
+	* ext/libmng/gstmngdec.c: (gst_mngdec_loop), (mngdec_error),
+	(mngdec_openstream), (mngdec_closestream),
+	(mngdec_handle_sink_event), (mngdec_readdata),
+	(mngdec_gettickcount), (mngdec_settimer), (mngdec_processheader),
+	(mngdec_getcanvasline), (mngdec_refresh),
+	(gst_mngdec_change_state):
+	Set the framerate correctly.
+
+2004-10-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_massage_index):
+	  There was something wrong with the index massaging.
+
+2004-10-04  Wim Taymans  <wim@fluendo.com>
+
+	* ext/jpeg/gstjpeg.c: (smoke_type_find), (plugin_init):
+	* ext/jpeg/gstsmokedec.c: (gst_smokedec_init),
+	(gst_smokedec_chain):
+	* ext/jpeg/gstsmokedec.h:
+	* ext/jpeg/gstsmokeenc.c: (gst_smokeenc_class_init),
+	(gst_smokeenc_init), (gst_smokeenc_resync), (gst_smokeenc_chain):
+	* ext/jpeg/gstsmokeenc.h:
+	* ext/jpeg/smokecodec.c: (smokecodec_encode_new),
+	(smokecodec_decode_new), (smokecodec_info_free),
+	(smokecodec_set_quality), (smokecodec_get_quality),
+	(smokecodec_set_threshold), (smokecodec_get_threshold),
+	(smokecodec_set_bitrate), (smokecodec_get_bitrate),
+	(find_best_size), (abs_diff), (put), (smokecodec_encode_id),
+	(smokecodec_encode), (smokecodec_parse_id),
+	(smokecodec_parse_header), (smokecodec_decode):
+	* ext/jpeg/smokecodec.h:
+	* ext/jpeg/smokeformat.h:
+	Updated smoke, new bitstream, allows embedding in ogg.
+
+2004-10-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_event):
+	  Fix seeking in some files. All this code is no longer needed (and
+	  actually breaks stuff) because we now synchronize the full index
+	  right when reading the header.
+
+2004-10-04  Wim Taymans  <wim@fluendo.com>
+
+	* configure.ac:
+	configure update for libmng.
+
+2004-10-04  Wim Taymans  <wim@fluendo.com>
+
+	* ext/libmng/Makefile.am:
+	* ext/libmng/gstmng.c: (plugin_init):
+	* ext/libmng/gstmng.h:
+	* ext/libmng/gstmngdec.c: (gst_mngdec_get_type),
+	(gst_mngdec_base_init), (gst_mngdec_class_init),
+	(gst_mngdec_sinklink), (gst_mngdec_init), (gst_mngdec_src_getcaps),
+	(gst_mngdec_loop), (gst_mngdec_get_property),
+	(gst_mngdec_set_property), (mngdec_error), (mngdec_openstream),
+	(mngdec_closestream), (mngdec_handle_sink_event),
+	(mngdec_readdata), (mngdec_gettickcount), (mngdec_settimer),
+	(mngdec_processheader), (mngdec_getcanvasline), (mngdec_refresh),
+	(gst_mngdec_change_state):
+	* ext/libmng/gstmngdec.h:
+	* ext/libmng/gstmngenc.c: (gst_mngenc_get_type),
+	(mng_caps_factory), (raw_caps_factory), (gst_mngenc_base_init),
+	(gst_mngenc_class_init), (gst_mngenc_sinklink), (gst_mngenc_init),
+	(gst_mngenc_chain), (gst_mngenc_get_property),
+	(gst_mngenc_set_property):
+	* ext/libmng/gstmngenc.h:
+	Added basic MNG decoder. Needs more work. The encoder does
+	not work yet.
+
+2004-10-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/realmedia/rmdemux.c: (gst_rmdemux_handle_sink_event),
+	(gst_rmdemux_loop), (gst_rmdemux_add_stream),
+	(gst_rmdemux_parse_mdpr), (gst_rmdemux_dump_mdpr):
+	  Don't hang on length=0 chunks. Some negotiation fixes. Signal
+	  no-more-pads.
+
+2004-10-04  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  you need at least 1.0.4 of speex
+
+2004-10-04 Iain <iaingnome@gmail.com>
+
+	* ext/speex/gstspeexdec.h: Revert the includes changes.
+
+	* ext/speex/gstspeexenc.[ch]: Revert the includes changes.
+
+2004-09-30 Iain <iaingnome@gmail.com>
+
+	* sys/sunaudio/gstsunaudio.c (gst_sunaudiosink_open): Use the device
+	found during init or set as a property instead of hardcoding /dev/audio
+
+2004-10-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/realmedia/rmdemux.c: (gst_rmdemux_class_init),
+	(gst_rmdemux_init), (gst_rmdemux_handle_sink_event),
+	(gst_rmdemux_loop), (gst_rmdemux_add_stream), (re_hexdump_bytes),
+	(re_dump_pascal_string), (gst_rmdemux_dump__rmf),
+	(gst_rmdemux_dump_prop), (gst_rmdemux_parse_mdpr),
+	(gst_rmdemux_dump_mdpr), (gst_rmdemux_dump_indx),
+	(gst_rmdemux_dump_data):
+	  Use debug category, fix EOS handling. filesrc ! rmdemux now
+	  works.
+
+2004-10-04  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_index),
+	(gst_avi_demux_stream_scan), (sort), (gst_avi_demux_massage_index),
+	(gst_avi_demux_stream_header), (gst_avi_demux_stream_data):
+	  Improve allocation, cutting and sorting of the index. How takes a
+	  few seconds instead of minutes.
+
+2004-10-03  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/realmedia/rmdemux.c: (gst_rmdemux_parse_mdpr):
+	  fixed compilation
+
+2004-10-02  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_video_template_caps):
+	  Add wing commander format mimetype/fourccs.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_massage_index):
+	  Don't crash if some value is 0.
+
+2004-10-02  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_video_template_caps):
+	  Add DIB fourcc (raw, palettized 8-bit RGB).
+	* gst-libs/gst/riff/riff-read.c:
+	(gst_riff_read_strf_vids_with_data):
+	  Oops, fix strf_data reading bug.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_add_stream):
+	  Use a non-NULL tag.
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse_trak):
+	  Time for hacks. Sorry Dave. At least one quicktime movie (a
+	  trailer) that I've encountered contains multiple video tracks.
+	  One of those is the actual video track, the other are one-frame
+	  tracks (images). Unfortunately, the number of frames according
+	  to the trak header is 1 for each, so that doesn't help. So
+	  instead, I look at the duration and discard tracks with a
+	  duration shorter than 20% of the length of the stream. Better
+	  than nothing.
+
+2004-10-01  Christian Schaller <christian@fluendo.com>
+
+	* ext/ivorbis/vorbis.c:
+	  Patch from Phil Blundell (Bug 152341)
+
+2004-10-01  Wim Taymans  <wim@fluendo.com>
+
+	* ext/speex/gstspeexdec.c: (gst_speex_dec_class_init),
+	(speex_dec_get_formats), (speex_dec_convert),
+	(speex_dec_src_query), (speex_dec_src_event), (speex_dec_event),
+	(speex_dec_chain), (gst_speexdec_get_property),
+	(gst_speexdec_set_property):
+	Small cleanups.
+
+2004-10-01  Wim Taymans  <wim@fluendo.com>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_class_init),
+	(gst_wavparse_stream_init), (gst_wavparse_fmt),
+	(gst_wavparse_other), (gst_wavparse_loop),
+	(gst_wavparse_pad_convert), (gst_wavparse_pad_query),
+	(gst_wavparse_srcpad_event):
+	* gst/wavparse/gstwavparse.h:
+	Added some more debugging info.
+	Fix the case where the length of the file is 0.
+	Make sure we seek to sample borders.
+
+2004-10-01  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/README:
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_factory_filter),
+	(gst_decode_bin_init), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (no_more_pads), (close_link), (type_found):
+	Add some debug info to decodebin, update README
+
+2004-10-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/dvdnav/dvdnavsrc.c: (dvdnav_handle_navigation_event):
+	  Don't use g_print(); use GST_DEBUG().
+
+2004-10-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_queue_pads):
+	  Handle EOS properly.
+
+2004-10-01  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/faad/gstfaad.c: (gst_faad_init), (gst_faad_sinkconnect),
+	(gst_faad_chain), (gst_faad_change_state):
+	* ext/faad/gstfaad.h:
+	  Allow playback of raw (unframed) MPEG AAC files (#148993).
+
+2004-10-01  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	Reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_fmt):
+	  Throw error if we didn't recognize the stream. Fixes #152289.
+
+2004-10-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_link):
+	  Fix negotiation.
+
+2004-10-01  Francis Labonte  <francis_labonte@hotmail.com>
+
+	Reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_fmt):
+	  Fix memleak.
+
+2004-10-01  Balamurali Viswanathan  <balamurali.viswanathan@wipro.com>
+
+	Reviewed by: Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/sunaudio/gstsunaudio.c: (gst_sunaudiosink_setparams):
+	  Solve #152805.
+	* sys/sunaudio/gstsunmixer.c: (gst_sunaudiomixer_set_mute):
+	  Solve 152806.
+
+2004-10-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_audio_caps_with_data):
+	  Add codec_data handling (like asfdemux used to do).
+	* gst/asfdemux/gstasf.c: (plugin_init):
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_base_init),
+	(gst_asf_demux_add_audio_stream), (gst_asf_demux_add_video_stream):
+	  Use riff-media for caps creation instead of our own (mostly
+	  broken) copy of its functions.
+
+2004-10-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_try_capture):
+	  Don't actually error out if we get another return value than
+	  -EINVAL. Opposite to what I first thought, drivers have random
+	  return values for this, although -EINVAL is the expected return
+	  value. Since this is not fatal, we shouldn't use
+	  GST_ELEMENT_ERROR() but just GST_ERROR_OBJECT().
+
+2004-10-01  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/dvdread/dvdreadsrc.c: (dvdreadsrc_class_init),
+	(dvdreadsrc_init), (dvdreadsrc_dispose), (dvdreadsrc_set_property),
+	(dvdreadsrc_get_property), (_open), (_seek), (_read),
+	(dvdreadsrc_get), (dvdreadsrc_open_file),
+	(dvdreadsrc_change_state):
+	  Fix. Don't do one big huge loop around the whole DVD, that will
+	  cache all data and thus eat sizeof(dvd) (several GB) before we
+	  see something.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_seek):
+	  Actually NULL'ify event after using it.
+	* gst/matroska/ebml-read.c: (gst_ebml_read_use_event),
+	(gst_ebml_read_handle_event), (gst_ebml_read_element_id),
+	(gst_ebml_read_element_length), (gst_ebml_read_element_data),
+	(gst_ebml_read_seek), (gst_ebml_read_skip):
+	  Handle events.
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_base_init),
+	(gst_dvd_demux_init), (gst_dvd_demux_get_audio_stream),
+	(gst_dvd_demux_get_subpicture_stream), (gst_dvd_demux_plugin_init):
+	  Fix timing (this will probably break if I seek using menus, but
+	  I didn't get there yet). VOBs and normal DVDs should now work.
+	  Add a mpeg2-only pad with high rank so this get autoplugged for
+	  MPEG-2 movies.
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_base_init),
+	(gst_mpeg_demux_class_init), (gst_mpeg_demux_init),
+	(gst_mpeg_demux_new_output_pad), (gst_mpeg_demux_get_video_stream),
+	(gst_mpeg_demux_get_audio_stream),
+	(gst_mpeg_demux_get_private_stream), (gst_mpeg_demux_parse_packet),
+	(gst_mpeg_demux_parse_pes), (gst_mpeg_demux_plugin_init):
+	  Use this as second rank for MPEG-1 and MPEG-2. Still use this for
+	  MPEG-1 but use dvddemux for MPEG-2.
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_class_init),
+	(gst_mpeg_parse_init), (gst_mpeg_parse_new_pad),
+	(gst_mpeg_parse_parse_packhead):
+	  Timing. Only add pad template if it exists. Add sink template from
+	  class and not from ourselves. This means we will always use the
+	  correct sink template even if it is not the one defined in this
+	  file.
+
+2004-09-29  Wim Taymans  <wim@fluendo.com>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_packet),
+	(gst_mpeg_demux_parse_pes):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_parse_packhead):
+	Fix playback of mpeg again, timestamps where screwed up by
+	patch 1.61.
+
+2004-09-29  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/flac/gstflacdec.c: (gst_flacdec_src_query):
+	  Only return true if we actually filled something in. Prevents
+	  player applications from showing a random length for flac files.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_class_init),
+	(gst_riff_read_use_event), (gst_riff_read_handle_event),
+	(gst_riff_read_seek), (gst_riff_read_skip), (gst_riff_read_strh),
+	(gst_riff_read_strf_vids_with_data),
+	(gst_riff_read_strf_auds_with_data), (gst_riff_read_strf_iavs):
+	  OK, ok, so I implemented event handling. Apparently it's normal
+	  that we receive random events at random points without asking
+	  for it.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_reset),
+	(gst_avi_demux_src_convert), (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_handle_src_event), (gst_avi_demux_stream_index),
+	(gst_avi_demux_sync), (gst_avi_demux_stream_scan),
+	(gst_avi_demux_massage_index), (gst_avi_demux_stream_header),
+	(gst_avi_demux_handle_seek), (gst_avi_demux_process_next_entry),
+	(gst_avi_demux_stream_data), (gst_avi_demux_loop):
+	* gst/avi/gstavidemux.h:
+	  Implement non-lineair chunk handling and subchunk processing.
+	  The first solves playback of AVI files where the audio and video
+	  data of individual buffers that we read are not synchronized.
+	  This should not happen according to the wonderful AVI specs, but
+	  of course it does happen in reality. It is also a prerequisite for
+	  the second. Subchunk processing allows us to cut chunks in small
+	  pieces and process each of these pieces separately. This is
+	  required because I've seen several AVI files with incredibly large
+	  audio chunks, even some files with only one audio chunk for the
+	  whole file. This allows for proper playback including seeking.
+	  This patch is supposed to fix all AVI A/V sync issues.
+	* gst/flx/gstflxdec.c: (gst_flxdec_class_init),
+	(flx_decode_chunks), (flx_decode_color), (gst_flxdec_loop):
+	  Work.
+	* gst/modplug/gstmodplug.cc:
+	  Proper return value setting for the query() function.
+	* gst/playback/gstplaybasebin.c: (setup_source):
+	  Being in non-playing state (after, e.g., EOS) is not necessarily
+	  a bad thing. Allow for that. This fixes playback of short files.
+	  They don't actually playback fully now, because the clock already
+	  runs. This means that small files (<500kB) with a small length
+	  (<2sec) will still not or barely play. Other files, such as mod
+	  or flx, will work correctly, however.
+
+2004-09-28  Wim Taymans  <wim@fluendo.com>
+
+	* ext/speex/gstspeex.c: (plugin_init):
+	* ext/speex/gstspeexdec.c: (gst_speex_dec_base_init),
+	(gst_speex_dec_class_init), (speex_dec_get_formats),
+	(speex_get_event_masks), (speex_get_query_types),
+	(gst_speex_dec_init), (speex_dec_convert), (speex_dec_src_query),
+	(speex_dec_src_event), (speex_dec_event), (speex_dec_chain),
+	(gst_speexdec_get_property), (gst_speexdec_set_property),
+	(speex_dec_change_state):
+	* ext/speex/gstspeexdec.h:
+	* ext/speex/gstspeexenc.c: (gst_speexenc_get_formats),
+	(gst_speexenc_get_type), (speex_caps_factory), (raw_caps_factory),
+	(gst_speexenc_base_init), (gst_speexenc_class_init),
+	(gst_speexenc_sinkconnect), (gst_speexenc_convert_src),
+	(gst_speexenc_convert_sink), (gst_speexenc_get_query_types),
+	(gst_speexenc_src_query), (gst_speexenc_init),
+	(gst_speexenc_get_tag_value), (comment_init), (comment_add),
+	(gst_speexenc_metadata_set1), (gst_speexenc_set_metadata),
+	(gst_speexenc_setup), (gst_speexenc_buffer_from_data),
+	(gst_speexenc_push_buffer), (gst_speexenc_set_header_on_caps),
+	(gst_speexenc_chain), (gst_speexenc_get_property),
+	(gst_speexenc_set_property), (gst_speexenc_change_state):
+	* ext/speex/gstspeexenc.h:
+	Rewrote speex encoder, make sure it can be embedded in ogg.
+	Implemented speex decoder.
+
+2004-09-28  Christian Schaller <christian@fluendo.com>
+
+	* configure.ac:
+	Remove kioslave plugin. Markey is brewing a new working one
+	* ext/Makefile.am: Remove kioslave plugin
+	* ext/kio: remove
+	* gst-plugins.spec.in: remove kio plugin from spec
+
+2004-09-27  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_add),
+	(gst_multifdsink_remove), (gst_multifdsink_remove_client_link),
+	(is_sync_frame), (gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_new_client),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients):
+	* gst/tcp/gstmultifdsink.h:
+	Make syncing to keyframes actually work for new clients and lagging
+	clients.
+
+2004-09-26  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/debug/gstnavigationtest.c: (gst_navigationtest_class_init),
+	(gst_navigationtest_handle_src_event), (draw_box_planar411),
+	(gst_navigationtest_planar411), (gst_navigationtest_change_state):
+	* gst/debug/gstnavigationtest.h:
+	  make navigationtest display button-press and button-release events
+
+2004-09-26 Iain <iaingnome@gmail.com>
+
+	* gst/interleave/interleave.c (all_channels_new_media): Checks if all
+	the channels have received a new media event.
+	(interleave_buffered_loop): Compresses a new media event on all
+	channels into one.
+
+2004-09-26 Iain <iaingnome@gmail.com>
+
+	* gst/wavenc/gstwavenc.c (gst_wavenc_chain): Company says we need to
+	call the sinkpad's default event handler and not the srcpads. He also
+	says this is confusing :)
+	(gst_wavenc_stop_file): Company says that seek events only go upstream
+	we should send a discontinuous downstream instead.
+
+2004-09-25  Christian Schaller <christian@fluendo.com>
+
+	* Update SPEC file to be usable in conjunction with Fedora Core,
+	  Fedora.us and freshrpms packages
+	* Fix typo in multifilesrc test Makefile
+
+2004-09-24  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (new_decoded_pad):
+	Only signal the no_more_pads signal when we have
+	added the stream to our list.
+
+2004-09-24  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (remove_prerolls),
+	(new_decoded_pad):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (setup_sinks):
+	Don't try to preroll or decode more than one audio/video
+	track.
+
+2004-09-24  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_change_state):
+	  Throw error if we failed to find a suitable output. This should
+	  throw an error if we successfully set up a pipeline (e.g. because
+	  we recognized a media file) but found no decodable streams in it
+	  (e.g. because it contains only media stream types for which we
+	  have no decoders, or because it's not a media type).
+
+2004-09-23  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/dirac/Makefile.am:
+	* ext/dirac/gstdirac.cc:
+	* ext/dirac/gstdiracdec.cc:
+	* ext/dirac/gstdiracdec.h:
+	  Do something. Don't actually know if this works because I don't
+	  have a demuxer yet.
+	* ext/gsm/gstgsmdec.c: (gst_gsmdec_getcaps):
+	  Add channels=1 to caps returned from _getcaps().
+	* ext/ogg/gstogmparse.c: (gst_ogm_audio_parse_get_type),
+	(gst_ogm_video_parse_get_type), (gst_ogm_audio_parse_base_init),
+	(gst_ogm_video_parse_base_init), (gst_ogm_parse_init),
+	(gst_ogm_audio_parse_init), (gst_ogm_video_parse_init),
+	(gst_ogm_parse_sink_convert), (gst_ogm_parse_chain),
+	(gst_ogm_parse_change_state):
+	  Separate between audio/video so ogmaudioparse actually uses the
+	  audio pad templates. Both audio and video work now, including
+	  autoplugging. Also use sometimes-srcpad hack.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_seek):
+	  Handle events better. Don't hang on infinite loops.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_class_init),
+	(gst_avi_demux_init), (gst_avi_demux_reset),
+	(gst_avi_demux_src_convert), (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_stream_header), (gst_avi_demux_stream_data),
+	(gst_avi_demux_change_state):
+	* gst/avi/gstavidemux.h:
+	  Improve A/V sync. Still not perfect.
+	* gst/matroska/ebml-read.c: (gst_ebml_read_seek),
+	(gst_ebml_read_skip):
+	  Handle events better.
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_handle_sink_event),
+	(gst_qtdemux_loop_header), (qtdemux_parse_trak),
+	(qtdemux_audio_caps):
+	  Add IMA4. Improve event handling. Save offset after a seek when
+	  the headers are at the end of the file so that we don't end up in
+	  an infinite loop.
+	* gst/typefind/gsttypefindfunctions.c: (qt_type_find):
+	  Add low-priority typefind support for files with no length.
+
+2004-09-23  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* testsuite/multifilesink/Makefile.am:
+	fix typo
+
+2004-09-22  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_destroy):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls): Fix
+	mistakes from thaytan's patches.
+
+2004-09-23  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_destroy):
+	  For completeness, XSync in the destroy function as xvimage does.
+
+2004-09-23  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/gdk_pixbuf/pixbufscale.c: (gst_pixbufscale_getcaps):
+	   Correct caps negotiation
+	* gst/volume/gstvolume.c: (volume_chain_float),
+	(volume_chain_int16):
+	   Modify debug output to be little more informative
+	* sys/ximage/ximagesink.c: (gst_ximagesink_check_xshm_calls):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_destroy):
+	  Add XSync calls after detaching from the shared memory segment to
+	  avoid a crash.
+
+2004-09-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_init),
+	(gst_ogg_mux_next_buffer), (gst_ogg_mux_loop):
+	* ext/vorbis/vorbis.c: (plugin_init):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_init),
+	(gst_vorbisenc_chain):
+	* ext/vorbis/vorbisenc.h:
+	remove explicit newmedia support from oggmux and vorbisenc
+	add debug category to vorbisenc
+	* gst/multifilesink/gstmultifilesink.c:
+	(gst_multifilesink_class_init), (gst_multifilesink_init),
+	(gst_multifilesink_dispose), (gst_multifilesink_set_location),
+	(gst_multifilesink_set_property), (gst_multifilesink_next_file),
+	(gst_multifilesink_handle_event), (gst_multifilesink_chain),
+	(plugin_init):
+	* gst/multifilesink/gstmultifilesink.h:
+	add support for streamheader in multifilesink
+
+2004-09-22  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (_read_var_length), (_read_guid),
+	(gst_asf_demux_process_segment), (gst_asf_demux_handle_data),
+	(gst_asf_demux_process_chunk), (gst_asf_demux_handle_sink_event):
+	  Prevent infinite loops. More correct error reporting.
+	* gst/auparse/gstauparse.c: (gst_auparse_chain):
+	  Error out if negotiation fails.
+	* gst/playback/gstplaybasebin.c: (setup_source),
+	(gst_play_base_bin_change_state), (gst_play_base_bin_error),
+	(gst_play_base_bin_found_tag):
+	  Error/tag forwarding. Pre-roll fixes for source errors on state
+	  changes (e.g. "file does not exist") to prevent hangs.
+
+2004-09-21  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* testsuite/multifilesink/Makefile.am:
+	* testsuite/multifilesink/lame_test.c: (gst_newmedia_base_init),
+	(gst_newmedia_class_init), (gst_newmedia_init),
+	(gst_newmedia_chain), (gst_newmedia_trigger), (test_format),
+	(newfile_signal), (test_signal), (main):
+	* testsuite/multifilesink/multifilesrc_test.c: (main):
+	* testsuite/multifilesink/oggtheora_test.c:
+	(gst_newmedia_base_init), (gst_newmedia_class_init),
+	(gst_newmedia_init), (gst_newmedia_chain), (gst_newmedia_trigger),
+	(test_format), (newfile_signal), (test_signal), (main):
+	* testsuite/multifilesink/oggvorbis_test.c:
+	(gst_newmedia_base_init), (gst_newmedia_class_init),
+	(gst_newmedia_init), (gst_newmedia_chain), (gst_newmedia_trigger),
+	(test_format), (newfile_signal), (test_signal), (main):
+	* testsuite/multifilesink/wavenc_test.c: (gst_newmedia_base_init),
+	(gst_newmedia_class_init), (gst_newmedia_init),
+	(gst_newmedia_chain), (gst_newmedia_trigger), (test_format),
+	(newfile_signal), (test_signal), (main):
+	New media tests
+
+2004-09-20  Christian Schaller <christian@fluendo.com>
+
+	* Fix mikmod license to LGPL as they have relicensed
+	* Move Dirac and Effectv into LGPL section of README_license
+
+2004-09-20  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstmad.c: (gst_mad_check_caps_reset),
+	(gst_mad_change_state):
+	  Allow for mp3 rate/channels changes. However, only very
+	  conservatively. Reason that we *have* to enable this is smiply
+	  because the mad find_sync() function is not good enough, it will
+	  regularly sync on random data as valid frames and therefore make
+	  us provide random caps as *final* caps of the stream. The best fix
+	  I could think of is to simply require several of the same stream
+	  changes in a row before we change caps.
+	  The actual testcase that works now is #
+	* ext/ogg/Makefile.am:
+	* ext/ogg/gstogg.c: (plugin_init):
+	* ext/ogg/gstogmparse.c:
+	  OGM support (video only for now; I need an audio sample file).
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_base_init),
+	(gst_asf_demux_process_stream), (gst_asf_demux_video_caps),
+	(gst_asf_demux_add_video_stream):
+	  WMV extradata.
+	* gst/playback/gstplaybasebin.c: (unknown_type):
+	  Don't error out on single unknown-types after all. It's wrong.
+	  If we found type of video and audio but not of a subtitle stream,
+	  it will still error out (which is unwanted). Will find a better fix
+	  later on.
+	* gst/typefind/gsttypefindfunctions.c: (ogmvideo_type_find),
+	(ogmaudio_type_find), (plugin_init):
+	  OGM support.
+
+2004-09-20  Johan Dahlin  <johan@gnome.org>
+
+	* ext/jpeg/gstjpegdec.c (gst_jpegdec_chain): Allocate the buffer
+	after setting caps.
+
+2004-09-19  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_init), (gst_wavenc_chain):
+	* gst/wavenc/gstwavenc.h:
+	Added newmedia support to wavenc
+
+2004-09-17  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (gst_fdset_fd_has_closed),
+	(gst_fdset_fd_has_error), (gst_fdset_fd_can_read),
+	(gst_fdset_fd_can_write), (gst_fdset_wait):
+	* gst/tcp/gstmultifdsink.c: (gst_client_status_get_type),
+	(gst_multifdsink_init), (gst_multifdsink_add),
+	(gst_multifdsink_remove), (gst_multifdsink_get_stats),
+	(gst_multifdsink_remove_client_link),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_handle_clients),
+	(gst_multifdsink_close), (gst_multifdsink_change_state):
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_class_init),
+	(gst_tcpserversink_removed):
+	Small cleanups in fdset.c
+	Use a hastable to map fd to the client structure for faster
+	lookup in _remove and get_stats.
+	Added virtual function to close the fds.
+	Handle clients even when the select/poll call was unblocked because
+	of a command.
+	Implement syncing to keyframe in the recovery procedure.
+
+2004-09-16 Iain <iaingnome@gmail.com>
+
+	* gst/audioconvert/gstaudioconvert.c (_fixate_caps_to_int): Free the
+	try caps.
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_get_audio_stream):
+	  Caps are only set if the type of the stream is unknown, but this
+	  is initialized in ->init_stream(), so set to UNKNOWN after calling
+	  ->init_stream() so that capsnego starts.
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_stream_data):
+	  Just hardcode for raw audio then. AVI audio sucks.
+
+2004-09-15  Arwed v. Merkatz  <v.merkatz@gmx.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_audio_caps):
+	* gst/matroska/matroska-mux.c: (audiosink_templ),
+	(gst_matroska_mux_audio_pad_link):
+	* gst/typefind/gsttypefindfunctions.c: (tta_caps), (plugin_init):
+	Use audio/x-ttafile for tta files and audio/x-tta for raw tta frames.
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_stream_data):
+	  Try to fix a/v sync issues.
+
+2004-09-15  David Schleef  <ds@schleef.org>
+
+	* configure.ac: remove NASM check, since we don't use it.  Update
+	dirac check to 0.4
+	* ext/dirac/gstdiracdec.cc: update to current 0.4 API
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	Initialized variables.
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_change_state),
+	(gst_qtdemux_loop_header), (qtdemux_parse), (qtdemux_parse_trak),
+	(gst_qtdemux_handle_esds), (qtdemux_audio_caps): Fix seeking, add
+	SVQ3 format
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_add_stream), (gst_avi_demux_stream_data):
+	* gst/avi/gstavidemux.h:
+	  Fix for compressed audio (mp3) timestamp generation. How did this
+	  ever work?
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybin.c: (gst_play_bin_get_property):
+	  Volume is a double not a float.
+
+2004-09-15  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_remove_client_link),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_change_state):
+	Don't close the fd in multifdsink as we didn't open it in the
+	first place. Some cleanups.
+
+2004-09-15  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_send_headers), (gst_ogg_mux_loop):
+	Fix the case where the muxer would mark pages as delta
+	frames when they are not (vorbis only ogg).
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c: (state_change), (setup_source),
+	(gst_play_base_bin_change_state):
+	  Handle the case where we failed to setup a clear pipeline. This
+	  will throw an error (or EOS, another nice case) and if you don't
+	  catch that, the app will wait for the signal forever (and thus
+	  hang).
+
+2004-09-15  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/gstgnomevfssink.c:
+	(gst_gnomevfssink_uri_get_protocols):
+	* ext/gnomevfs/gstgnomevfssrc.c:
+	(gst_gnomevfssrc_uri_get_protocols):
+	* ext/gnomevfs/gstgnomevfsuri.c: (gst_gnomevfs_get_supported_uris):
+	* ext/gnomevfs/gstgnomevfsuri.h:
+	  Use _uri_new() instead of _open(), so it doesn't take as long and
+	  Christophe's computer won't hang.
+	* gst/playback/gstplaybasebin.c: (unknown_type):
+	  Throw error on unknown media type, so apps actually display it.
+
+2004-09-14  Brian Cameron  <brian.cameron@sun.com
+
+	* tools/gst-launch-ext-m.m:  Changed ~ to $ENV{HOME} to allow
+	  this script to work on Solaris since bash shell handles echo
+	  differenly than bash.
+
+2004-09-17  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstplaybasebin.c: (queue_overrun), (no_more_pads),
+	(setup_source), (gst_play_base_bin_set_property),
+	(gst_play_base_bin_add_element):
+	* gst/playback/gstplaybin.c: (gst_play_bin_send_event):
+	Some more work on making sure seeking pauses the pipeline and
+	that changing the uri actually does something.
+
+2004-09-17  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (gst_fdset_wait):
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_close):
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_init_send),
+	(gst_tcpserversink_close):
+	Be a bit more paranoid when freeing memory.
+
+2004-09-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_add_stream),
+	(qtdemux_parse_trak):
+	  Don't crash by dividing by zero (see sample movie in #126922).
+
+2004-09-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_audio_caps):
+	  Don't touch non-existing data (fixes crash on file in #140147).
+
+2004-09-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/playback/gstplaybasebin.c:
+	(gst_play_base_bin_dispose), (gst_play_base_bin_set_property):
+	  Handle double disposals, and proper change of URIs.
+
+2004-09-13  Martin Eikermann <meiker@upb.de>
+
+	* gst/mpegstream/gstmpegparse.c:
+	  fix synchronistation for streams recorded from digital PCR
+	  fixes bug #119376
+
+2004-09-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/Makefile.am:
+	* ext/gnomevfs/gstgnomevfs.c: (plugin_init):
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_get_type),
+	(gst_gnomevfssink_dispose), (gst_gnomevfssink_init),
+	(gst_gnomevfssink_uri_get_type),
+	(gst_gnomevfssink_uri_get_protocols),
+	(gst_gnomevfssink_uri_get_uri), (gst_gnomevfssink_uri_set_uri),
+	(gst_gnomevfssink_uri_handler_init),
+	(gst_gnomevfssink_set_property), (gst_gnomevfssink_get_property),
+	(gst_gnomevfssink_open_file), (gst_gnomevfssink_close_file):
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_get_type),
+	(gst_gnomevfssrc_init), (gst_gnomevfssrc_dispose),
+	(gst_gnomevfssrc_uri_get_type),
+	(gst_gnomevfssrc_uri_get_protocols), (gst_gnomevfssrc_uri_get_uri),
+	(gst_gnomevfssrc_uri_set_uri), (gst_gnomevfssrc_uri_handler_init),
+	(gst_gnomevfssrc_set_property), (gst_gnomevfssrc_get_property),
+	(gst_gnomevfssrc_open_file), (gst_gnomevfssrc_close_file):
+	* ext/gnomevfs/gstgnomevfsuri.c: (gst_gnomevfs_get_supported_uris):
+	* ext/gnomevfs/gstgnomevfsuri.h:
+	  Add URI support to Gnome-VFS plugins. Tries to load a fixed list
+	  of fake URIs to see which this version of Gnome-VFS likes, and
+	  uses that for the Gst-URI interface. Makes playbin support http://
+	  streams. Also fix up some stupid behaviour in gnomevfssrc.
+
+2004-09-13  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_update),
+	(gst_alsa_mixer_get_volume), (gst_alsa_mixer_set_volume),
+	(gst_alsa_mixer_set_mute), (gst_alsa_mixer_set_record),
+	(gst_alsa_mixer_set_option), (gst_alsa_mixer_get_option):
+	  Update mixer (to sync with other sessions) if we try to obtain
+	  a new value. This makes alsamixer work accross applications.
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_get_time):
+	  Only call sync functions if we're running, else alsalib asserts.
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query):
+	  Sometimes fails to compile. Possibly a gcc bug.
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_audio_element):
+	  Add a reference to an application-provided object, because we lose
+	  this same reference if we add it to the bin. If we don't do this,
+	  we can only use this object once and thus crash if we go from
+	  ready to playing, back to ready and back to playing again.
+	  Also add an audioscale element because several cheap soundcards -
+	  like mine - don't support all samplerates.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get),
+	(gst_ximagesink_xcontext_clear), (gst_ximagesink_change_state):
+	  Fix wrong order or PAR calls. Makes automatically obtained PAR
+	  from the X server atually being used.
+
+2004-09-12  David Schleef  <ds@schleef.org>
+
+	Fixes: #151879, #151881, #151882, #151883, #151884, #151886,
+	#151887, #152102, #152247.
+	* examples/indexing/indexmpeg.c: 64-bit warning fixes.
+	* examples/seeking/cdparanoia.c: same
+	* examples/seeking/cdplayer.c: same
+	* examples/seeking/seek.c: same
+	* examples/seeking/spider_seek.c: same
+	* examples/seeking/vorbisfile.c: same
+	* examples/stats/mp2ogg.c: same
+	* ext/esd/esdsink.c: (gst_esdsink_class_init),
+	(gst_esdsink_dispose): Dispose of element properly.
+	* ext/ivorbis/vorbisfile.c: (gst_ivorbisfile_seek): 64-bit warning
+	fixes.
+	* ext/nas/nassink.c: (gst_nassink_class_init),
+	(gst_nassink_dispose): Dispose of element correctly.
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_chain): Fix leak.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_check_xshm_calls),
+	(gst_ximagesink_ximage_new), (gst_ximagesink_ximage_destroy):
+	Fix 64-bit warning.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_new), (gst_xvimagesink_xvimage_destroy):
+	Fix 64-bit warning.
+
+2004-09-12  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* configure.ac : change speex detection as 1.1.6 now uses
+	  .pc/pkg-config and they changed their headers location.
+
+2004-09-09  Arwed v. Merkatz  <v.merkatz@gmx.net>
+
+	* gst/matroska/matroska-mux.h:
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_reset),
+	(gst_matroska_mux_start), (gst_matroska_mux_finish),
+	(gst_matroska_mux_write_data):
+	  Write multiple blocks/frames per cluster.
+		Write meta-seek information (seek heads).
+
+2004-09-09  Scott Wheeler <wheeler@kde.org>
+
+	* gst/gstplaybin.c: (gst_play_bin_class_init), (gst_play_bin_init),
+	(gst_play_bin_set_property), (gst_play_bin_get_property),
+	(gen_audio_element), (gen_audio_element):
+	  Add a volume element / property to the pipeline.
+
+2004-09-07  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videomixer/videomixer.c: (gst_videomixer_blend_buffers):
+	Copy timestamps from the master pad to the output buffers.
+
+2004-09-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/raw1394/gstdv1394src.c:
+	  throw errors when applicable
+
+2004-09-01  Arwed v. Merkatz  <v.merkatz@gmx.net>
+
+	* gst/matroska/ebml-ids.h:
+	* gst/matroska/ebml-read.c: (gst_ebml_read_date):
+	* gst/matroska/ebml-write.c: (gst_ebml_write_date):
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_finish):
+	  automatically convert unix time <-> ebml time when reading/writing
+	  a date, use gst_ebml_write_uint to write CUETIME,
+	  not gst_ebml_write_date.
+	* gst/matroska/matroska-ids.h:
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_create_uid),
+	(gst_matroska_mux_reset), (gst_matroska_mux_audio_pad_link),
+	(gst_matroska_mux_track_header), (gst_matroska_mux_start),
+	(gst_matroska_mux_write_data):
+	  Write track and segment UIDs, write muxing date, write
+	  TRACKDEFAULTDURATION for TTA audio, write BLOCKDURATION if known.
+	  Create cues for audio only files.
+
+2004-08-31  Ronald S. Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_build_list):
+	* ext/alsa/gstalsamixertrack.c: (gst_alsa_mixer_track_new):
+	  Re-commit ALSA switches.
+	* gst/adder/gstadder.c: (gst_adder_loop):
+	  64-bit fix (#151416).
+	* gst/debug/progressreport.c: (gst_progressreport_report):
+	  64-bit fix (#151419).
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_contents):
+	  64-bit fix (#151420).
+	* gst/playback/test3.c: (update_scale):
+	  64-bit fix (#151421).
+
+2004-08-31  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  bump nano to cvs
+
+=== release 0.8.4 ===
+
+2004-08-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: releasing 0.8.4, "Alias"
+
+2004-08-31  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/theora/Makefile.am:
+	  fix makefile.  Fixes #151462.
+
+2004-08-30  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (gst_fdset_free), (gst_fdset_wait):
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_add),
+	(gst_multifdsink_remove_client_link),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write):
+	* gst/tcp/gsttcpclientsink.c: (gst_tcpclientsink_init_send):
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_init_receive):
+	Fix some memory leaks.
+
+2004-08-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	Patch by: David Schleef
+
+	* configure.ac:
+	* sys/Makefile.am:
+	  rename our detection macro for V4L2.  Fixes #151236.
+
+2004-08-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	Patch by: David Schleef
+
+	* configure.ac:
+	  check to define LAMEPRESET.  Fixes #151232.
+
+2004-08-27  David Schleef  <ds@schleef.org>
+
+	* sys/glsink/glimagesink.c: (gst_glimagesink_ximage_put),
+	(gst_glimagesink_xwindow_new), (gst_glimagesink_xcontext_get),
+	(gst_glimagesink_fixate):  Move local variable declarations to
+	make gcc-2.95 happy.
+
+2004-08-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  bump nano for prerelease
+
+2004-08-27  David Schleef  <ds@schleef.org>
+
+	* sys/sunaudio/Makefile.am: Add sunaudiosrc patch from Bala
+	* sys/sunaudio/gstsunaudiosrc.c:
+	* sys/sunaudio/gstsunaudiosrc.h:
+
+2004-08-27 Arwed v. Merkatz <v.merkatz@gmx.net>
+
+	* gst/matroska/ebml-read.c: (gst_ebml_peed_id), (gst_ebml_read_element_id),
+	handle EOS correctly
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_video_pad_link):
+	* gst/matroska/matroska-mux.h:
+	added BITMAPINFOHEADER structure, mux video/x-divx and video/x-xvid in
+	VFW compatibility mode
+
+2004-08-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Zaheer Abbas Merali
+
+	* ext/ogg/gstoggmux.c:
+	* ext/vorbis/vorbisenc.c:
+	* ext/vorbis/vorbisenc.h:
+	  handle NEWMEDIA
+
+2004-08-26 Arwed v. Merkatz <v.merkatz@gmx.net>
+
+	* gst/matroska/ebml-write.c: (gst_ebml_write_float),
+	fix byte order reversion on little endian machines.
+	* gst/matroska/matroska-mux.c: (audiosink_templ),
+	(gst_matroska_mux_audio_pad_link):
+	add TTA codec to the list of supported codecs.
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_init),
+	(gst_matroska_mux_start), (gst_matroska_mux_finish),
+	(gst_matroska_mux_write_data):
+	* gst/matroska/matroska-mux.h:
+	write segment duration correctly, write muxing app string, fixes bugs
+	#140897 and #140898.
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_loop),
+	wait for all pads to be negotiated before starting to mux.
+
+2004-08-26  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_init), (gst_lame_chain):
+	* ext/lame/gstlame.h:
+	Added new media support to lame
+
+2004-08-25 Arwed v. Merkatz <v.merkatz@gmx.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_parse_blockgroup),
+	send vorbis headers at the beginning of a stream, fixes bug #141554.
+	Interpret BLOCKDURATION and set buffer duration accordingly, fixes
+	bug #148950.
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_audio_caps),
+	(gst_matroska_demux_plugin_init):
+	* gst/matroska/matroska-ids.h:
+	enable demuxing of TTA audio streams, fixes bug #148951.
+	* gst/typefind/gsttypefindfunctions.c: (tta_type_find), (plugin_init),
+	enable typefinding for TTA audio files, fixes bug #148711.
+	* ext/xvid/gstxviddec.c: (gst_xviddec_chain),
+	set XVID_LOWDELAY flag for decoding so xvid always returns an image,
+	fixes playback of packed bitstream and xvid with bframes, bug #135407.
+
+2004-08-24  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head),
+	(gst_riff_read_element_data), (gst_riff_read_seek),
+	(gst_riff_read_skip): fix infinite loop in wavparse, fixes bug
+	#144616, patch reviewed by Ronald and committed by Christophe Fergeau
+	<teuf@gnome.org>
+
+2004-08-23 Iain <iaingnome@gmail.com>
+
+	* ext/mad/gstid3tag.c (gst_mad_id3_to_tag_list): Special case COMM
+	tags. They appear to be handled differently to normal.
+	(tag_list_to_id3_tag_foreach): Ditto.
+
+2004-08-22  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_send_headers), (gst_ogg_mux_loop):
+	Make sure we never send -1 granulepos.
+
+2004-08-20  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_loop):
+	I will accept bitchslappings with non sharp objects.
+
+2004-08-20  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* configure.ac:
+	Clean up the test for lame presets
+
+2004-08-19  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* configure.ac:
+	* ext/lame/Makefile.am:
+	* ext/lame/gstlame.c: (gst_lame_class_init),
+	(gst_lame_set_property), (gst_lame_get_property), (gst_lame_setup):
+	Only enable lame presets if version of lame has presets in API
+
+2004-08-19  Jan Schmidt  <thaytan@mad.scientist.com>
+	* gst/udp/gstudpsrc.c: (gst_udpsrc_init), (gst_udpsrc_get):
+	* gst/udp/gstudpsrc.h:
+	  Don't call gst_pad_push in a get function. Fixes #150449
+
+2004-08-18  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (gst_fdset_free), (gst_fdset_set_mode),
+	(gst_fdset_get_mode), (gst_fdset_add_fd), (gst_fdset_remove_fd),
+	(gst_fdset_fd_ctl_write), (gst_fdset_fd_ctl_read),
+	(gst_fdset_fd_has_closed), (gst_fdset_fd_has_error),
+	(gst_fdset_fd_can_read), (gst_fdset_fd_can_write),
+	(gst_fdset_wait):
+	* gst/tcp/gstfdset.h:
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_add),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write):
+	* gst/tcp/gstmultifdsink.h:
+	Some extra checks in gstfdset.
+	Only use send() when the fd is a socket. Don't try to
+	read from write only fds.
+
+2004-08-18  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (gst_fdset_add_fd), (gst_fdset_remove_fd),
+	(gst_fdset_fd_ctl_write), (gst_fdset_fd_ctl_read),
+	(gst_fdset_fd_has_closed), (gst_fdset_fd_has_error),
+	(gst_fdset_fd_can_read), (gst_fdset_fd_can_write),
+	(gst_fdset_wait):
+	Add more locking and bounds checking.
+
+2004-08-18  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (ensure_size), (gst_fdset_wait):
+	Realloc test fdset in the lock and right before starting
+	the poll call. Bump the limit to 4096.
+
+2004-08-17  David Schleef  <ds@schleef.org>
+
+	* sys/sunaudio/Makefile.am:
+	* sys/sunaudio/gstsunaudio.c: Fix caps to handle full range
+	of rates and channels.  Make debugging less obnoxious.
+
+	Patch from Balamurali Viswanathan implementing a mixer for
+	Sun audio.  (bug #144091):
+	* sys/sunaudio/gstsunelement.c:
+	* sys/sunaudio/gstsunelement.h:
+	* sys/sunaudio/gstsunmixer.c:
+	* sys/sunaudio/gstsunmixer.h:
+
+2004-08-17  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/audioscale/gstaudioscale.c:
+	* gst/audioscale/gstaudioscale.h:
+	made audioscale resample from any sample rate to any sample rate
+
+2004-08-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/libpng/gstpngdec.c:
+	  error out on unsupported types
+
+2004-08-17  Iain <iaingnome@gmail.com>
+
+	* ext/flac/gstflacenc.c (gst_flacenc_update_quality): Only set the
+	mid_side and loose_mid_side properties if its a stereo stream.
+
+2004-08-17  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (gst_theora_dec_class_init),
+	(theora_get_formats), (theora_dec_src_convert),
+	(theora_dec_sink_convert), (theora_dec_src_query),
+	(theora_dec_src_event), (theora_dec_event), (theora_dec_chain):
+	Add a debug line.
+
+2004-08-17  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_iterate),
+	(gst_ogg_pad_push):
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_init),
+	(gst_ogg_mux_request_new_pad), (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_buffer_from_page), (gst_ogg_mux_push_page),
+	(gst_ogg_mux_send_headers), (gst_ogg_mux_loop):
+	Mark delta units in the muxer.
+	Try to decode the packet after an out-of-sync error from
+	libogg.
+
+2004-08-17  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_init), (gst_multifdsink_add),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_set_property), (gst_multifdsink_get_property):
+	* gst/tcp/gstmultifdsink.h:
+	Added option to send a keyframe to clients as the first buffer.
+	Make timeout property writable.
+
+2004-08-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch by: Wim Taymans
+
+	* gst/tcp/gstfdset.c:
+	* gst/tcp/gstmultifdsink.c:
+	  fix index comparison, should include 0
+
+2004-08-16  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstfdset.c: (ensure_size), (gst_fdset_new),
+	(gst_fdset_add_fd), (gst_fdset_remove_fd),
+	(gst_fdset_fd_has_closed), (gst_fdset_fd_has_error),
+	(gst_fdset_fd_can_read), (gst_fdset_fd_can_write),
+	(gst_fdset_wait):
+	  copy when reallocing for poll so the select arguments don't get
+	  changed during the call
+
+2004-08-16  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoraenc.c: (gst_border_mode_get_type),
+	(gst_theora_enc_class_init), (theora_enc_sink_link),
+	(theora_buffer_from_packet), (theora_enc_chain):
+	Fix bug where buffers were not marked as keyframes
+	correctly.
+
+2004-08-15  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_vbrmode_get_type),
+	(gst_lame_preset_get_type), (gst_lame_class_init):
+	describe the enum values for vbr mode and presets more verbosely
+
+2004-08-13  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_mode_get_type),
+	(gst_lame_quality_get_type), (gst_lame_padding_get_type),
+	(gst_lame_preset_get_type), (gst_lame_class_init), (gst_lame_init),
+	(gst_lame_set_property), (gst_lame_get_property), (gst_lame_setup):
+	* ext/lame/gstlame.h:
+	add preset property to lame so it can use lame presets
+
+2004-08-13  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_get_property):
+	whoops forgot break, thanks teuf
+
+2004-08-13  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_vbrmode_get_type),
+	(gst_lame_class_init), (gst_lame_src_getcaps),
+	(gst_lame_sink_link), (gst_lame_init), (gst_lame_set_property),
+	(gst_lame_get_property), (gst_lame_setup):
+	* ext/lame/gstlame.h:
+	fix lame's broken vbr stuff, allow it to resample if need be, and also
+	make xing header optional
+
+2004-08-12  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_src_getcaps), (gst_lame_init):
+	added getcaps function so samplerate doesnt get fixated to silly values
+
+2004-08-12  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_src_link):
+	revert previous fix
+
+2004-08-12  Johan Dahlin  <johan@gnome.org>
+
+	* sys/v4l/gstv4lelement.c (gst_v4l_iface_supported): Remove bogus
+	checks. Doesn't matter what state we are in. Interfaces are a
+	compile time thing, not runtime. It also broke the python bindings.
+
+2004-08-12  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_src_link):
+	made source pad link function check if sinkpad is ok..fixes the problem
+	where core fixates the output rate of lame stupidly
+
+2004-08-12  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_src_link), (gst_v4lsrc_fixate):
+	* sys/v4l/v4l_calls.c:
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_set_capture):
+	  fix fixate function to handle nonsimple caps.
+	  remove bogus check in _link
+	  cleanups
+
+2004-08-12  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_class_init), (gst_lame_init):
+	set default compression ratio parameter to 0.0 so bitrate parameter
+	works :)
+
+2004-08-11  David Schleef  <ds@schleef.org>
+
+	* gst/tcp/gstfdset.c: Fix compile problem on OS/X.
+
+2004-08-11  David Schleef  <ds@schleef.org>
+
+	* gst/mpeg1sys/gstmpeg1systemencode.c: Oops, this was correct
+	before.
+
+2004-08-11  David Schleef  <ds@schleef.org>
+
+	* gst-libs/gst/video/videosink.h: Change copyright block to LGPL.
+
+2004-08-11  David Schleef  <ds@schleef.org>
+
+	* ext/pango/gsttextoverlay.c: Add copyright block and fix plugin
+	  license field
+	* gst-libs/gst/idct/Makefile.am: Remove mmx/sse code
+	* gst-libs/gst/video/gstvideosink.c: Change copyright block to
+	  LGPL.
+	* gst/auparse/gstauparse.c: Fix plugin license field.
+	* gst/monoscope/gstmonoscope.c: Fix plugin license field.
+	* gst/mpeg1sys/gstmpeg1systemencode.c: Fix plugin license field.
+	* gst/rtp/gstrtp.c: Fix plugin license field.
+
+2004-08-11  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/Makefile.am:
+	* gst/tcp/gstfdset.c: (gst_fdset_mode_get_type), (nearest_pow),
+	(ensure_size), (gst_fdset_new), (gst_fdset_free),
+	(gst_fdset_set_mode), (gst_fdset_get_mode), (gst_fdset_add_fd),
+	(gst_fdset_remove_fd), (gst_fdset_fd_ctl_write),
+	(gst_fdset_fd_ctl_read), (gst_fdset_fd_has_closed),
+	(gst_fdset_fd_has_error), (gst_fdset_fd_can_read),
+	(gst_fdset_fd_can_write), (gst_fdset_wait):
+	* gst/tcp/gstfdset.h:
+	* gst/tcp/gstmultifdsink.c: (gst_unit_type_get_type),
+	(gst_multifdsink_class_init), (gst_multifdsink_init),
+	(gst_multifdsink_add), (gst_multifdsink_remove),
+	(gst_multifdsink_clear), (gst_multifdsink_get_stats),
+	(gst_multifdsink_remove_client_link),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_client_queue_data),
+	(gst_multifdsink_client_queue_caps),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_set_property),
+	(gst_multifdsink_get_property), (gst_multifdsink_init_send),
+	(gst_multifdsink_close):
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_class_init),
+	(gst_tcpserversink_init), (gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_handle_wait), (gst_tcpserversink_init_send),
+	(gst_tcpserversink_close):
+	* gst/tcp/gsttcpserversink.h:
+	Abstracted away the select call, implemented poll (yes we ran into
+	the 1024 limit in production).
+
+2004-08-11  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcp.c:
+	* gst/tcp/gsttcpplugin.c:
+	  improve debuggging, remove assert
+
+2004-08-10  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_unit_type_get_type),
+	(gst_client_status_get_type), (gst_multifdsink_class_init),
+	(gst_multifdsink_init), (gst_multifdsink_remove_client_link),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_set_property),
+	(gst_multifdsink_get_property):
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcp-marshal.list:
+	Starting to prepare for specifying buffer time in other units
+	than buffers. Expose remove reason in signal.
+
+2004-08-10  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_add),
+	(gst_multifdsink_remove), (gst_multifdsink_clear),
+	(gst_multifdsink_remove_client_link),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_client_queue_data),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer), (gst_multifdsink_handle_clients),
+	(gst_multifdsink_chain), (gst_multifdsink_close):
+	* gst/tcp/gstmultifdsink.h:
+	Added more debugging info. Changed the way clients are
+	removed from the lists. Fixed a bug where a bad file descriptor
+	could cause many clients to be removed.
+
+2004-08-06  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/videotestsrc/gstvideotestsrc.c: (generate_capslist):
+	  allow all pixel-aspect-ratios, not just 1:1
+
+2004-08-09  David Schleef  <ds@schleef.org>
+
+	* sys/glsink/ARB_multitexture.h:  Remove old files.
+	* sys/glsink/EXT_paletted_texture.h:
+	* sys/glsink/NV_register_combiners.h:
+	* sys/glsink/gstgl_nvimage.c:
+	* sys/glsink/gstgl_pdrimage.c:
+	* sys/glsink/gstgl_rgbimage.c:
+	* sys/glsink/gstglsink.c:
+	* sys/glsink/gstglsink.h:
+	* sys/glsink/gstglxwindow.c:
+	* sys/glsink/regcomb_yuvrgb.c:
+
+2004-08-09  David Schleef  <ds@schleef.org>
+
+	Patch from Gernot Ziegler <gz@lysator.liu.se> rewriting the
+	GL sink plugin.  (Bug #147302)
+
+	* configure.ac: Test for OpenGL
+	* sys/Makefile.am: Use test for OpenGL
+	* sys/glsink/Makefile.am:
+	* sys/glsink/glimagesink.c: rewrite
+	* sys/glsink/glimagesink.h: rewrite
+
+2004-08-09  David Schleef  <ds@schleef.org>
+
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_base_init):  Only allow
+	sane framerates.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get): same
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support): same
+	* testsuite/gst-lint: Test for G_GUINT64_FORMAT usage near gettext.
+
+2004-08-09  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_add), (gst_multifdsink_get_stats),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer), (gst_multifdsink_handle_clients):
+	Do a bit more logging, make the client_read code more robust.
+
+2004-08-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/jpeg/gstjpegdec.c: (gst_jpegdec_init_source),
+	(gst_jpegdec_fill_input_buffer), (gst_jpegdec_skip_input_data),
+	(gst_jpegdec_resync_to_restart), (gst_jpegdec_term_source),
+	(gst_jpegdec_init), (gst_jpegdec_chain):
+	* gst/multipart/multipartdemux.c: (gst_multipart_demux_init),
+	(gst_multipart_demux_chain), (gst_multipart_demux_change_state):
+	  cleanups, debugging fixes and memleak plugging
+
+2004-08-09  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (gst_theora_dec_class_init),
+	(theora_get_formats), (theora_dec_src_convert),
+	(theora_dec_sink_convert), (theora_dec_src_query),
+	(theora_dec_src_event), (theora_dec_event), (theora_dec_chain),
+	(theora_dec_change_state):
+	Don't crash on missing header packets.
+
+2004-08-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/sq.po:
+	  Added Albanian translation (Laurent Dhima)
+	* po/cs.po:
+	  updated
+
+2004-08-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/lame/gstlame.c:
+	  fix/add debugging
+
+2004-08-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c:
+	* sys/xvimage/xvimagesink.c:
+	  assign all TOO_LAZY's to a real category.  Thanks to Warthy Warthog.
+
+2004-08-06  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_add), (gst_multifdsink_get_stats),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer), (gst_multifdsink_handle_clients):
+	Make sure we don't try to read more from a client that what
+	ioctl says us or we deadlock.
+
+2004-08-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_src_link),
+	(gst_videotestsrc_change_state), (gst_videotestsrc_src_query),
+	(gst_videotestsrc_handle_src_event), (gst_videotestsrc_get):
+	  decouple running_time and n_frames so it can handle changing
+	  framerate while running
+
+2004-08-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/nl.po:
+	* po/sv.po:
+	  updated translations
+
+2004-08-04  Benjamin Otte  <otte@gnome.org>
+
+	* gst/videotestsrc/gstvideotestsrc.c:
+	(gst_videotestsrc_get_capslist), (generate_capslist),
+	(plugin_init):
+	  generate the list of supported caps at startup and reuse it instead
+	  of always generating it
+
+2004-07-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_pad_link):
+	  whoops, last checkin broke normal build
+
+2004-08-03  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_get_volume),
+	(gst_alsa_mixer_set_volume), (gst_alsa_mixer_set_mute),
+	(gst_alsa_mixer_set_record), (gst_alsa_mixer_set_option),
+	(gst_alsa_mixer_get_option):
+	* ext/dvdnav/dvdnavsrc.c: (dvdnav_get_event_name),
+	(dvdnavsrc_print_event):
+	* ext/ogg/gstoggdemux.c: (_find_chain_process), (gst_ogg_print):
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_pad_link),
+	(gst_ogg_mux_pad_unlink):
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_pad_link),
+	(gst_multipart_mux_pad_unlink):
+	* gst/videofilter/gstvideobalance.c:
+	(gst_videobalance_colorbalance_set_value):
+	* gst/videomixer/videomixer.c: (gst_videomixer_pad_link),
+	(gst_videomixer_pad_unlink):
+	* po/uk.po:
+	* sys/oss/gstossmixer.c:
+	* sys/v4l/gstv4lcolorbalance.c:
+	* sys/v4l/gstv4ltuner.c:
+	* sys/v4l/v4lsrc_calls.c:
+	* sys/v4l2/gstv4l2colorbalance.c:
+	* sys/v4l2/gstv4l2tuner.c:
+	  compile fixes for --disable-gst-debug, G_DISABLE_ASSERT and friends
+
+2004-08-03  Benjamin Otte  <otte@gnome.org>
+
+	* examples/dynparams/filter.c: (ui_control_create):
+	* examples/gstplay/player.c: (print_tag):
+	* ext/alsa/gstalsa.c: (gst_alsa_request_new_pad):
+	* ext/gdk_pixbuf/gstgdkanimation.c:
+	(gst_gdk_animation_iter_may_advance):
+	* ext/jack/gstjack.c: (gst_jack_request_new_pad):
+	* ext/mad/gstid3tag.c: (gst_mad_id3_to_tag_list),
+	(tag_list_to_id3_tag_foreach), (gst_id3_tag_handle_event):
+	* ext/vorbis/oggvorbisenc.c: (gst_oggvorbisenc_get_tag_value):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_get_tag_value):
+	* ext/xine/xineaudiodec.c: (gst_xine_audio_dec_chain):
+	* gst-libs/gst/media-info/media-info-test.c: (print_tag):
+	* gst/sine/demo-dparams.c: (main):
+	* gst/tags/gstvorbistag.c: (gst_tag_to_vorbis_comments):
+	* testsuite/alsa/formats.c: (create_pipeline):
+	* testsuite/alsa/sinesrc.c: (sinesrc_force_caps), (sinesrc_get):
+	  fixes for G_DISABLE_ASSERT and friends
+	* gst/typefind/gsttypefindfunctions.c: (aac_type_find),
+	(mp3_type_frame_length_from_header), (mp3_type_find),
+	(plugin_init):
+	  require mp3 typefinding to have at least MIN_HEADERS valid headers
+	  add typefinding for AAC adts files
+
+2004-08-04  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* sys/ximage/ximagesink.c:
+	(gst_ximagesink_calculate_pixel_aspect_ratio):
+	* sys/xvimage/xvimagesink.c:
+	(gst_xvimagesink_calculate_pixel_aspect_ratio):
+	Make sure we calculate pixel-aspect-ratio using floating point maths
+
+2004-08-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/uk.po:
+	  updated translation
+
+2004-08-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get):
+	  add debugging for display PAR calculation
+
+2004-08-02  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Fix mikmod CFLAGS.
+
+2004-07-27  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioscale/gstaudioscale.c:
+	- fix templates to only support S16, it's the only format that works
+	- make caps nego code use try_set_caps_nonfixed and fixation instead
+	of try_set_caps twice, which is not nice for autopluggers
+	- change rank to secondary, so autopluggers can pick it up after
+	audioconvert
+
+2004-08-02  Iain <iain@prettypeople.org>
+
+	* gst/interleave/interleave.c (interleave_init),
+	(interleave_request_new_pad),
+	(interleave_pad_removed),
+	(interleave_buffered_loop): Use the real pad count, not the artificial
+	one.
+
+2004-08-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: bump nano back to development
+
+=== release 0.8.3 ===
+
+2004-08-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: releasing 0.8.3, "Water"
+
+2004-08-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/xvimage/xvimagesink.c:
+	(gst_xvimagesink_calculate_pixel_aspect_ratio),
+	(gst_xvimagesink_xcontext_clear), (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_change_state), (gst_xvimagesink_buffer_alloc),
+	(gst_xvimagesink_set_property), (gst_xvimagesink_get_property),
+	(gst_xvimagesink_init), (gst_xvimagesink_class_init):
+	* sys/xvimage/xvimagesink.h:
+	  apply similar PAR fixes as to ximagesink
+
+2004-08-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch from: Benjamin Otte
+
+	* ext/lame/gstlame.c: (gst_lame_src_link), (gst_lame_init):
+	  add link function to lame.  Fixes #148986.
+
+2004-08-02  Johan Dahlin  <johan@gnome.org>
+
+	* gst/multipart/multipartmux.c (gst_multipart_mux_next_buffer):
+	fix debugging log
+
+2004-07-30  David Schleef  <ds@schleef.org>
+
+	* gst/videomixer/Makefile.am: Fix things that should have been
+	fixed in the last checkin.
+
+2004-07-30  David Schleef  <ds@schleef.org>
+
+	* gst/multipart/Makefile.am: Fix things that should have been
+	fixed in the last checkin.
+
+2004-07-30  David Schleef  <ds@schleef.org>
+
+	* testsuite/multifilesink/Makefile.am: Fix unused variable.
+
+2004-07-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  bump nano for prerelease
+	* po/af.po:
+	* po/az.po:
+	* po/cs.po:
+	* po/en_GB.po:
+	* po/hu.po:
+	* po/nl.po:
+	* po/sr.po:
+	* po/sv.po:
+	* po/uk.po:
+	  updates
+
+2004-07-30  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_add), (gst_multifdsink_remove),
+	(gst_multifdsink_clear), (gst_multifdsink_get_stats),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer), (gst_multifdsink_handle_clients):
+	* gst/tcp/gstmultifdsink.h:
+	Recover from a select with a bad file descriptor by removing
+	the client.
+
+2004-07-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  fix requirement of core
+	* gst-libs/gst/play/play.c: (gst_play_error_plugin),
+	(gst_play_pipeline_setup):
+	  don't use colorspace element.  do use hermescolorspace element.
+	  make macro to get a colorspace element.
+	  mark strings for translation.
+	* po/POTFILES.in:
+	  add play.c
+	* po/af.po:
+	* po/az.po:
+	* po/cs.po:
+	* po/en_GB.po:
+	* po/hu.po:
+	* po/nl.po:
+	* po/sr.po:
+	* po/sv.po:
+	* po/uk.po:
+	  update translations
+
+2004-07-30  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/libpng/gstpngenc.c: (gst_pngenc_class_init):
+	fix default for newmedia flag
+
+2004-07-30  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (gst_theora_dec_class_init),
+	(gst_theora_dec_init), (theora_get_formats),
+	(theora_dec_src_convert), (theora_dec_sink_convert),
+	(theora_dec_src_query), (theora_dec_src_event), (theora_dec_event),
+	(theora_dec_chain), (theora_dec_set_property),
+	(theora_dec_get_property):
+	* ext/theora/theoraenc.c: (gst_border_mode_get_type),
+	(gst_theora_enc_class_init), (gst_theora_enc_init),
+	(theora_enc_sink_link), (theora_enc_chain),
+	(theora_enc_set_property), (theora_enc_get_property):
+	Added cropping option to theora decoder.
+	Added border option to theora encoder.
+
+2004-07-30  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/libpng/gstpngenc.c: (gst_pngenc_class_init),
+	(gst_pngenc_init), (gst_pngenc_chain), (gst_pngenc_get_property),
+	(gst_pngenc_set_property):
+	* ext/libpng/gstpngenc.h:
+	Added newmedia support to pngenc so now gst-launch-0.8 videotestsrc ! ffmpegcolorspace ! pngenc snapshot=false newmedia=true ! multifilesink location=blah%d.png works as expected
+
+2004-07-30  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init),
+	(theora_enc_sink_link), (theora_enc_chain),
+	(theora_enc_set_property), (theora_enc_get_property):
+	Fix encoding of non-multiple-of-16 video.
+
+2004-07-29  David Schleef  <ds@schleef.org>
+
+	* configure.ac: make test for audiofile more strict
+
+2004-07-25  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/typefind/gsttypefindfunctions.c: (plugin_init):
+	  give different names to typefind functions
+
+2004-07-28  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_renegotiate_size),
+	(gst_ximagesink_calculate_pixel_aspect_ratio),
+	(gst_ximagesink_xcontext_get), (gst_ximagesink_getcaps),
+	(gst_ximagesink_sink_link), (gst_ximagesink_change_state),
+	(gst_ximagesink_set_xwindow_id), (gst_ximagesink_set_property),
+	(gst_ximagesink_get_property), (gst_ximagesink_init):
+	* sys/ximage/ximagesink.h:
+	  allocate PAR's dynamically.
+	  use autodetected PAR if no object-set PAR is given.
+	  add workaround for directfb's X not setting physical size.
+	  fix to xvimagesink will follow tomorrow.
+
+2004-07-28  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/lame/gstlame.c: (gst_lame_chain): send tag events downstream
+	* ext/shout2/gstshout2.c: (gst_shout2send_protocol_get_type),
+	(gst_shout2send_get_type), (gst_shout2send_set_clock),
+	(gst_shout2send_class_init), (gst_shout2send_init),
+	(set_shout_metadata), (gst_shout2send_set_metadata),
+	(gst_shout2send_chain), (gst_shout2send_set_property),
+	(gst_shout2send_get_property), (gst_shout2send_connect),
+	(gst_shout2send_change_state):
+	* ext/shout2/gstshout2.h:
+	- fix for sending mp3 audio to icecast2 server, if pad link function not
+	called before PAUSED state
+	- added option to use GStreamer clock sync (as opposed to libshout's own sync)
+	- added tagging support for mp3 audio broadcasted
+	* gst/monoscope/gstmonoscope.c: (gst_monoscope_class_init):
+	debug info
+
+2004-07-28  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query),
+	(gst_ogg_demux_push):
+	Return query failure when we don't know the length of
+	an ogg stream insteda of returning TRUE with a bogus value.
+
+2004-07-28  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (theora_get_formats),
+	(theora_dec_src_convert), (theora_dec_sink_convert),
+	(theora_dec_src_query), (theora_dec_src_event), (theora_dec_event),
+	(theora_dec_chain):
+	Don't screw up the 1 Chroma for 1 luma sample situation when we
+	have an odd offset/width by adding a black border in those cases.
+
+2004-07-28  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (theora_get_formats),
+	(theora_dec_src_convert), (theora_dec_sink_convert),
+	(theora_dec_src_query), (theora_dec_src_event), (theora_dec_event),
+	(theora_dec_chain):
+	* ext/theora/theoraenc.c: (theora_enc_sink_link):
+	Added first attempt at cropping of the image as required by the
+	theora spec. We need more properties in the caps (offset_x,
+	offset_y,stride) to implement this correctly.
+
+2004-07-28  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dvdnav/README:
+	  Update the README to use dvddemux
+	* ext/gdk_pixbuf/pixbufscale.c: (gst_pixbufscale_getcaps):
+	  Ensure getcaps returns a subset of the template caps
+	* gst/mpeg2sub/gstmpeg2subt.c: (gst_mpeg2subt_base_init),
+	(gst_mpeg2subt_init):
+	  Ensure getcaps returns a subset of the template caps
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_class_init),
+	(gst_dvd_demux_init), (gst_dvd_demux_get_video_stream),
+	(gst_dvd_demux_get_subpicture_stream),
+	(gst_dvd_demux_send_subbuffer), (gst_dvd_demux_set_cur_subpicture):
+	* gst/mpegstream/gstdvddemux.h:
+	  Set the explicit caps on the current_video pad before pushing
+	  anything
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_get_video_stream),
+	(gst_mpeg_demux_get_audio_stream):
+	  Free caps used to gst_pad_set_explicit_caps, which takes a const
+	  GstCaps *
+
+2004-07-28  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: update GStreamer requirement to 0.8.4 because of
+	  GstFraction.
+
+2004-07-28  Wim Taymans  <wim@fluendo.com>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_fmt),
+	(gst_wavparse_handle_seek), (gst_wavparse_srcpad_event):
+	Add the pad to the element after setting up the caps. This
+	makes it a lot easier to autoplug.
+
+2004-07-27  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/median/gstmedian.c:
+	* gst/mpeg2subt/gstmpeg2subt.c:
+	* gst/mpegaudioparse/gstmpegaudioparse.c:
+	* gst/mpegstream/gstdvddemux.c:
+	* gst/mpegstream/gstmpegdemux.c:
+	* gst/mpegstream/gstmpegpacketize.c:
+	* gst/rtjpeg/gstrtjpeg.c:
+	* gst/rtjpeg/gstrtjpegdec.c:
+	* gst/rtjpeg/gstrtjpegenc.c:
+	* gst/sine/gstsinesrc.c:
+	* gst/smooth/gstsmooth.c:
+	* gst/smpte/gstsmpte.c:
+	* gst/smpte/gstsmpte.h:
+	* gst/stereo/gststereo.c:
+	* gst/videofilter/gstgamma.c:
+	* gst/videofilter/gstvideobalance.c:
+	* gst/videofilter/gstvideofilter.c:
+	* gst/videofilter/gstvideoflip.c:
+	* gst/videoscale/gstvideoscale.c:
+	* gst/videoscale/videoscale.c:
+	* gst/videotestsrc/gstvideotestsrc.c:
+	* gst/videotestsrc/videotestsrc.c:
+	* gst/wavenc/gstwavenc.c:
+	* gst/wavparse/gstwavparse.c:
+	  fix local includes and 64 bits constants
+
+2004-07-27  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* win32/gst.sln:
+	* gst-libs/gst/*/*.vcproj:
+	* gst/*/*.vcproj:
+	  more working plugins
+
+2004-07-27  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* testsuite/alsa/Makefile.am:
+	* testsuite/alsa/srcstate.c:
+	add test for alsasrc changing state
+
+2004-07-27  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/silence/gstsilence.c: (gst_silence_init), (gst_silence_link),
+	(gst_silence_get):
+	* gst/silence/gstsilence.h:
+	fix silence generation for 16bit raw audio
+
+2004-07-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_metadata),
+	(gst_matroska_demux_video_caps), (gst_matroska_demux_plugin_init):
+	* gst/mpegaudio/common.c:
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_class_init),
+	(gst_videoscale_getcaps), (gst_videoscale_link),
+	(gst_videoscale_src_fixate), (gst_videoscale_init),
+	(gst_videoscale_finalize):
+	* gst/videoscale/gstvideoscale.h:
+	* gst/videotestsrc/gstvideotestsrc.c:
+	(gst_videotestsrc_get_capslist):
+	* gst/wavenc/gstwavenc.c:
+	* sys/oss/gstossmixer.c: (fill_labels):
+	* sys/ximage/ximagesink.c: (gst_ximagesink_renegotiate_size),
+	(gst_ximagesink_handle_xevents),
+	(gst_ximagesink_calculate_pixel_aspect_ratio),
+	(gst_ximagesink_xcontext_get), (gst_ximagesink_fixate),
+	(gst_ximagesink_getcaps), (gst_ximagesink_sink_link),
+	(gst_ximagesink_chain), (gst_ximagesink_set_xwindow_id),
+	(gst_ximagesink_set_property), (gst_ximagesink_get_property),
+	(gst_ximagesink_init), (gst_ximagesink_class_init):
+	* sys/ximage/ximagesink.h:
+	* sys/xvimage/xvimagesink.c:
+	(gst_xvimagesink_calculate_pixel_aspect_ratio),
+	(gst_xvimagesink_xcontext_get), (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_alloc),
+	(gst_xvimagesink_set_property), (gst_xvimagesink_get_property),
+	(gst_xvimagesink_init), (gst_xvimagesink_class_init):
+	* sys/xvimage/xvimagesink.h:
+	  first batch of pixel aspect ratio commits.
+
+2004-07-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_class_init), (gst_ffmpegcolorspace_chain):
+	* gst/ffmpegcolorspace/imgconvert.c: (avpicture_fill):
+	  handle stride, needs work if we want to move stride handling
+	  upstream, but works correctly for our purposes.
+
+2004-07-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videoscale/README:
+	  add testing examples
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_link),
+	(gst_videoscale_chain):
+	* gst/videoscale/videoscale.c: (gst_videoscale_setup),
+	(gst_videoscale_get_size):
+	  add get_size function that handles stride like videotestsrc.
+	  fixes conversion for YUV formats for as much as I can test them.
+
+2004-07-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_check_xshm_calls),
+	(gst_ximagesink_ximage_new), (gst_ximagesink_ximage_destroy):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_new), (gst_xvimagesink_xvimage_destroy),
+	(gst_xvimagesink_xvimage_put):
+	  further cleanups, logging, error handling and synchronizing
+
+2004-07-27  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videomixer/videomixer.c: (gst_videomixer_pad_get_type),
+	(gst_videomixer_pad_class_init), (gst_videomixer_pad_get_property),
+	(gst_videomixer_pad_set_property),
+	(gst_videomixer_pad_sinkconnect), (gst_videomixer_pad_init),
+	(gst_video_mixer_background_get_type), (gst_videomixer_get_type),
+	(gst_videomixer_class_init), (gst_videomixer_init),
+	(gst_videomixer_getcaps), (gst_videomixer_request_new_pad),
+	(gst_videomixer_blend_ayuv_i420), (pad_zorder_compare),
+	(gst_videomixer_sort_pads), (gst_videomixer_fill_checker),
+	(gst_videomixer_fill_color), (gst_videomixer_fill_queues),
+	(gst_videomixer_blend_buffers), (gst_videomixer_update_queues),
+	(gst_videomixer_loop), (plugin_init):
+	Be a nicer negotiation citizen and provide a getcaps function on
+	the srcpad. This also fixes a crash when resizing.
+
+2004-07-27  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_new): Some fixes to image size calculation.
+
+2004-07-27  Wim Taymans  <wim@fluendo.com>
+
+	* ext/libpng/gstpngdec.c: (gst_pngdec_src_getcaps):
+	* ext/libpng/gstpngenc.c: (gst_pngenc_class_init),
+	(gst_pngenc_init), (gst_pngenc_chain), (gst_pngenc_get_property),
+	(gst_pngenc_set_property):
+	* ext/libpng/gstpngenc.h:
+	Added snapshot property to pngenc.
+	removed g_print from pngdec
+
+2004-07-27  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/ac3parse/ac3parse.vcproj
+	* gst/adder/adder.vcproj
+	* gst/alpha/alpha.vcproj
+	* gst/alpha/alphacolor.vcproj
+	* gst/asfdemux/asf.vcproj
+	* gst/audioconvert/audioconvert.vcproj
+	* gst/audiorate/audiorate.vcproj
+	* gst/audioscale/audioscale.vcproj
+	* gst/auparse/auparse.vcproj
+	* gst/avi/avi.vcproj
+	* gst/cdxaparse/cdxaparse.vcproj
+	* gst/chart/chart.vcproj
+	* gst/colorspace/colorspace.vcproj
+	* gst/cutter/cutter.vcproj
+	* gst/debug/debug.vcproj
+	* gst/debug/efence.vcproj
+	* gst/debug/navigationtest.vcproj
+	* gst/deinterlace/deinterlace.vcproj
+	* gst/effectv/effectv.vcproj
+	* gst/ffmpegcolorspace/ffmpegcolorspace.vcproj
+	* gst/filter/filter.vcproj
+	* gst/flx/flxdec.vcproj
+	* gst/goom/goom.vcproj
+	* gst/interleave/interleave.vcproj
+	* gst/law/alaw.vcproj
+	* gst/law/mulaw.vcproj
+	* gst/matroska/matroska.vcproj
+	* gst/median/median.vcproj
+	* gst/mixmatrix/mixmatrix.vcproj
+	* gst/mpeg1sys/mpeg1systemencode.vcproj
+	* gst/mpeg1videoparse/mp1videoparse.vcproj
+	* gst/mpeg2sub/mpeg2subt.vcproj
+	* gst/mpegaudio/mpegaudio.vcproj
+	* gst/mpegaudioparse/mpegaudioparse.vcproj
+	* gst/mpegstream/mpegstream.vcproj
+	* gst/multifilesink/multifilesink.vcproj
+	* gst/multipart/multipart.vcproj
+	* gst/oneton/oneton.vcproj
+	* gst/overlay/overlay.vcproj
+	* gst/passthrough/passthrough.vcproj
+	* gst/qtdemux/qtdemux.vcproj
+	* gst/realmedia/rmdemux.vcproj
+	* gst/rtjpeg/rtjpeg.vcproj
+	* gst/rtp/rtp.vcproj
+	* gst/silence/silence.vcproj
+	* gst/sine/sinesrc.vcproj
+	* gst/smooth/smooth.vcproj
+	* gst/smpte/smpte.vcproj
+	* gst/spectrum/spectrum.vcproj
+	* gst/speed/speed.vcproj
+	* gst/stereo/stereo.vcproj
+	* gst/switch/switch.vcproj
+	* gst/tags/tagedit.vcproj
+	* gst/tcp/tcp.vcproj
+	* gst/typefind/typefindfunctions.vcproj
+	* gst/udp/udp.vcproj
+	* gst/videobox/videobox.vcproj
+	* gst/videocrop/videocrop.vcproj
+	* gst/videodrop/videodrop.vcproj
+	* gst/videofilter/gamma.vcproj
+	* gst/videofilter/videobalance.vcproj
+	* gst/videofilter/videofilter.vcproj
+	* gst/videofilter/videoflip.vcproj
+	* gst/videoflip/videoflip.vcproj
+	* gst/videomixer/videomixer.vcproj
+	* gst/videorate/videorate.vcproj
+	* gst/videoscale/videoscale.vcproj
+	* gst/videotestsrc/videotestsrc.vcproj
+	* gst/virtualdub/virtualdub.vcproj
+	* gst/volenv/volenv.vcproj
+	* gst/volume/volume.vcproj
+	* gst/wavenc/wavenc.vcproj
+	* gst/wavparse/wavparse.vcproj
+	* gst/y4m/y4menc.vcproj
+	* gst-libs/gst/audio/audio.vcproj
+	* gst-libs/gst/audio/audiofilter.vcproj
+	* gst-libs/gst/colorbalance/colorbalance.vcproj
+	* gst-libs/gst/idct/idtc.vcproj
+	* gst-libs/gst/media-info/media-info.vcproj
+	* gst-libs/gst/mixer/mixer.vcproj
+	* gst-libs/gst/navigation/navigation.vcproj
+	* gst-libs/gst/play/play.vcproj
+	* gst-libs/gst/propertyprobe/propertyprobe.vcproj
+	* gst-libs/gst/resample/resample.vcproj
+	* gst-libs/gst/riff/riff.vcproj
+	* gst-libs/gst/tuner/tuner.vcproj
+	* gst-libs/gst/video/video.vcproj
+	* gst-libs/gst/xoverlay/xoverlay.vcproj
+	  avoid problems with math.h, fix release dependancy
+	  rename GStreamer-0.8.lib to libgstreamer.lib
+
+2004-07-27  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_decorate):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xwindow_decorate): When
+	the atom is not available we have to unlock the mutex. Fixes #148023
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst-libs/gst/media-info/media-info.h:
+	  issue for a vararg macro with MSVC
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/effectv/effectv.vcproj
+	* gst-libs/gst/idct/idct.vcproj:
+	* gst-libs/gst/media-info/media-info.vcproj:
+	* gst-libs/gst/navigation/navigation.vcproj:
+	* gst-libs/gst/propertyprobe/propertyprobe.vcproj:
+	* gst-libs/gst/video/video.vcproj:
+	* gst-libs/gst/xoverlay/xoverlay.vcproj:
+	  fixes for build problems
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst-libs/gst/audio/audio.def:
+	* gst-libs/gst/audio/riff.def:
+	  add some definitions needed by plugins
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/asfdemux/gstasfmux.c
+	  Fix some 64 bits constants to be glib friendly
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/ac3parse/gstac3parse.c
+	* gst/audioscale/gstaudioscale.c
+	* gst/auparse/gstauparse.c
+	* gst/colorspace/gstcolorspace.c
+	* gst/colorspace/yuv2rgb.h
+	  local include fixes
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* win32/gst.sln
+	  add more plugins to the build
+
+2004-07-26  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_check_xshm_calls),
+	(gst_ximagesink_ximage_new): Some more fixes to image size calculation.
+
+2004-07-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/level/gstlevel.c: (gst_level_link), (gst_level_chain),
+	(gst_level_set_property), (gst_level_get_property),
+	(gst_level_base_init), (gst_level_class_init):
+	  add debugging categories.  cleanups.
+
+2004-07-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videoscale/videoscale.c: (gst_videoscale_setup),
+	(gst_videoscale_planar411), (gst_videoscale_planar400),
+	(gst_videoscale_packed422), (gst_videoscale_packed422rev),
+	(gst_videoscale_scale_nearest_str1),
+	(gst_videoscale_scale_nearest_str2),
+	(gst_videoscale_scale_nearest_str4),
+	(gst_videoscale_scale_nearest_16bit),
+	(gst_videoscale_scale_nearest_24bit):
+	  fixed stride issues
+	  tested with 320x240 -> 321, 322, 324 x240
+	  tested with YV12, I420, YUY2, UYVY
+	  fixed packed422rev (don't think it could have worked before)
+	  by testing with UYVY
+
+2004-07-26  Benjamin Otte  <otte@gnome.org>
+
+	* ext/lame/gstlame.c: (gst_lame_sink_link), (gst_lame_init),
+	(gst_lame_chain), (gst_lame_setup), (gst_lame_change_state),
+	(plugin_init):
+	  add debugging category, add error checks like checking return values
+	  of setup calls, make sure it still works after
+	  PLAYING=>NULL=>PLAYING, fix encoding of mono streams
+
+2004-07-26  Wim Taymans  <wim@fluendo.com>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_get_video_stream),
+	(gst_mpeg_demux_get_audio_stream),
+	(gst_mpeg_demux_process_private):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_send_data):
+	Check for error codes from the negotiation functions. Make sure
+	we really set the pad caps when a new pad is created.
+
+2004-07-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_caps_to_pix_fmt):
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.h:
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_pad_link):
+	  don't make function do two things at the same time without reason.
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/ac3parse/ac3parse.vcproj
+	* gst/adder/adder.vcproj
+	* gst/alpha/alpha.vcproj
+	* gst/alpha/alphacolor.vcproj
+	* gst/asfdemux/asf.vcproj
+	* gst/audioconvert/audioconvert.vcproj
+	* gst/audiorate/audiorate.vcproj
+	* gst/audioscale/audioscale.vcproj
+	* gst/auparse/auparse.vcproj
+	* gst/avi/avi.vcproj
+	* gst/cdxaparse/cdxaparse.vcproj
+	* gst/chart/chart.vcproj
+	* gst/colorspace/colorspace.vcproj
+	* gst/cutter/cutter.vcproj
+	* gst/debug/debug.vcproj
+	* gst/debug/efence.vcproj
+	* gst/debug/navigationtest.vcproj
+	* gst/deinterlace/deinterlace.vcproj
+	* gst/effectv/effectv.vcproj
+	* gst/ffmpegcolorspace/ffmpegcolorspace.vcproj
+	* gst/filter/filter.vcproj
+	* gst/flx/flxdec.vcproj
+	* gst/goom/goom.vcproj
+	* gst/interleave/interleave.vcproj
+	* gst/law/alaw.vcproj
+	* gst/law/mulaw.vcproj
+	* gst/matroska/matroska.vcproj
+	* gst/median/median.vcproj
+	* gst/mixmatrix/mixmatrix.vcproj
+	* gst/mpeg1sys/mpeg1systemencode.vcproj
+	* gst/mpeg1videoparse/mp1videoparse.vcproj
+	* gst/mpeg2sub/mpeg2subt.vcproj
+	* gst/mpegaudio/mpegaudio.vcproj
+	* gst/mpegaudioparse/mpegaudioparse.vcproj
+	* gst/mpegstream/mpegstream.vcproj
+	* gst/multifilesink/multifilesink.vcproj
+	* gst/multipart/multipart.vcproj
+	* gst/oneton/oneton.vcproj
+	* gst/overlay/overlay.vcproj
+	* gst/passthrough/passthrough.vcproj
+	* gst/qtdemux/qtdemux.vcproj
+	* gst/realmedia/rmdemux.vcproj
+	* gst/rtjpeg/rtjpeg.vcproj
+	* gst/rtp/rtp.vcproj
+	* gst/silence/silence.vcproj
+	* gst/sine/sinesrc.vcproj
+	* gst/smooth/smooth.vcproj
+	* gst/smpte/smpte.vcproj
+	* gst/spectrum/spectrum.vcproj
+	* gst/speed/speed.vcproj
+	* gst/stereo/stereo.vcproj
+	* gst/switch/switch.vcproj
+	* gst/tags/tagedit.vcproj
+	* gst/tcp/tcp.vcproj
+	* gst/typefind/typefindfunctions.vcproj
+	* gst/udp/udp.vcproj
+	* gst/videobox/videobox.vcproj
+	* gst/videocrop/videocrop.vcproj
+	* gst/videodrop/videodrop.vcproj
+	* gst/videofilter/gamma.vcproj
+	* gst/videofilter/videobalance.vcproj
+	* gst/videofilter/videofilter.vcproj
+	* gst/videofilter/videoflip.vcproj
+	* gst/videoflip/videoflip.vcproj
+	* gst/videomixer/videomixer.vcproj
+	* gst/videorate/videorate.vcproj
+	* gst/videoscale/videoscale.vcproj
+	* gst/videotestsrc/videotestsrc.vcproj
+	* gst/virtualdub/virtualdub.vcproj
+	* gst/volenv/volenv.vcproj
+	* gst/volume/volume.vcproj
+	* gst/wavenc/wavenc.vcproj
+	* gst/wavparse/wavparse.vcproj
+	* gst/y4m/y4menc.vcproj
+	  more plugins supported under windows
+
+2004-07-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_new),
+	(gst_ximagesink_ximage_put), (gst_ximagesink_renegotiate_size),
+	(gst_ximagesink_chain), (gst_ximagesink_buffer_alloc):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_new),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_alloc):
+	  Add debugging statements.  Use the sizes as returned by the
+	  *CreateImage calls.
+
+2004-07-26  Johan Dahlin  <johan@gnome.org>
+
+	* gst/tcp/gsttcpclientsrc.c (gst_tcpclientsrc_get): Make sure that
+	the pad is negotiated.
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c (gst_ffmpegcolorspace_chain): Ditto
+
+2004-07-26  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst-libs/gst/colorbalance/colorbalance.vcproj:
+	* gst-libs/gst/idct/idct.vcproj:
+	* gst-libs/gst/media-info/media-info.vcproj:
+	* gst-libs/gst/mixer/mixer.vcproj:
+	* gst-libs/gst/navigation/navigation.vcproj:
+	* gst-libs/gst/play/play.vcproj:
+	* gst-libs/gst/propertyprobe/propertyprobe.vcproj:
+	* gst-libs/gst/resample/resample.vcproj:
+	* gst-libs/gst/tuner/tuner.vcproj:
+	* gst-libs/gst/video/video.vcproj:
+	* gst-libs/gst/xoverlay/xoverlay.vcproj:
+	  more plugins supported under windows
+
+2004-07-25 Iain <iain@prettypeople.org>
+
+	* gst/wavparse/gstwavparse.c (gst_wavparse_fmt): Set the caps on the
+	pad now rather than when the pad is created because state changes wipe
+	explicit caps (fixes #148043).
+
+2004-07-25  Sebastien Cote  <sc5@hermes.usherb.ca>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstmad.c:
+	  fix mad plugin crashing on Sun (fixes #148289)
+
+2004-07-25  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/avi/avi.def:
+	* gst/avi/avi.vcproj:
+	* gst/matroska/matroska.def:
+	* gst/matroska/matroska.vcproj:
+	  remove unused .def files
+
+2004-07-25  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst-libs/gst/audio/gstaudiofilter.c:
+	  Clean the local include
+
+2004-07-25  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* win32/gst.sln:
+	* gst-libs/gst/audio/audio.def:
+	* gst-libs/gst/audio/audio.vcproj:
+	* gst-libs/gst/audio/audiofilter.vcproj:
+	* gst-libs/gst/audio/riff.def:
+	* gst-libs/gst/audio/riff.vcproj:
+	* gst-libs/gst/gst-libs.def:
+	* gst-libs/gst/gst-libs.vcproj:
+	* gst/avi/avi.vcproj:
+	* gst/avi/avi.vcproj:
+	  Copy the files where needed after building, cleaner projects
+
+2004-07-25  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* gst/matroska/ebml-write.c:
+	  Fix some 64 bits constants to be glib friendly
+
+2004-07-24  Steve Lhomme  <steve.lhomme@free.fr>
+
+	* win32/gst.sln:
+	* gst-libs/gst/gst-libs.def:
+	* gst-libs/gst/gst-libs.vcproj:
+	* gst/matroska/matroska.def:
+	* gst/matroska/matroska.vcproj:
+	  Add the preliminary canvas to build plugins on Win32
+
+2004-07-23  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	  don't enfore negotiation from source side, it breaks
+	  sinesrc ! audioconvert ! osssink
+
+2004-07-22  David Schleef  <ds@schleef.org>
+
+	* gst/typefind/gsttypefindfunctions.c: (plugin_init): Add typefind
+	for ELF files, since they can easily be recognized as audio/mpeg.
+	(bug #147441)
+
+2004-07-22  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videoscale/videoscale.c: (gst_videoscale_setup),
+	(gst_videoscale_planar411), (gst_videoscale_scale_nearest_32bit),
+	(gst_videoscale_scale_nearest_24bit),
+	(gst_videoscale_scale_nearest_16bit):
+	  fix 16bit and 24bit for stride (24bit might need testing)
+	  don't pretend we do more than one algorithm
+
+2004-07-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* configure.ac:
+	* gst/Makefile.am:
+	* gst/multifilesink/Makefile.am:
+	* gst/multifilesink/gstmultifilesink.c:
+	(gst_multifilesink_get_formats),
+	(gst_multifilesink_get_query_types), (_do_init),
+	(gst_multifilesink_base_init), (gst_multifilesink_class_init),
+	(gst_multifilesink_init), (gst_multifilesink_dispose),
+	(gst_multifilesink_set_location), (gst_multifilesink_set_property),
+	(gst_multifilesink_get_property), (gst_multifilesink_open_file),
+	(gst_multifilesink_close_file), (gst_multifilesink_next_file),
+	(gst_multifilesink_pad_query), (gst_multifilesink_handle_event),
+	(gst_multifilesink_chain), (gst_multifilesink_change_state),
+	(gst_multifilesink_uri_get_type),
+	(gst_multifilesink_uri_get_protocols),
+	(gst_multifilesink_uri_get_uri), (gst_multifilesink_uri_set_uri),
+	(gst_multifilesink_uri_handler_init), (plugin_init):
+	* gst/multifilesink/gstmultifilesink.h:
+	* testsuite/Makefile.am:
+	* testsuite/multifilesink/Makefile.am:
+	* testsuite/multifilesink/fakesrc_test.c: (gst_newmedia_base_init),
+	(gst_newmedia_class_init), (gst_newmedia_init),
+	(gst_newmedia_chain), (gst_newmedia_trigger), (test_format),
+	(newfile_signal), (test_signal), (main):
+	multifilesink plugin for creating new files every time a new media
+	discontinuity event occurs
+
+2004-07-22  Wim Taymans  <wim@fluendo.com>
+
+	* gst/alpha/Makefile.am:
+	* gst/alpha/gstalphacolor.c: (gst_alpha_color_get_type),
+	(gst_alpha_color_base_init), (gst_alpha_color_class_init),
+	(gst_alpha_color_init), (gst_alpha_color_set_property),
+	(gst_alpha_color_get_property), (gst_alpha_color_sink_link),
+	(transform), (gst_alpha_color_chain),
+	(gst_alpha_color_change_state), (plugin_init):
+	Stupid plugin to to RGBA to AYUV conversion because none of
+	the colorspace plugins can handle that yet.
+
+2004-07-22  Wim Taymans  <wim@fluendo.com>
+
+	* examples/seeking/seek.c: (update_scale), (main):
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_is_dynamic),
+	(gst_decode_bin_factory_filter), (compare_ranks), (print_feature),
+	(gst_decode_bin_init), (gst_decode_bin_dispose),
+	(find_compatibles), (close_pad_link), (try_to_link_1), (new_pad),
+	(no_more_pads), (close_link), (type_found),
+	(gst_decode_bin_set_property), (gst_decode_bin_get_property),
+	(plugin_init):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_get_type),
+	(gst_play_base_bin_class_init), (gst_play_base_bin_init),
+	(gst_play_base_bin_dispose), (queue_overrun),
+	(gen_preroll_element), (remove_prerolls), (unknown_type),
+	(no_more_pads), (new_stream), (setup_source),
+	(gst_play_base_bin_set_property), (gst_play_base_bin_get_property),
+	(play_base_eos), (gst_play_base_bin_change_state),
+	(gst_play_base_bin_add_element),
+	(gst_play_base_bin_remove_element),
+	(gst_play_base_bin_mute_stream), (gst_play_base_bin_link_stream),
+	(gst_play_base_bin_unlink_stream),
+	(gst_play_base_bin_get_streaminfo):
+	* gst/playback/gstplaybin.c: (gen_video_element),
+	(gen_audio_element):
+	* gst/playback/gststreaminfo.h:
+	More playback updates, attempt to fix things after the state change
+	breakage.
+
+2004-07-22  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videoscale/videoscale.c: (gst_videoscale_planar411),
+	(gst_videoscale_scale_nearest_16bit):
+	  comment algorithm
+
+2004-07-22  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videotestsrc/gstvideotestsrc.c:
+	(gst_videotestsrc_class_init), (gst_videotestsrc_src_link),
+	(gst_videotestsrc_init), (gst_videotestsrc_get),
+	(gst_videotestsrc_set_pattern), (gst_videotestsrc_set_property),
+	(gst_videotestsrc_get_property):
+	* gst/videotestsrc/gstvideotestsrc.h:
+	* gst/videotestsrc/videotestsrc.c:
+	* gst/videotestsrc/videotestsrc.h:
+	  cleanup and commenting
+
+2004-07-21  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_init),
+	(gst_ogg_demux_get_formats), (gst_ogg_demux_src_query),
+	(gst_ogg_demux_src_event), (gst_ogg_demux_src_convert),
+	(gst_ogg_demux_handle_event), (gst_ogg_demux_seek_before),
+	(_find_chain_get_unknown_part), (_find_streams_check),
+	(gst_ogg_demux_push), (gst_ogg_pad_push):
+	* ext/theora/theoradec.c: (theora_get_formats),
+	(theora_dec_src_convert), (theora_dec_sink_convert),
+	(theora_dec_src_query), (theora_dec_src_event), (theora_dec_event),
+	(theora_dec_chain):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_get_formats),
+	(vorbis_dec_convert), (vorbis_dec_src_query),
+	(vorbis_dec_src_event), (vorbis_dec_event):
+	More seeking fixes, oggdemux now supports seeking to time and
+	uses the downstream element to convert granulepos to time.
+	Seeking in theora-only ogg files now works.
+
+2004-07-21  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (gst_theora_dec_init),
+	(theora_get_formats), (theora_get_event_masks),
+	(theora_get_query_types), (theora_dec_src_convert),
+	(theora_dec_sink_convert), (theora_dec_src_query),
+	(theora_dec_src_event), (theora_dec_event), (theora_dec_chain):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_get_formats),
+	(vorbis_get_event_masks), (vorbis_get_query_types),
+	(gst_vorbis_dec_init), (vorbis_dec_convert),
+	(vorbis_dec_src_query), (vorbis_dec_src_event), (vorbis_dec_event):
+	Added query/convert/formats functions to vorbis and theora decoders
+	so that the outside world can use them too. Fixed seeking on an
+	ogg/theora/vorbis file by disabling the seeking seeking on the
+	theora srcpad.
+
+2004-07-21  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_new),
+	(gst_ximagesink_renegotiate_size), (gst_ximagesink_sink_link),
+	(gst_ximagesink_chain), (gst_ximagesink_set_xwindow_id): Optimize
+	images creation for both elements. We don't create the image on caps
+	nego or renego, we just destroy the internal one if present if it does
+	not match the needs. The chain function takes care of creating a new
+	image when needed.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_new),
+	(gst_xvimagesink_xwindow_decorate), (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_alloc),
+	(gst_xvimagesink_set_xwindow_id): Additionally xvimage now contains
+	the image format information. The buffer pool checks for the context
+	image format and discard images with different formats.
+	* sys/xvimage/xvimagesink.h: Adding im_format in the xvimage structure.
+
+2004-07-21  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_chain):
+	  no point in doing any chaining if the pad we want to push from
+	  isn't usable.
+
+2004-07-20  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_audio_caps_with_data):
+	  Fix double end-to-native symbol conversion (#148021).
+
+2004-07-20  David Schleef  <ds@schleef.org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_decorate):
+	Don't use an Atom that doesn't exist.
+
+2004-07-20  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_add), (gst_multifdsink_get_stats),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer):
+	* gst/tcp/gstmultifdsink.h:
+	More multifdsink stats. Avoid deadlock by releasing locks
+	before sending out a signal.
+
+2004-07-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/hu.po:
+	  added Hungarian translation (Laszlo Dvornik)
+
+2004-07-20  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_add), (gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer):
+	* gst/tcp/gsttcp-marshal.list:
+	Fixed the stupid marshal definition.
+
+2004-07-20  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_init), (gst_multifdsink_add),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_queue_buffer), (gst_multifdsink_chain),
+	(gst_multifdsink_set_property), (gst_multifdsink_get_property),
+	(gst_multifdsink_init_send):
+	* gst/tcp/gstmultifdsink.h:
+	Added more stats, added timeout for a client, fixed some typos
+	and added some comments.
+
+2004-07-20  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_class_init),
+	(gst_multifdsink_add), (gst_multifdsink_get_stats),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_write):
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcp-marshal.list:
+	Added get_stats method that returns a GValueArray of
+	stats values.
+
+2004-07-19  Benjamin Otte  <otte@gnome.org>
+
+	* ext/ladspa/gstladspa.c: (gst_ladspa_base_init):
+	  make sure longname, description and author are valid UTF-8
+
+2004-07-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_change_state),
+	(gst_ximagesink_set_property):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_change_state),
+	(gst_xvimagesink_set_property):
+	  make sure SYNCHRONOUS is respected after getting the X context
+
+2004-07-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_handle_src_event),
+	(gst_matroska_demux_parse_blockgroup):
+	* gst/matroska/matroska-ids.h:
+	  add BlockReference tag and ignore it to clear out log.
+	  ignore NAVIGATION events to clear out log.
+
+2004-07-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_class_init),
+	(gst_matroska_demux_add_stream):
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_class_init):
+	  add debug categories
+
+2004-07-16  Wim Taymans  <wim@fluendo.com>
+
+	* ext/libpng/Makefile.am:
+	* ext/libpng/gstpng.c: (plugin_init):
+	* ext/libpng/gstpngdec.c: (user_error_fn), (user_warning_fn),
+	(gst_pngdec_get_type), (gst_pngdec_base_init),
+	(gst_pngdec_class_init), (gst_pngdec_sinklink), (gst_pngdec_init),
+	(gst_pngdec_src_getcaps), (user_read_data), (gst_pngdec_chain):
+	* ext/libpng/gstpngdec.h:
+	Added png decoder.
+
+2004-07-16  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xerror),
+	(gst_ximagesink_check_xshm_calls), (gst_ximagesink_ximage_new),
+	(gst_ximagesink_ximage_destroy), (gst_ximagesink_sink_link),
+	(gst_ximagesink_chain), (gst_ximagesink_buffer_free),
+	(gst_ximagesink_buffer_alloc):
+	* sys/ximage/ximagesink.h:
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_new), (gst_xvimagesink_xvimage_destroy),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_free),
+	(gst_xvimagesink_buffer_alloc):
+	* sys/xvimage/xvimagesink.h: Getting the 2 video sinks synchronized
+	again. Using internal data pointer of the x(v)image to store image's
+	data to be coherent with the buffer alloc mechanism. Investigated the
+	image destruction code to be sure that everything gets freed correctly.
+
+2004-07-16  Wim Taymans  <wim@fluendo.com>
+
+	* gst-libs/gst/riff/riff-read.c:
+	(gst_riff_read_strf_vids_with_data),
+	(gst_riff_read_strf_auds_with_data):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_add_stream), (gst_avi_demux_stream_header):
+	Make sure we don't create 0 sized subbuffers in riff-read.
+	Signal the no more pads signal after reading the avi header.
+
+2004-07-16  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_is_dynamic),
+	(gst_decode_bin_factory_filter), (compare_ranks), (print_feature),
+	(gst_decode_bin_init), (gst_decode_bin_dispose),
+	(find_compatibles), (close_pad_link), (try_to_link_1), (new_pad),
+	(no_more_pads), (close_link), (type_found),
+	(gst_decode_bin_set_property), (gst_decode_bin_get_property),
+	(gst_decode_bin_change_state), (plugin_init):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_get_type),
+	(gst_play_base_bin_class_init), (gst_play_base_bin_init),
+	(gst_play_base_bin_dispose), (queue_overrun),
+	(gen_preroll_element), (remove_prerolls), (unknown_type),
+	(no_more_pads), (new_stream), (setup_source),
+	(gst_play_base_bin_set_property), (gst_play_base_bin_get_property),
+	(play_base_eos), (gst_play_base_bin_change_state),
+	(gst_play_base_bin_add_element),
+	(gst_play_base_bin_remove_element),
+	(gst_play_base_bin_mute_stream), (gst_play_base_bin_link_stream),
+	(gst_play_base_bin_unlink_stream),
+	(gst_play_base_bin_get_streaminfo):
+	* gst/playback/gstplaybasebin.h:
+	Better error recovery. Added configurable preroll queue size. Faster
+	detection of no-more-pads.
+
+2004-07-16  Wim Taymans  <wim@fluendo.com>
+
+	* gst-libs/gst/video/video.h:
+	Added 32 bits RGBA. Not sure if we should use another mime-type
+	for alpha rgb. Currently the presence of the alpha_mask property
+	signals an alpha channel.
+
+2004-07-16  Wim Taymans  <wim@fluendo.com>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support):
+	FPS seems to be 0.0 to MAX everywhere else.
+
+2004-07-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data):
+	  mp42/mp43 (no caps) exist too.
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_video_caps):
+	  Set pixel_width/height; we've got them in-caps.
+	* gst/typefind/gsttypefindfunctions.c: (plugin_init):
+	* gst/wavparse/gstwavparse.c: (plugin_init):
+	  Both are valid primary.
+	* sys/oss/gstossmixer.c:
+	  Remove i18n hack and enable translations.
+
+2004-07-15  Benjamin Otte  <otte@gnome.org>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_new), (gst_xvimagesink_xvimage_destroy):
+	  fix for non-shm xv. Original patch by Tim Ringenbach (fixes #147248)
+
+2004-07-15  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_open_audio),
+	(gst_alsa_sw_params_dump), (gst_alsa_hw_params_dump),
+	(gst_alsa_close_audio):
+	  disable some of the debugging code for now. Writing debugging to a
+	  buffer is broken in current alsalib releases.
+
+2004-07-12  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_alloc_buffer):
+	  use bufferpools
+
+2004-07-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/theora/theoradec.c: (gst_theora_dec_class_init),
+	(theora_dec_src_query), (theora_dec_event):
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init):
+	  add debugging categories.  Remove \n's.
+
+2004-07-13  Johan Dahlin  <johan@gnome.org>
+
+	* gst/playback/gstplaybin.c (gst_play_bin_set_property)
+	(gst_play_bin_get_property): Impl.
+
+2004-07-13  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_seek_before):
+	When trying to find the stream length, seek back N pages
+	instead of just one, where N is the number of streams in
+	the current chain.
+
+2004-07-13  Wim Taymans  <wim@fluendo.com>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_audio_caps_with_data),
+	(gst_riff_create_audio_caps),
+	(gst_riff_create_audio_template_caps):
+	* gst-libs/gst/riff/riff-media.h:
+	* gst-libs/gst/riff/riff-read.c:
+	(gst_riff_read_strf_vids_with_data),
+	(gst_riff_read_strf_auds_with_data), (gst_riff_read_strf_auds):
+	* gst-libs/gst/riff/riff-read.h:
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_query),
+	(gst_avi_demux_add_stream):
+	Set codec_data on caps for avidemuxer.
+
+2004-07-12  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Fix test for Objective C
+
+2004-07-12  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_get_capslist),
+	(gst_gdk_pixbuf_chain):
+	  Add svg and pcx to template caps, and ensure that getcaps returns a
+	  subset of the template caps.
+	  Copy each row manually for output, as gdkpixbuf may pad the
+	  rowstride to a 32-bit word boundary.
+
+2004-07-12  Wim Taymans  <wim@fluendo.com>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_audio_caps),
+	(gst_riff_create_video_template_caps):
+	Fix the template caps to include some more media types.
+
+2004-07-12  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_factory_filter),
+	(compare_ranks), (print_feature), (gst_decode_bin_init),
+	(gst_decode_bin_dispose), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (new_pad), (close_link), (type_found),
+	(gst_decode_bin_set_property), (gst_decode_bin_get_property),
+	(gst_decode_bin_change_state), (plugin_init):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_get_type),
+	(gst_play_base_bin_class_init), (gst_play_base_bin_init),
+	(gst_play_base_bin_dispose), (queue_overrun),
+	(gen_preroll_element), (remove_prerolls), (no_more_pads),
+	(new_stream), (setup_source), (gst_play_base_bin_set_property),
+	(gst_play_base_bin_get_property), (play_base_eos),
+	(gst_play_base_bin_change_state), (gst_play_base_bin_add_element),
+	(gst_play_base_bin_remove_element),
+	(gst_play_base_bin_mute_stream), (gst_play_base_bin_link_stream),
+	(gst_play_base_bin_unlink_stream),
+	(gst_play_base_bin_get_streaminfo):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gst_play_bin_get_type),
+	(gst_play_bin_class_init), (gst_play_bin_init),
+	(gst_play_bin_dispose), (gst_play_bin_set_property),
+	(gst_play_bin_get_property), (gen_video_element),
+	(gen_audio_element), (remove_sinks), (setup_sinks),
+	(gst_play_bin_change_state), (gst_play_bin_get_event_masks),
+	(gst_play_bin_send_event), (gst_play_bin_get_formats),
+	(gst_play_bin_convert), (gst_play_bin_get_query_types),
+	(gst_play_bin_query), (plugin_init):
+	* gst/playback/test4.c: (main):
+	More fixes on reusing of the element.
+
+2004-07-11  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstmad.c: (normal_seek):
+	  allow seeking for other methods than just SET
+
+2004-07-11  Andy Wingo  <wingo@pobox.com>
+
+	* gst/audioconvert/gstaudioconvert.c (gst_audio_convert_link): For
+	float, "any" caps -> buffer_frames=[0,MAX].
+
+	* gst/interleave/interleave.c (interleave_getcaps): Seems the core
+	doesn't intersect our caps with the template any more. Do it
+	ourselves.
+	(interleave_buffered_loop): Use g_newa instead of malloc/free.
+
+2004-07-09  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_factory_filter),
+	(compare_ranks), (print_feature), (gst_decode_bin_init),
+	(gst_decode_bin_dispose), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (new_pad), (close_link), (type_found),
+	(gst_decode_bin_set_property), (gst_decode_bin_get_property),
+	(gst_decode_bin_change_state), (plugin_init):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_get_type),
+	(gst_play_base_bin_class_init), (gst_play_base_bin_init),
+	(gst_play_base_bin_dispose), (queue_overrun),
+	(gen_preroll_element), (remove_prerolls), (no_more_pads),
+	(new_stream), (setup_source), (gst_play_base_bin_set_property),
+	(gst_play_base_bin_get_property), (play_base_eos),
+	(gst_play_base_bin_change_state), (gst_play_base_bin_add_element),
+	(gst_play_base_bin_remove_element),
+	(gst_play_base_bin_mute_stream), (gst_play_base_bin_link_stream),
+	(gst_play_base_bin_unlink_stream),
+	(gst_play_base_bin_get_streaminfo):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gst_play_bin_get_type),
+	(gst_play_bin_class_init), (gst_play_bin_init),
+	(gst_play_bin_dispose), (gst_play_bin_set_property),
+	(gst_play_bin_get_property), (gen_video_element),
+	(gen_audio_element), (remove_sinks), (setup_sinks),
+	(gst_play_bin_change_state), (gst_play_bin_get_event_masks),
+	(gst_play_bin_send_event), (gst_play_bin_get_formats),
+	(gst_play_bin_convert), (gst_play_bin_get_query_types),
+	(gst_play_bin_query), (plugin_init):
+	* gst/playback/test4.c: (main):
+	Work on object reuse and seeking.
+
+2004-07-09  Wim Taymans  <wim@fluendo.com>
+
+	* examples/seeking/seek.c: (iterate):
+	Don't consume all CPU in the idle loop.
+
+2004-07-09  Wim Taymans  <wim@fluendo.com>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_new_output_pad),
+	(gst_mpeg_demux_parse_packet), (gst_mpeg_demux_process_private):
+	Add pad to element *after* setting the pad functions so that
+	the scheduler can use the correct ones.
+
+2004-07-09  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (theora_dec_from_granulepos),
+	(theora_dec_src_query), (theora_dec_src_event), (theora_dec_chain):
+	Sync to keyframe after seek
+
+2004-07-09  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state):
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event),
+	(gst_alsa_sink_loop), (gst_alsa_sink_change_state):
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_change_state):
+	* ext/libvisual/visual.c: (gst_visual_change_state):
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_change_state):
+	* ext/theora/theoradec.c: (theora_dec_change_state):
+	* ext/theora/theoraenc.c: (theora_enc_change_state):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_change_state):
+	* gst-libs/gst/navigation/navigation.c:
+	* gst/adder/gstadder.c: (gst_adder_change_state):
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_chain),
+	(gst_audio_convert_get_buffer):
+	* gst/multipart/multipartdemux.c:
+	(gst_multipart_demux_change_state):
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_change_state):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_change_state):
+	* gst/playback/gstplaybin.c: (gst_play_bin_change_state):
+	* gst/videoscale/gstvideoscale.c:
+	(gst_videoscale_handle_src_event):
+	* gst/volume/gstvolume.c: (volume_chain_int16):
+	  don't assert in state change, this should be done by the base
+	  GstElement class.
+	  various debugging fixes.
+
+2004-07-08  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* configure.ac:
+	* gst-libs/gst/play/play.c: (gst_play_pipeline_setup),
+	(gst_play_dispose), (gst_play_set_location),
+	(gst_play_set_data_src), (gst_play_set_video_sink),
+	(gst_play_set_audio_sink), (gst_play_set_visualization),
+	(gst_play_connect_visualization), (gst_play_get_sink_element),
+	(gst_play_get_all_by_interface):
+	* gst-libs/gst/play/play.h:
+	  add new method to get elements implementing an interface.
+	  add various error logging
+
+2004-07-08  Wim Taymans  <wim@fluendo.com>
+
+	* examples/seeking/seek.c: (make_dv_pipeline), (make_avi_pipeline),
+	(make_mpeg_pipeline), (make_mpegnt_pipeline),
+	(make_playerbin_pipeline), (query_durations_elems),
+	(query_durations_pads), (query_positions_elems),
+	(query_positions_pads), (update_scale), (iterate), (stop_seek),
+	(main):
+	Added playbin seeking example.
+
+2004-07-08  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* gst-libs/gst/play/play.c: (gst_play_set_location),
+	(gst_play_set_data_src), (gst_play_set_video_sink),
+	(gst_play_set_audio_sink), (gst_play_set_visualization),
+	(gst_play_connect_visualization), (gst_play_get_framerate):
+	  use a macro to look up elements from hash table
+
+2004-07-08  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* gst-libs/gst/play/play.c: (gst_play_pipeline_setup),
+	(gst_play_get_length_callback), (gst_play_set_location),
+	(gst_play_seek_to_time), (gst_play_set_data_src),
+	(gst_play_set_video_sink), (gst_play_set_audio_sink),
+	(gst_play_set_visualization), (gst_play_connect_visualization),
+	(gst_play_get_sink_element):
+	- add debugging info
+	- fix looking up sink elements by iterating over complete caps
+	- put everything except for source and autoplugger in a complete bin
+
+2004-07-08  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_drain_audio):
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_flush_one_pad),
+	(gst_alsa_sink_check_event), (gst_alsa_sink_mmap),
+	(gst_alsa_sink_write), (gst_alsa_sink_loop):
+	* ext/alsa/gstalsasink.h:
+	- add debugging info
+	- clean up schizophrenia of data/buffer/event
+	- fix double event unref error
+
+2004-07-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/Makefile.am:
+	Add headers to noinst
+
+2004-07-08  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* tools/gst-launch-ext-m.m:
+	* tools/gst-launch-ext.1.in:
+	  convert to the third millenium
+
+2004-07-07  David Schleef  <ds@schleef.org>
+
+	* sys/dxr3/Makefile.am: noinst_SOURCES should be nodist_SOURCES
+
+2004-07-07  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/Makefile.am:
+	* gst/playback/README:
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_factory_filter),
+	(compare_ranks), (print_feature), (gst_decode_bin_init),
+	(gst_decode_bin_dispose), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (new_pad), (close_link), (type_found),
+	(gst_decode_bin_set_property), (gst_decode_bin_get_property),
+	(plugin_init):
+	* gst/playback/gstplaybasebin.c: (gst_play_base_bin_get_type),
+	(gst_play_base_bin_class_init), (gst_play_base_bin_init),
+	(gst_play_base_bin_dispose), (rebuild_pipeline), (queue_overrun),
+	(gen_preroll_element), (no_more_pads), (new_stream),
+	(setup_source), (gst_play_base_bin_set_property),
+	(gst_play_base_bin_get_property), (gst_play_base_bin_change_state),
+	(gst_play_base_bin_add_element),
+	(gst_play_base_bin_remove_element),
+	(gst_play_base_bin_mute_stream), (gst_play_base_bin_link_stream),
+	(gst_play_base_bin_unlink_stream),
+	(gst_play_base_bin_get_streaminfo):
+	* gst/playback/gstplaybasebin.h:
+	* gst/playback/gstplaybin.c: (gst_play_bin_get_type),
+	(gst_play_bin_class_init), (gst_play_bin_init),
+	(gst_play_bin_dispose), (gst_play_bin_set_property),
+	(gst_play_bin_get_property), (gen_video_element),
+	(gen_audio_element), (setup_sinks), (gst_play_bin_change_state),
+	(gst_play_bin_get_event_masks), (gst_play_bin_send_event),
+	(gst_play_bin_get_formats), (gst_play_bin_convert),
+	(gst_play_bin_get_query_types), (gst_play_bin_query),
+	(plugin_init):
+	* gst/playback/gststreaminfo.c: (gst_stream_type_get_type),
+	(gst_stream_info_get_type), (gst_stream_info_class_init),
+	(gst_stream_info_init), (gst_stream_info_new),
+	(gst_stream_info_dispose), (gst_stream_info_set_property),
+	(gst_stream_info_get_property):
+	* gst/playback/gststreaminfo.h:
+	* gst/playback/test.c: (gen_video_element), (gen_audio_element),
+	(main):
+	* gst/playback/test2.c: (main):
+	* gst/playback/test3.c: (update_scale), (main):
+	More playbin fixes. Added README. Do better element filtering.
+	Added base class to preroll media. Added test apps.
+
+2004-07-07  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_flush_decoder):
+	* ext/mpeg2dec/gstmpeg2dec.h:
+	  various debugging improvements.  Reset stream to next picture
+	  instead of sequence header, otherwise seeks cannot work.
+
+2004-07-07  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videobox/gstvideobox.c: (gst_video_box_fill_get_type),
+	(gst_video_box_class_init), (gst_video_box_set_property),
+	(gst_video_box_i420), (gst_video_box_ayuv), (gst_video_box_chain):
+	Use pad_alloc where possible.
+
+2004-07-07  Wim Taymans  <wim@fluendo.com>
+
+	* sys/oss/gstosselement.c: (gst_osselement_reset),
+	(gst_osselement_parse_caps):
+	* sys/oss/gstosselement.h:
+	* sys/oss/gstosssrc.c: (gst_osssrc_get):
+	Fix offset on osssrc.
+
+2004-07-07  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theora.c: (plugin_init):
+	* ext/theora/theoradec.c: (theora_dec_from_granulepos),
+	(theora_dec_src_query), (theora_dec_chain):
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init),
+	(theora_enc_sink_link), (theora_buffer_from_packet),
+	(theora_push_packet), (theora_enc_chain):
+	Fix theora granulepos calculation.
+	Fix overflow in duration/position calculation.
+	Bump rank to PRIMARY for theoradec.
+	Use granulepos of last packet to calculate position.
+	Set keyframe flag on buffers when needed.
+
+2004-07-06  David Schleef  <ds@schleef.org>
+
+	* gst/playback/Makefile.am: 'test' in bin_PROGRAMS?  Are you
+	serious?  (Fixed, obviously.)
+
+2004-07-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/cs.po:
+	  added Czech translation (Miloslav Trmac)
+
+2004-07-05  Wim Taymans  <wim@fluendo.com>
+
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_factory_filter),
+	(compare_ranks), (gst_decode_bin_init), (gst_decode_bin_dispose),
+	(find_compatibles), (close_pad_link), (try_to_link_1), (new_pad),
+	(close_link), (type_found), (gst_decode_bin_set_property),
+	(gst_decode_bin_get_property), (gst_decode_bin_get_event_masks),
+	(gst_decode_bin_send_event), (gst_decode_bin_get_formats),
+	(gst_decode_bin_convert), (gst_decode_bin_get_query_types),
+	(gst_decode_bin_query), (plugin_init):
+	* gst/playback/gstplaybin.c: (gst_play_bin_get_type),
+	(gst_play_bin_class_init), (gst_play_bin_init),
+	(gst_play_bin_dispose), (rebuild_pipeline), (get_audio_element),
+	(get_video_element), (new_pad), (setup_source),
+	(gst_play_bin_set_property), (gst_play_bin_get_property),
+	(gst_play_bin_change_state), (gst_play_bin_add_element),
+	(gst_play_bin_remove_element), (gst_play_bin_get_event_masks),
+	(gst_play_bin_send_event), (gst_play_bin_get_formats),
+	(gst_play_bin_convert), (gst_play_bin_get_query_types),
+	(gst_play_bin_query), (gst_play_bin_get_clock), (plugin_init):
+	* gst/playback/test.c: (main):
+	More fixes, cleaned up playbin, make it use decodebin. Added
+	threaded property to playbin.
+
+2004-07-05  Wim Taymans  <wim@fluendo.com>
+
+	* configure.ac:
+	* gst/playback/Makefile.am:
+	* gst/playback/decodetest.c: (main):
+	* gst/playback/gstdecodebin.c: (gst_decode_bin_get_type),
+	(gst_decode_bin_class_init), (gst_decode_bin_factory_filter),
+	(compare_ranks), (gst_decode_bin_init), (gst_decode_bin_dispose),
+	(find_compatibles), (close_pad_link), (try_to_link_1), (new_pad),
+	(close_link), (type_found), (gst_decode_bin_set_property),
+	(gst_decode_bin_get_property), (gst_decode_bin_change_state),
+	(gst_decode_bin_get_event_masks), (gst_decode_bin_send_event),
+	(gst_decode_bin_get_formats), (gst_decode_bin_convert),
+	(gst_decode_bin_get_query_types), (gst_decode_bin_query),
+	(plugin_init):
+	* gst/playback/gstplaybin.c: (gst_play_bin_get_type),
+	(gst_play_bin_class_init), (gst_play_bin_init),
+	(gst_play_bin_dispose), (gen_default_output), (rebuild_pipeline),
+	(collect_sink_pads), (find_compatibles), (close_pad_link),
+	(try_to_link_1), (new_pad), (close_link), (type_found),
+	(setup_source), (gst_play_bin_set_property),
+	(gst_play_bin_get_property), (gst_play_bin_factory_filter),
+	(compare_ranks), (gst_play_bin_collect_factories),
+	(gst_play_bin_change_state), (gst_play_bin_add_element),
+	(gst_play_bin_remove_element), (gst_play_bin_get_event_masks),
+	(gst_play_bin_send_event), (gst_play_bin_get_formats),
+	(gst_play_bin_convert), (gst_play_bin_get_query_types),
+	(gst_play_bin_query), (gst_play_bin_get_clock), (plugin_init):
+	* gst/playback/test.c: (main):
+	Added some playback helper elements and some test apps, very alpha
+	still.
+
+2004-07-04  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_xrun_recovery):
+	  only restart audio when we indeed have an xrun to fix repeated
+	  xruns. Fix suggested by Giuliano Pochini.
+
+2004-07-03  David Schleef  <ds@schleef.org>
+
+	* ext/alsa/gstalsaplugin.c: (gst_alsa_error_wrapper): Disable
+	call to gst_debug_log() if debugging is disabled (bug #145118)
+
+2004-07-03  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_xrun_recovery):
+	  use our own functions for restarting the alsa device.
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  I should apply patches myself - use MIN for the third argument, not
+	  the second, this fixes seeking
+
+2004-07-02  David Schleef  <ds@schleef.org>
+
+	* ext/flac/gstflacdec.c: (gst_flacdec_class_init),
+	(gst_flacdec_write):  Actually, GST_PAD_CAPS() has nothing to
+	do with the logic.
+
+2004-07-02  David Schleef  <ds@schleef.org>
+
+	* ext/flac/gstflacdec.c: (gst_flacdec_write):  Set duration on
+	output buffers.  Fix logic mistake.  (bug #144866)
+
+2004-07-02  David Schleef  <ds@schleef.org>
+
+	* gst-libs/gst/xoverlay/Makefile.am: xoverlay no longer depends
+	on X.  (bug #144753)
+
+2004-07-02  David Schleef  <ds@schleef.org>
+
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_setup),
+	(gst_wavenc_stop_file): Switch to GST_WRITE_UINT32_LE macros
+	(bug #144624)
+	* sys/oss/gstosselement.c: (gst_osselement_probe_caps),
+	(gst_osselement_rate_probe_check): Add another workaround for
+	buggy drivers (bug #145336)
+
+2004-07-02  David Schleef  <ds@schleef.org>
+
+	* gst/tcp/gstmultifdsink.c: (gst_multifdsink_handle_client_write):
+	Most systems don't have MSG_NOSIGNAL.
+
+2004-07-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/tuner/Makefile.am:
+	  (hopefully) fix both install and dist and make error message useful.
+	  needs testing across automakes.
+
+2004-07-02  Benjamin Otte  <otte@gnome.org>
+
+	* ext/ogg/gstogg.c: (plugin_init):
+	  we require bytestream now
+	* ext/ogg/gstoggdemux.c:
+	  huge diff to implement chain setup in a fast and generic way. This
+	  improves tag reading and startup of huge files (read: Theora videos)
+	  quite a bit. It probably contains bugs, too, so please test.
+	  Seeking is not improved to the fast method.
+
+2004-06-29  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	* ext/ogg/gstoggmux.c:
+	Fix memleak in oggdemux when running unconnected pads.
+	doc update in mux, start working on keyframe mode.
+
+2004-06-29  Benjamin Otte  <otte@gnome.org>
+
+	* sys/oss/gstosssink.c:
+	* sys/oss/gstosssrc.c:
+	  advertise correct template caps - we indeed do non-native endianness
+	  and 8bit audio has no endianness
+	* sys/ximage/ximagesink.c: (gst_ximagesink_getcaps):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_getcaps):
+	  avoid (wrong) duplications in getcaps function and return
+	  template caps
+
+2004-06-29  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_recover_policy_get_type),
+	(gst_multifdsink_class_init), (gst_multifdsink_add),
+	(gst_multifdsink_remove), (gst_multifdsink_clear),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_client_queue_data),
+	(gst_multifdsink_client_queue_caps),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_thread),
+	(gst_multifdsink_init_send), (gst_multifdsink_close):
+	Fix wrong GList iteration that could crash the server when
+	more then 2 clients disconnect at the same time. Read all the
+	pending commands in one batch to recover from command storms under
+	very heavy load.
+
+2004-06-28  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videomixer/videomixer.c: (gst_videomixer_pad_get_type),
+	(gst_videomixer_pad_class_init), (gst_videomixer_pad_get_property),
+	(gst_videomixer_pad_set_property),
+	(gst_videomixer_pad_sinkconnect), (gst_videomixer_pad_init),
+	(gst_video_mixer_background_get_type), (gst_videomixer_get_type),
+	(gst_videomixer_class_init), (gst_videomixer_init),
+	(gst_videomixer_request_new_pad), (gst_videomixer_blend_ayuv_i420),
+	(pad_zorder_compare), (gst_videomixer_sort_pads),
+	(gst_videomixer_fill_checker), (gst_videomixer_fill_color),
+	(gst_videomixer_fill_queues), (gst_videomixer_blend_buffers),
+	(gst_videomixer_update_queues), (gst_videomixer_loop),
+	(plugin_init):
+	Avoid divide by zero, choose masterpad as the pad with the highest
+	framerate.
+
+2004-06-27  Julien Moutte  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_decorate),
+	(gst_ximagesink_xwindow_new):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xwindow_decorate),
+	(gst_xvimagesink_xwindow_new): I prefer locking the mutex in the
+	function directly. We might want to call it from somewhere else one day.
+
+2004-06-27  Julien Moutte  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_decorate),
+	(gst_ximagesink_xwindow_new):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xwindow_decorate),
+	(gst_xvimagesink_xwindow_new): Trying to fix the random behaviour of
+	window decorations.
+
+2004-06-27  Wim Taymans  <wim@fluendo.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_class_init), (gst_dvdec_init),
+	(gst_dvdec_video_getcaps), (gst_dvdec_video_link),
+	(gst_dvdec_push), (gst_dvdec_loop), (gst_dvdec_change_state),
+	(gst_dvdec_set_property), (gst_dvdec_get_property):
+	* ext/dv/gstdvdec.h:
+	Implement drop_factor property to lower the framerate with
+	a factor.
+
+2004-06-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/tuner/Makefile.am:
+	  unbreak Company's fix that didn't install the -enum.h files
+
+2004-06-27  Wim Taymans  <wim@fluendo.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_push), (gst_dvdec_loop),
+	(gst_dvdec_change_state):
+	* ext/dv/gstdvdec.h:
+	Fix timestamp, duration and offset of the buffers.
+
+2004-06-27  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gstmultifdsink.c: (gst_recover_policy_get_type),
+	(gst_multifdsink_class_init), (gst_multifdsink_add),
+	(gst_multifdsink_remove), (gst_multifdsink_clear),
+	(gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_client_queue_data),
+	(gst_multifdsink_client_queue_caps),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_thread),
+	(gst_multifdsink_init_send), (gst_multifdsink_close):
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcpserversink.c:
+	(gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_handle_select), (gst_tcpserversink_close):
+	More multifdsink fixes, more recovery policy fixes.
+	Removed stupid g_print
+
+2004-06-26  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/Makefile.am:
+	* gst/tcp/gstmultifdsink.c: (gst_recover_policy_get_type),
+	(gst_multifdsink_get_type), (gst_multifdsink_base_init),
+	(gst_multifdsink_class_init), (gst_multifdsink_init),
+	(gst_multifdsink_debug_fdset), (gst_multifdsink_client_remove),
+	(gst_multifdsink_handle_client_read),
+	(gst_multifdsink_client_queue_data),
+	(gst_multifdsink_client_queue_caps),
+	(gst_multifdsink_client_queue_buffer),
+	(gst_multifdsink_handle_client_write),
+	(gst_multifdsink_recover_client), (gst_multifdsink_queue_buffer),
+	(gst_multifdsink_handle_clients), (gst_multifdsink_thread),
+	(gst_multifdsink_chain), (gst_multifdsink_set_property),
+	(gst_multifdsink_get_property), (gst_multifdsink_init_send),
+	(gst_multifdsink_close), (gst_multifdsink_change_state):
+	* gst/tcp/gstmultifdsink.h:
+	* gst/tcp/gsttcpplugin.c: (plugin_init):
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_get_type),
+	(gst_tcpserversink_class_init), (gst_tcpserversink_init),
+	(gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_handle_select),
+	(gst_tcpserversink_set_property), (gst_tcpserversink_get_property),
+	(gst_tcpserversink_init_send), (gst_tcpserversink_close):
+	* gst/tcp/gsttcpserversink.h:
+	Added multifdsink, made tcpserversink a subclass of fdsink, removed
+	one of the locks, added recovery policy to multifdsink.
+
+2004-06-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videorate/gstvideorate.c: (gst_videorate_chain):
+	  fix decision for when getting frames with same timestamp
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_class_init), (gst_v4lsrc_init),
+	(gst_v4lsrc_get), (gst_v4lsrc_set_property),
+	(gst_v4lsrc_get_property):
+	* sys/v4l/gstv4lsrc.h:
+	  add latency offset property
+
+2004-06-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videorate/gstvideorate.c: (gst_videorate_chain),
+	(plugin_init):
+	  fix debugging. add category.
+
+2004-06-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_get):
+          fix wrong offsets
+
+2004-06-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_init),
+	(gst_alsa_src_get_time), (gst_alsa_src_loop),
+	(gst_alsa_src_change_state):
+	  return a time that is in sync with the element's processing
+
+2004-06-25  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_class_init),
+	(gst_tcpserversink_init), (gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_client_remove),
+	(gst_tcpserversink_handle_client_read),
+	(gst_tcpserversink_client_queue_data),
+	(gst_tcpserversink_client_queue_caps),
+	(gst_tcpserversink_client_queue_buffer),
+	(gst_tcpserversink_handle_client_write),
+	(gst_tcpserversink_queue_buffer),
+	(gst_tcpserversink_handle_clients), (gst_tcpserversink_thread),
+	(gst_tcpserversink_chain), (gst_tcpserversink_set_property),
+	(gst_tcpserversink_get_property), (gst_tcpserversink_init_send),
+	(gst_tcpserversink_close):
+	* gst/tcp/gsttcpserversink.h:
+	Serversink rewrite. Really do non blocking writes to clients and
+	maintain an internal queue to handle slower clients while not
+	disturbing fast clients.
+
+2004-06-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_get):
+	  better debug, don't override OFFSET and OFFSET_END
+
+2004-06-25  Iain <iain@prettypeople.org>
+
+	* gst-libs/gst/media-info/media-info-priv.c (gmi_set_mime): Add
+	name=source for the wavparse pipeline.
+
+2004-06-24  Johan Dahlin  <johan@gnome.org>
+
+	* ext/theora/theoraenc.c (theora_enc_chain): Call
+	gst_pad_try_set_caps instead of gst_pad_set_explicit_caps so the
+	streamheader caps are set correctly.
+
+2004-06-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisenc.c: (raw_caps_factory),
+	(gst_vorbisenc_setup), (gst_vorbisenc_set_property):
+	  respect minimum bitrate; same could be done for max bitrate
+
+2004-06-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisenc.c: (raw_caps_factory),
+	(gst_vorbisenc_setup):
+	  fix sample rate range
+
+2004-06-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/oggvorbisenc.c: (gst_oggvorbisenc_class_init),
+	(gst_oggvorbisenc_setup):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_class_init),
+	(gst_vorbisenc_setup):
+	  resolve ambiguities in code and description
+
+2004-06-24  Wim Taymans  <wim@fluendo.com>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_start), (gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_init),
+	(gst_alsa_src_update_avail), (gst_alsa_src_loop):
+	Use alsa trigger_tstamp to get the timestamp of the first
+	sample in the buffer for more precise sync. Some cleanups.
+
+2004-06-24  Wim Taymans  <wim@fluendo.com>
+
+	* gst/audiorate/gstaudiorate.c: (gst_audiorate_link),
+	(gst_audiorate_init), (gst_audiorate_chain),
+	(gst_audiorate_set_property), (gst_audiorate_get_property):
+	* gst/videorate/gstvideorate.c: (gst_videorate_class_init),
+	(gst_videorate_chain):
+	Added some logging, fixed an overflow bug in videorate.
+
+2004-06-24  Benjamin Otte  <otte@gnome.org>
+
+	* ext/kio/Makefile.am:
+	  fix for builddir != srcdir and distcheck
+
+2004-06-24  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/tuner/Makefile.am:
+	* gst/tcp/Makefile.am:
+	* sys/dxr3/Makefile.am:
+	  don't include -enumtypes.[ch] or -marshal.[ch] files in the disted
+	  tarball.
+	  Also add all *.list files that were missing.
+	* Makefile.am:
+	  add a distcheck hook to ensure the above doesn't happen again.
+
+2004-06-23  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* ext/Makefile.am: s/DTS_DIR=dvdread/DTS_DIR=dts/
+
+2004-06-23  Colin Walters  <walters@redhat.com>
+
+	* m4/Makefile.am: Distribute gst-fionread.m4.
+
+2004-06-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: back to dev
+
+2004-06-23  Wim Taymans  <wim@fluendo.com>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state), (gst_alsa_start),
+	(gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event),
+	(gst_alsa_sink_loop), (gst_alsa_sink_get_time):
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_init),
+	(gst_alsa_src_get_time), (gst_alsa_src_update_avail),
+	(gst_alsa_src_loop):
+	Add clock to alsasrc. Take new capture timestamp when
+	restarting after an overrun. Split up some functions between
+	alsasrc and alsasink.
+
+=== release 0.8.2 ===
+
+2004-06-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_init), (gst_alsa_dispose),
+	(gst_alsa_change_state), (gst_alsa_update_avail),
+	(gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  merge back changes from release
+
+2004-06-23  Wim Taymans  <wim@fluendo.com>
+
+	* gst/audiorate/gstaudiorate.c: (gst_audiorate_class_init),
+	(gst_audiorate_init), (gst_audiorate_chain),
+	(gst_audiorate_set_property), (gst_audiorate_get_property):
+	Implement sample dropping and notify
+
+2004-06-22  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init),
+	(theora_enc_sink_link), (theora_buffer_from_packet),
+	(theora_push_packet), (theora_enc_chain):
+	Some cleanups, make sure the timestamps are correct.
+
+2004-06-22  Wim Taymans  <wim@fluendo.com>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_time), (gst_alsa_clock_update),
+	(gst_alsa_change_state), (gst_alsa_update_avail),
+	(gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_loop):
+	Cleanups, take queued samples into account when reporting
+	the time.
+
+2004-06-22  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videorate/gstvideorate.c: (gst_videorate_class_init),
+	(gst_videorate_init):
+	Initialize the property as well.
+
+2004-06-22  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videorate/gstvideorate.c: (gst_videorate_class_init),
+	(gst_videorate_init), (gst_videorate_chain),
+	(gst_videorate_set_property), (gst_videorate_get_property):
+	Add property to make videorate silent.
+	Add property to prefer new frames over old ones.
+
+2004-06-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* sys/osxvideo/Makefile.am:
+        Workaround so that the osxvideo .so file gets linked with the
+        Cocoa, OpenGL and QuickTime frameworks
+
+2004-06-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* sys/osxaudio/Makefile.am:
+        Workaround so that the osxaudio .so file gets linked with the
+        CoreAudio framework
+
+2004-06-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* configure.ac:
+	Whoops, my fault...fixed build issues
+
+2004-06-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* configure.ac:
+        Add objective-c support if running in Darwin/Mac OS X
+	* sys/Makefile.am:
+        * sys/osxvideo:
+        * sys/osxvideo/Makefile.am:
+        * sys/osxvideo/osxvideosink.h:
+        * sys/osxvideo/osxvideosink.m:
+        * sys/osxvideo/cocoawindow.h:
+        * sys/osxvideo/cocoawindow.m:
+        Add osxvideosink, a cocoa-based osx video sink
+
+
+2004-06-19  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/dvdnav/gst-dvd:
+	Grab the gconf key from the right spot
+	* gst/debug/gstnavseek.c: (gst_navseek_init),
+	(gst_navseek_segseek), (gst_navseek_handle_src_event),
+	(gst_navseek_chain):
+	* gst/debug/gstnavseek.h:
+	  Add 's', 'e' and 'l' keypresses to navseek to define the start,end
+	  and loop parameters of a segment seek.
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_init),
+	(gst_videotestsrc_get_event_masks),
+	(gst_videotestsrc_handle_src_event), (gst_videotestsrc_get):
+	* gst/videotestsrc/gstvideotestsrc.h:
+	  Add seeking support to videotestsrc
+	  Initialise the timestamp_offset variable.
+
+2004-06-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/sidplay/gstsiddec.cc:
+	Fix negotiation and set correct end offset.
+
+2004-06-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: branch and prerelease
+
+2004-06-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_init),
+	(gst_tcpclientsrc_getcaps), (gst_tcpclientsrc_get),
+	(gst_tcpclientsrc_init_receive):
+	* gst/tcp/gsttcpclientsrc.h:
+          read caps when connecting to server for GDP so we set them correctly
+
+2004-06-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videorate/gstvideorate.c: (gst_videorate_chain):
+	  notify drops and duplicates
+	* gst/videoscale/videoscale.c: (videoscale_get_structure):
+	  no good reason to limit ourselves to 100x100
+
+2004-06-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_class_init), (gst_v4lsrc_init),
+	(gst_v4lsrc_open), (gst_v4lsrc_src_link), (gst_v4lsrc_getcaps),
+	(gst_v4lsrc_get), (gst_v4lsrc_set_property),
+	(gst_v4lsrc_get_property):
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/v4l_calls.c: (gst_v4l_set_window_properties),
+	(gst_v4l_open), (gst_v4l_get_picture), (gst_v4l_get_audio),
+	(gst_v4l_set_audio):
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_grab_frame),
+	(gst_v4lsrc_try_capture):
+	* sys/v4l/v4lsrc_calls.h:
+	  change try_palette to more general try_capture
+	  add autoprobe option so we can turn off autoprobing
+	  various fixes
+
+2004-06-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  add videorate
+	* sys/ximage/ximagesink.c: (gst_ximagesink_finalize),
+	(gst_ximagesink_class_init):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_finalize),
+	(gst_xvimagesink_class_init):
+          run them as finalize, not dispose, since dispose can be invoked
+          multiple times
+
+2004-06-17  Wim Taymans  <wim@fluendo.com>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_init), (gst_alsa_dispose),
+	(gst_alsa_get_time), (gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsaclock.c: (gst_alsa_clock_get_type):
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_init), (gst_alsa_src_loop),
+	(gst_alsa_src_change_state):
+	* ext/alsa/gstalsasrc.h:
+	Make the xrun code timestamp and offset the buffers correctly.
+	moved the clock to the base class, use alsa methods to get time.
+	Do correct timestamping on outgoing buffers.
+
+2004-06-17  Wim Taymans  <wim@fluendo.com>
+
+	* gst/audiorate/Makefile.am:
+	* gst/audiorate/gstaudiorate.c: (gst_audiorate_get_type),
+	(gst_audiorate_base_init), (gst_audiorate_class_init),
+	(gst_audiorate_link), (gst_audiorate_init), (gst_audiorate_chain),
+	(gst_audiorate_set_property), (gst_audiorate_get_property),
+	(gst_audiorate_change_state), (plugin_init):
+	Added an audiorate converter that fills in gaps.
+
+2004-06-17  Johan Dahlin  <johan@gnome.org>
+
+	* ext/tcp/*: Revert Zaheer changes, to make things actually work again.
+
+2004-06-16  Wim Taymans  <wim@fluendo.com>
+
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_get):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_sync_mode_get_type),
+	(gst_v4lsrc_class_init), (gst_v4lsrc_init), (gst_v4lsrc_get_fps),
+	(gst_v4lsrc_get), (gst_v4lsrc_set_property),
+	(gst_v4lsrc_get_property):
+	* sys/v4l/gstv4lsrc.h:
+	Added a copy mode to v4lsrc where it will output a copied version
+	of its internal hardware buffer.
+	Fix the wrong FLAG_SET usage. The flags are integers, not bits, you
+	can't | them.
+
+2004-06-16  Wim Taymans  <wim@fluendo.com>
+
+	* sys/oss/gstosssrc.c: (gst_osssrc_get):
+	Timestamp fixes.
+
+2004-06-16  Wim Taymans  <wim@fluendo.com>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_sync_mode_get_type),
+	(gst_v4lsrc_class_init), (gst_v4lsrc_init), (gst_v4lsrc_get_fps),
+	(gst_v4lsrc_get), (gst_v4lsrc_set_property),
+	(gst_v4lsrc_get_property):
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_overlay):
+	Added a sync mode enum property to control v4lsrc timestamp method
+	Removed the use-fixed-fps property and moved functionality in
+	the enum.
+	Don't error on an error value from v4l-conf, it might not always
+	be a real error.
+
+2004-06-16  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videorate/Makefile.am:
+	* gst/videorate/gstvideorate.c: (gst_videorate_get_type),
+	(gst_videorate_base_init), (gst_videorate_class_init),
+	(gst_videorate_getcaps), (gst_videorate_link),
+	(gst_videorate_init), (gst_videorate_chain),
+	(gst_videorate_set_property), (gst_videorate_get_property),
+	(gst_videorate_change_state), (plugin_init):
+	Added a video timestamp corrector.
+
+2004-06-15  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	fixed a potential leak with previous commit
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head):
+
+2004-06-15  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head):
+	Added missing refcount, fixes bug #144425
+	Cheers Tim for finding the bug
+
+2004-06-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4l.c: (plugin_init):
+	* sys/v4l/gstv4lcolorbalance.c:
+	* sys/v4l/gstv4lcolorbalance.h:
+	* sys/v4l/gstv4lelement.c:
+	* sys/v4l/gstv4lelement.h:
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_class_init):
+	* sys/v4l/gstv4lmjpegsink.h:
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_class_init):
+	* sys/v4l/gstv4lmjpegsrc.h:
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_get_fps_list),
+	(gst_v4lsrc_get_fps), (gst_v4lsrc_srcconnect),
+	(gst_v4lsrc_getcaps), (gst_v4lsrc_get):
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/gstv4ltuner.c:
+	* sys/v4l/gstv4ltuner.h:
+	* sys/v4l/gstv4lxoverlay.c:
+	* sys/v4l/gstv4lxoverlay.h:
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_overlay),
+	(gst_v4l_set_window), (gst_v4l_enable_overlay):
+	* sys/v4l/v4l_calls.c: (gst_v4l_set_window_properties),
+	(gst_v4l_open), (gst_v4l_get_picture), (gst_v4l_get_audio),
+	(gst_v4l_set_audio):
+	* sys/v4l/v4l_calls.h:
+	* sys/v4l/v4lmjpegsink_calls.c: (gst_v4lmjpegsink_sync_thread),
+	(gst_v4lmjpegsink_queue_frame), (gst_v4lmjpegsink_sync_frame),
+	(gst_v4lmjpegsink_set_buffer), (gst_v4lmjpegsink_set_playback),
+	(gst_v4lmjpegsink_playback_init),
+	(gst_v4lmjpegsink_playback_start), (gst_v4lmjpegsink_get_buffer),
+	(gst_v4lmjpegsink_play_frame), (gst_v4lmjpegsink_wait_frame),
+	(gst_v4lmjpegsink_playback_stop),
+	(gst_v4lmjpegsink_playback_deinit):
+	* sys/v4l/v4lmjpegsink_calls.h:
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_queue_frame),
+	(gst_v4lmjpegsrc_sync_next_frame), (gst_v4lmjpegsrc_set_buffer),
+	(gst_v4lmjpegsrc_set_capture), (gst_v4lmjpegsrc_set_capture_m),
+	(gst_v4lmjpegsrc_capture_init), (gst_v4lmjpegsrc_capture_start),
+	(gst_v4lmjpegsrc_grab_frame), (gst_v4lmjpegsrc_requeue_frame),
+	(gst_v4lmjpegsrc_capture_stop), (gst_v4lmjpegsrc_capture_deinit):
+	* sys/v4l/v4lmjpegsrc_calls.h:
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_queue_frame),
+	(gst_v4lsrc_sync_frame), (gst_v4lsrc_set_capture),
+	(gst_v4lsrc_capture_init), (gst_v4lsrc_capture_start),
+	(gst_v4lsrc_grab_frame), (gst_v4lsrc_requeue_frame),
+	(gst_v4lsrc_capture_stop), (gst_v4lsrc_capture_deinit),
+	(gst_v4lsrc_try_palette):
+	* sys/v4l/v4lsrc_calls.h:
+	  bunch of paranoia cleanups
+
+2004-06-14  David Schleef  <ds@schleef.org>
+
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_init),
+	(cdparanoia_get), (cdparanoia_open), (cdparanoia_change_state):
+	Send discont events and change timestamps appropriately when
+	we get a seek event.  (bug #144240)
+	* ext/cdparanoia/gstcdparanoia.h:
+
+2004-06-14  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: Use snd_pcm_hw_params_set_rate _near instead of
+	  snd_pcm_hw_params_set_rate  since the latter fails for no good
+	  reason on some setups.
+
+2004-06-14  David Schleef  <ds@schleef.org>
+
+	* gst/volume/demo.c: (value_changed_callback): exp10() is not
+	standard.  Thank you for playing.
+
+2004-06-14  Wim Taymans  <wim@fluendo.com>
+
+	* gst/ffmpegcolorspace/imgconvert.c: (img_convert):
+	Patch 1.3 broke the ordering of the colorspace info and
+	made the plugin basically work by coincidence, reordered
+	the info.
+
+2004-06-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/lame/gstlame.c:
+	* ext/mad/gstmad.c:
+	  sync caps.  Make sure mad can only output a list of rates, not
+	  a full range.  In the future, have three caps lists for each of the
+	  mpeg versions.  Change mpegversion to a double as well.
+
+2004-06-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/volume/.cvsignore:
+	* gst/volume/Makefile.am:
+	* gst/volume/demo.c: (value_changed_callback), (idler),
+	(setup_gui), (main):
+	  added small demo app
+
+2004-06-13  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/esd/esdsink.c: (gst_esdsink_change_state):
+	* ext/esd/esdsink.h:
+	Close the esd connection on pause, because esd will just wait -
+	blocking all other esd clients indefinitely.
+
+2004-06-12  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/tags/gstvorbistag.c: replaced a g_warning which I added in my
+	  previous commit with GST_DEBUG
+
+2004-06-12  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  add a header check for a dvdread header in dvdnav.  Fixes #133002
+
+2004-06-12  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/tcp/gsttcpclientsink.c: (gst_tcpclientsink_init_send):
+	* gst/tcp/gsttcpclientsink.h:
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_init_receive):
+	* gst/tcp/gsttcpclientsrc.h:
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_init),
+	(gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_init_send):
+	* gst/tcp/gsttcpserversink.h:
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_init_receive):
+	* gst/tcp/gsttcpserversrc.h:
+	Modified the tcp plugins so they are portable (IPv4,IPv6, any future
+        version of IP)
+
+2004-06-12  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* configure.ac:
+	Added ogg library so that OSX detects libtheora properly
+
+2004-06-11  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoradec.c: (theora_dec_chain),
+	(theora_dec_change_state):
+	Don't try to decode frames before we received a keyframe.
+
+2004-06-11  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_class_init),
+	(gst_ogg_mux_init), (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_get_headers), (gst_ogg_mux_set_header_on_caps),
+	(gst_ogg_mux_send_headers), (gst_ogg_mux_loop),
+	(gst_ogg_mux_get_property), (gst_ogg_mux_set_property):
+	Added property to set the maximum delay of a page.
+
+2004-06-10  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_class_init),
+	(gst_ogg_mux_init), (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_get_headers), (gst_ogg_mux_set_header_on_caps),
+	(gst_ogg_mux_send_headers), (gst_ogg_mux_loop),
+	(gst_ogg_mux_get_property), (gst_ogg_mux_set_property):
+	Added max-delay property to control the maximum amount
+	of data to put in one page.
+
+2004-06-10  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init),
+	(gst_theora_enc_init), (theora_enc_sink_link),
+	(theora_buffer_from_packet), (theora_enc_set_property),
+	(theora_enc_get_property):
+	Set duration on encoded buffer, added some more properties
+
+2004-06-10  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_get_headers), (gst_ogg_mux_set_header_on_caps),
+	(gst_ogg_mux_send_headers), (gst_ogg_mux_loop):
+	* ext/theora/theoraenc.c: (theora_enc_chain):
+	Fix refcounting bugs
+
+2004-06-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_init),
+	(gst_asf_demux_loop), (gst_asf_demux_process_file),
+	(gst_asf_demux_process_data), (gst_asf_demux_handle_data),
+	(gst_asf_demux_process_object), (gst_asf_demux_get_stream),
+	(gst_asf_demux_process_chunk), (gst_asf_demux_handle_sink_event),
+	(gst_asf_demux_handle_src_event), (gst_asf_demux_handle_src_query),
+	(gst_asf_demux_change_state):
+	* gst/asfdemux/gstasfdemux.h:
+	  You know Chimaira? "I - HATE - EVERYTHING". Yeah, that's what this
+	  feels like. I think we should set a new requirement for demuxers
+	  from now on to implement sane loop functions, data loops, query
+	  and seek functions before first commit into CVS. And this commit
+	  fixes all of the above.
+
+2004-06-10  Christophe Fergeau  <teuf@gnome.org>
+
+	* gst/tags/gstvorbistag.c: (gst_vorbis_tag_add): make sure parsed
+	  vorbis comments are properly encoded in UTF-8 before adding them
+	  to a GstTagList
+
+2004-06-09  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (add_channels):
+	  handle min <= max correctly
+	* ext/alsa/gstalsa.c: (gst_alsa_fixate_to_mimetype),
+	(gst_alsa_fixate_field_nearest_int), (gst_alsa_fixate):
+	  add fixation functions so we fixate correctly. No preferring of alaw
+	  anymore because it's the first structure.
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsa.c: (gst_alsa_sw_params_dump),
+	(gst_alsa_hw_params_dump):
+	  add functions to ease debugging in alsalib
+	* ext/alsa/gstalsa.c: (gst_alsa_probe_hw_params),
+	(gst_alsa_set_hw_params), (gst_alsa_set_sw_params),
+	(gst_alsa_start_audio):
+	  only specify hw params if we really setup a format (fixes #134007 -
+	  or at least works around it)
+
+2004-06-09  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_init),
+	(gst_ogg_mux_next_buffer), (gst_ogg_mux_buffer_from_page),
+	(gst_ogg_mux_push_page), (gst_ogg_mux_get_headers),
+	(gst_ogg_mux_set_header_on_caps), (gst_ogg_mux_send_headers),
+	(gst_ogg_mux_loop):
+	Use stream caps to setup the initial pages in the ogg stream.
+	Correctly set the streamheader caps on the srcpad.
+
+2004-06-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_get_fps_list),
+	(gst_v4lsrc_get_fps), (gst_v4lsrc_srcconnect),
+	(gst_v4lsrc_getcaps):
+	* sys/v4l/v4l_calls.c: (gst_v4l_set_window_properties),
+	(gst_v4l_get_picture), (gst_v4l_get_audio), (gst_v4l_set_audio):
+	  add querying of fps lists for webcams.  Negotiating to a framerate
+	  now works.
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/theora/theoraenc.c: (theora_buffer_from_packet),
+	(theora_push_buffer), (theora_push_packet),
+	(theora_set_header_on_caps), (theora_enc_chain):
+	  mark buffers and put on streamheader, raw theora streaming
+	  now works too, whee
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcp.c: (gst_tcp_gdp_read_header),
+	(gst_tcp_gdp_read_caps):
+          do a looping read for caps and GDP headers too
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_get):
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_get):
+          return EOS instead of NULL in _get
+
+2004-06-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/tcp/gsttcp.c: (gst_tcp_gdp_read_header),
+	(gst_tcp_gdp_read_caps), (gst_tcp_gdp_write_header),
+	(gst_tcp_gdp_write_caps):
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_get):
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_gdp_read_caps),
+	(gst_tcpserversrc_gdp_read_header), (gst_tcpserversrc_get):
+	Memory leak fixes
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/Makefile.am:
+	* ext/vorbis/vorbis.c: (plugin_init):
+	* ext/vorbis/vorbisparse.c: (gst_vorbis_parse_base_init),
+	(gst_vorbis_parse_class_init), (gst_vorbis_parse_init),
+	(vorbis_parse_set_header_on_caps), (vorbis_parse_chain),
+	(vorbis_parse_change_state):
+	* ext/vorbis/vorbisparse.h:
+          adding a vorbisparse element that marks the buffers, streaming
+          raw vorbis using GDP now works, whee
+
+2004-06-08  Wim Taymans  <wim@fluendo.com>
+
+	* ext/jpeg/Makefile.am:
+	* ext/jpeg/README:
+	* ext/jpeg/gstjpeg.c: (plugin_init):
+	* ext/jpeg/gstsmokedec.c: (gst_smokedec_get_type),
+	(gst_smokedec_base_init), (gst_smokedec_class_init),
+	(gst_smokedec_init), (gst_smokedec_link), (gst_smokedec_chain):
+	* ext/jpeg/gstsmokedec.h:
+	* ext/jpeg/gstsmokeenc.c: (gst_smokeenc_get_type),
+	(gst_smokeenc_base_init), (gst_smokeenc_class_init),
+	(gst_smokeenc_init), (gst_smokeenc_getcaps), (gst_smokeenc_link),
+	(gst_smokeenc_resync), (gst_smokeenc_chain),
+	(gst_smokeenc_set_property), (gst_smokeenc_get_property):
+	* ext/jpeg/gstsmokeenc.h:
+	* ext/jpeg/smokecodec.c: (smokecodec_init_destination),
+	(smokecodec_flush_destination), (smokecodec_term_destination),
+	(smokecodec_init_source), (smokecodec_fill_input_buffer),
+	(smokecodec_skip_input_data), (smokecodec_resync_to_restart),
+	(smokecodec_term_source), (smokecodec_encode_new),
+	(smokecodec_decode_new), (smokecodec_info_free),
+	(smokecodec_set_quality), (smokecodec_get_quality),
+	(smokecodec_set_threshold), (smokecodec_get_threshold),
+	(smokecodec_set_bitrate), (smokecodec_get_bitrate),
+	(find_best_size), (abs_diff), (put), (smokecodec_encode),
+	(smokecodec_parse_header), (smokecodec_decode):
+	* ext/jpeg/smokecodec.h:
+	Added a new simple jpeg based codec
+
+2004-06-08  Wim Taymans  <wim@fluendo.com>
+
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_class_init),
+	(gst_multipart_mux_loop):
+	Fix memory leak
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_get):
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_client_remove),
+	(gst_tcpserversink_handle_client_read), (gst_tcp_buffer_write),
+	(gst_tcpserversink_handle_client_write), (gst_tcpserversink_chain),
+	(gst_tcpserversink_init_send), (gst_tcpserversink_close):
+	* gst/tcp/gsttcpserversink.h:
+          take streamheader into account
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/level/Makefile.am:
+	* gst/level/gstlevel.c: (gst_level_class_init):
+	  clean up marshal generation
+
+2004-06-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/Makefile.am:
+	* gst/tcp/gsttcpclientsink.c: (gst_tcpclientsink_get_type),
+	(gst_tcpclientsink_class_init), (gst_tcpclientsink_init),
+	(gst_tcpclientsink_set_property), (gst_tcpclientsink_get_property):
+	* gst/tcp/gsttcpclientsrc.c: (gst_tcpclientsrc_class_init),
+	(gst_tcpclientsrc_init), (gst_tcpclientsrc_set_property),
+	(gst_tcpclientsrc_get_property):
+	* gst/tcp/gsttcpserversink.c: (gst_tcpserversink_class_init),
+	(gst_tcpserversink_init), (gst_tcpserversink_handle_server_read),
+	(gst_tcpserversink_handle_client_read),
+	(gst_tcpserversink_handle_client_write),
+	(gst_tcpserversink_set_property), (gst_tcpserversink_get_property):
+	* gst/tcp/gsttcpserversink.h:
+	  add signals client-added and client-removed
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_class_init),
+	(gst_tcpserversrc_init), (gst_tcpserversrc_set_property),
+	(gst_tcpserversrc_get_property):
+	uniformized, change default protocol to NONE
+	* gst/tcp/gsttcp-marshal.list: added
+2004-06-07  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  handle discont events if they happen before caps nego
+
+2004-06-07  Wim Taymans  <wim@fluendo.com>
+
+	* gst/multipart/multipartdemux.c: (gst_multipart_demux_base_init),
+	(gst_multipart_find_pad_by_mime), (gst_multipart_demux_chain),
+	(gst_multipart_demux_plugin_init):
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_class_init),
+	(gst_multipart_mux_init), (gst_multipart_mux_loop),
+	(gst_multipart_mux_change_state):
+	Small updates, fix a memleak
+
+2004-06-07  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* configure.ac: OSS portability
+	* ext/arts/gst_arts.c: idem
+	* sys/oss/gstosselement.c: idem
+	* sys/oss/gstossmixer.c: idem
+	* sys/oss/gstosssink.c: idem
+	* sys/oss/gstosssrc.c: idem
+	* sys/oss/oss_probe.c: idem
+	  - check for soundcard.h in different places for some BSD
+
+2004-06-07  Jan Schmidt <thaytan@mad.scientist.com>
+
+	* AUTHORS:
+	Add me to the authors file
+	* configure.ac:
+	Increase the libdv requirement to >= version 0.100
+	* ext/dv/gstdvdec.c: (gst_dvdec_init), (gst_dvdec_src_convert),
+	(gst_dvdec_src_query), (gst_dvdec_handle_sink_event),
+	(gst_dvdec_push), (gst_dvdec_loop), (gst_dvdec_change_state):
+	* ext/dv/gstdvdec.h:
+	Add support for the new_media flag when sending DISCONT events
+	Make the querying work when video pad is not linked
+
+2004-06-07  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* gst/mixmatrix/mixmatrix.c: (gst_mixmatrix_init):
+	  create a NULL-initialized array of pads, so we don't think they
+	  exist already. (fixes #143130)
+
+2004-06-07  Benjamin Otte  <otte@gnome.org>
+
+	* gst/mixmatrix/mixmatrix.c: (gst_mixmatrix_init),
+	(mixmatrix_resize), (gst_mixmatrix_set_all_caps),
+	(gst_mixmatrix_request_new_pad), (gst_mixmatrix_loop):
+	  don't use // coments
+
+2004-06-07  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_samples_to_timestamp):
+	  cast to GstClockTime to get higher granularity
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  use gst_element_set_time_delay to get the exact time
+	* ext/mad/gstmad.c: (gst_mad_chain):
+	  use the negotiated rate instead of the current frame's rate which
+	  might be wrong because of bit errors. This avoids emitting totally
+	  bogus timestamps and screwing sync.
+	(fixes #143454)
+
+2004-06-07  Tim-Philipp Müller  <t.i.m@zen.co.uk>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* gst/adder/gstadder.c: (gst_adder_loop):
+	  properly error out when no negotiation has happened yet. (fixes
+	  #143032)
+
+2004-06-06  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event):
+	  forward correctly transformed offset in discont events. Based on
+	  patch by Arwed v. Merkatz. (fixes #142851)
+
+2004-06-06  David Schleef  <ds@schleef.org>
+
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c: that's
+	G_HAVE_GNUC_VARARGS, not G_HAVE_GNU_VARARGS.  Should fix compile
+	problems on several systems.
+
+2004-06-06  Benjamin Otte  <otte@gnome.org>
+
+	* ext/vorbis/vorbisdec.c: (gst_vorbis_dec_init):
+	  use explicit caps on the srcpad
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+	  properly error out if caps couldn't be set (fixes #142764)
+
+2004-06-06  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_probe_hw_params),
+	(gst_alsa_set_hw_params), (gst_alsa_set_sw_params),
+	(gst_alsa_start_audio):
+	  - don't call set_periods_integer anymore, it breaks the
+	  configuration randomly
+	  - call snd_pcm_hw_params_set_access directly instead of using masks
+	  - don't fail if the sw_params can't be set, just use the default
+	  params and hope it works. Alsalib has weird issues when you touch
+	  sw_params and does no proper error reporting about what failed.
+	* ext/alsa/gstalsa.c: (gst_alsa_open_audio),
+	(gst_alsa_close_audio):
+	  make our alsa debugging go via gst debugging and not conditionally
+	  defined
+	* ext/alsa/gstalsa.h:
+	  add ALSA_DEBUG_FLUSH macro
+	* ext/alsa/gstalsaplugin.c: (gst_alsa_error_wrapper),
+	(plugin_init):
+	  wrap alsa errors to be printed via the gst debugging system and not
+	  spammed to stderr
+
+2004-06-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_init),
+	(gst_qtdemux_handle_src_query), (gst_qtdemux_handle_src_event),
+	(gst_qtdemux_handle_sink_event), (gst_qtdemux_change_state),
+	(gst_qtdemux_loop_header), (qtdemux_dump_mvhd),
+	(qtdemux_parse_trak):
+	* gst/qtdemux/qtdemux.h:
+	  Bitch. Also known as seeking, querying & co.
+	* sys/oss/gstosssink.c: (gst_osssink_init), (gst_osssink_chain),
+	(gst_osssink_change_state):
+	* sys/oss/gstosssink.h:
+	  Resyncing is for weenies, this hack is no longer needed and was
+	  broken anyway (since it - unintendedly - always leaves resync to
+	  TRUE).
+
+2004-06-05  Andrew Turner <zxombie@hotpop.com>
+
+	* gst/tcp/gsttcp.c: portability (Solaris 10/FreeBSD)
+	* gst/tcp/gsttcpclientsrc.h: idem
+	  - define MSG_NOSIGNAL if not done
+	  - include unistd.h for off_t
+          (fixes #143749)
+
+2004-06-05  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	* ext/kio/Makefile.am:
+	  check for qt's moc preprocessor explicitly and use it
+
+2004-06-03  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* gst/tcp/gsttcp.c: (gst_tcp_socket_write):
+	  don't get a signal for EPIPE on socket writes
+	  (somebody check if this works on other platforms)
+
+2004-06-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/alsa/gstalsaclock.c: (gst_alsa_clock_get_type):
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_loop):
+          check error condition on available samples correctly
+
+2004-06-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_get_time):
+          avoid a segfault
+	* gst/tcp/gsttcp.c: (gst_tcp_socket_write), (gst_tcp_socket_read),
+	(gst_tcp_gdp_read_header), (gst_tcp_gdp_read_caps):
+	* gst/tcp/gsttcpserversrc.c: (gst_tcpserversrc_gdp_read_caps),
+	(gst_tcpserversrc_gdp_read_header):
+         use ssize_t over size_t since the former is signed and thus the
+         check for error codes can work
+
+2004-06-02  Wim Taymans  <wim@fluendo.com>
+
+	reviewed by: Johan
+
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_class_init),
+	(gst_multipart_mux_loop):
+	Oops
+
+2004-06-02  Wim Taymans  <wim@fluendo.com>
+
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_class_init),
+	(gst_multipart_mux_init), (gst_multipart_mux_loop),
+	(gst_multipart_mux_get_property), (gst_multipart_mux_set_property),
+	(gst_multipart_mux_change_state):
+	Added configurable boundary specifier, added the value as a
+	caps field as well.
+
+2004-06-02  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* gst/tcp/gsttcp.c:
+	* gst/tcp/gsttcpclientsrc.c:
+	* gst/tcp/gsttcpclientsrc.h:
+	* gst/tcp/gsttcpserversrc.c:
+	  - portability fix, to compile on OSX
+            (fixes #143146)
+
+	* sys/osxaudio/gstosxaudioelement.c:
+	* sys/osxaudio/gstosxaudiosink.c:
+	* sys/osxaudio/gstosxaudiosrc.c:
+	  - compilation warnings on OSX
+            (fixes #143153)
+
+2004-06-02  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/vorbis/vorbisdec.c : sign warning fixes
+
+	* gst-libs/gst/mixer/mixertrack.c :
+	  do no use defines which are glib 2.4 specific
+
+2004-06-01  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/flac/gstflactag.c: strip ending framing bit from vorbiscomment
+	  buffer since libflac doesn't expect it (reports a sync error when
+	  it encounters that)
+
+
+2004-06-01  Owen Fraser-Green  <owen@discobabe.net>
+
+	* gst-libs/gst/mixer/mixertrack.h: Changed struct syntax
+	* gst-libs/gst/mixer/mixertrack.c:
+	(gst_mixer_track_get_property), (get_mixer_track_init),
+	(get_mixer_track_get_property): Added property accessors
+	* gst-libs/gst/mixer/mixeroptions.h: Changed struct syntax
+	* gst-libs/gst/mixer/mixeroptions.c:
+	(gst_mixer_options_get_values): Added
+	* gst-libs/gst/mixer/mixer.h: Changed GstMixerClass syntax
+	* gst-libs/gst/mixer/mixer.c: Fixed comment
+
+
+2004-06-01  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_open_audio):
+          improve error messages on open
+
+
+2004-06-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_overlay):
+          check if v4l-conf is in path
+
+2004-06-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/media-info/media-info-priv.c: (gmi_set_mime):
+          change assert to a more readable error message
+
+2004-05-31  Stephane Loeuillet  <stephane.loeuillet@tiscali.fr>
+
+	* gst-libs/gst/tuner/tunerchannel.h:
+	  - add a freq_multiplicator field to make the conversion
+	    between internal frequency unit and Hz
+	* sys/v4l/gstv4lelement.c:
+	* sys/v4l2/gstv4l2element.c:
+	  - change default video device to /dev/video0
+	* sys/v4l/v4l_calls.c:
+	* sys/v4l2/v4l2_calls.c:
+	  - we only expose frequency to the user in Hz instead of
+	    bastard v4lX unit (either 62.5kHz or 62.5Hz)
+
+2004-05-31  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+	  Initialise b_o_s and e_o_s variables
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data):
+	  Add some unusual fourcc's from mplayer avi's
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_plugin_init):
+	  Make the muxer have rank GST_RANK_NONE, so it doesn't mess up
+	  autoplugging.
+
+2004-05-28  Wim Taymans  <wim@fluendo.com>
+
+	* configure.ac:
+	* gst/alpha/Makefile.am:
+	* gst/alpha/gstalpha.c: (gst_alpha_method_get_type),
+	(gst_alpha_get_type), (gst_alpha_base_init),
+	(gst_alpha_class_init), (gst_alpha_init), (gst_alpha_set_property),
+	(gst_alpha_get_property), (gst_alpha_sink_link), (gst_alpha_add),
+	(gst_alpha_chroma_key), (gst_alpha_chain),
+	(gst_alpha_change_state), (plugin_init):
+	A plugin to add an alpha channel to I420 video. Can optionally do
+	chroma keying.
+	* gst/multipart/Makefile.am:
+	* gst/multipart/multipart.c: (plugin_init):
+	* gst/multipart/multipartdemux.c: (gst_multipart_demux_base_init),
+	(gst_multipart_demux_class_init), (gst_multipart_demux_init),
+	(gst_multipart_demux_finalize), (gst_multipart_demux_handle_event),
+	(gst_multipart_find_pad_by_mime), (gst_multipart_demux_chain),
+	(gst_multipart_demux_change_state),
+	(gst_multipart_demux_plugin_init):
+	* gst/multipart/multipartmux.c: (gst_multipart_mux_get_type),
+	(gst_multipart_mux_base_init), (gst_multipart_mux_class_init),
+	(gst_multipart_mux_get_sink_event_masks), (gst_multipart_mux_init),
+	(gst_multipart_mux_sinkconnect), (gst_multipart_mux_pad_link),
+	(gst_multipart_mux_pad_unlink),
+	(gst_multipart_mux_request_new_pad),
+	(gst_multipart_mux_handle_src_event),
+	(gst_multipart_mux_next_buffer), (gst_multipart_mux_compare_pads),
+	(gst_multipart_mux_queue_pads), (gst_multipart_mux_loop),
+	(gst_multipart_mux_get_property), (gst_multipart_mux_set_property),
+	(gst_multipart_mux_change_state), (gst_multipart_mux_plugin_init):
+	A Multipart demuxer/muxer. Not sure if it violates specs. Used to
+	send multipart jpeg images to a browser.
+	* gst/videobox/Makefile.am:
+	* gst/videobox/README:
+	* gst/videobox/gstvideobox.c: (gst_video_box_fill_get_type),
+	(gst_video_box_get_type), (gst_video_box_base_init),
+	(gst_video_box_class_init), (gst_video_box_init),
+	(gst_video_box_set_property), (gst_video_box_get_property),
+	(gst_video_box_sink_link), (gst_video_box_i420),
+	(gst_video_box_ayuv), (gst_video_box_chain),
+	(gst_video_box_change_state), (plugin_init):
+	Crops or adds borders around an image. can do alpha channel
+	borders as well.
+	* gst/videomixer/Makefile.am:
+	* gst/videomixer/README:
+	* gst/videomixer/videomixer.c: (gst_videomixer_pad_get_type),
+	(gst_videomixer_pad_base_init), (gst_videomixer_pad_class_init),
+	(gst_videomixer_pad_get_sink_event_masks),
+	(gst_videomixer_pad_get_property),
+	(gst_videomixer_pad_set_property),
+	(gst_videomixer_pad_sinkconnect), (gst_videomixer_pad_link),
+	(gst_videomixer_pad_unlink), (gst_videomixer_pad_init),
+	(gst_video_mixer_background_get_type), (gst_videomixer_get_type),
+	(gst_videomixer_base_init), (gst_videomixer_class_init),
+	(gst_videomixer_init), (gst_videomixer_request_new_pad),
+	(gst_videomixer_handle_src_event),
+	(gst_videomixer_blend_ayuv_i420), (gst_videomixer_fill_checker),
+	(gst_videomixer_fill_color), (gst_videomixer_fill_queues),
+	(gst_videomixer_blend_buffers), (gst_videomixer_update_queues),
+	(gst_videomixer_loop), (gst_videomixer_get_property),
+	(gst_videomixer_set_property), (gst_videomixer_change_state),
+	(plugin_init):
+	Generic video mixer plugin, can handle multiple inputs all with
+	different framerates and video sizes. Is fully alpha channel
+	aware.
+
+2004-05-27  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_build_list):
+	  Select first track as master track. Not sure how else to handle
+	  that...
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_next_buffer):
+	  Discard discont events. Should fix #142962.
+
+2004-05-26  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/Makefile.am:
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_interface_init),
+	(gst_alsa_mixer_build_list), (gst_alsa_mixer_get_volume),
+	(gst_alsa_mixer_set_volume), (gst_alsa_mixer_set_mute),
+	(gst_alsa_mixer_set_record), (gst_alsa_mixer_set_option),
+	(gst_alsa_mixer_get_option):
+	* ext/alsa/gstalsamixer.h:
+	* ext/alsa/gstalsamixeroptions.c:
+	(gst_alsa_mixer_options_get_type),
+	(gst_alsa_mixer_options_class_init), (gst_alsa_mixer_options_init),
+	(gst_alsa_mixer_options_new):
+	* ext/alsa/gstalsamixeroptions.h:
+	* ext/alsa/gstalsamixertrack.c: (gst_alsa_mixer_track_new):
+	* ext/alsa/gstalsamixertrack.h:
+	  Add enumerations (as GstMixerOptions). Make correct distinction
+	  between input/output tracks. Add capture/playback private flag.
+	  Use flag to decide on whether to set capture or playback volumes
+	  or switches. Use playback and record switches.
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/mixer/mixer-marshal.list:
+	* gst-libs/gst/mixer/mixer.c: (gst_mixer_class_init),
+	(gst_mixer_set_option), (gst_mixer_get_option),
+	(gst_mixer_mute_toggled), (gst_mixer_record_toggled),
+	(gst_mixer_volume_changed), (gst_mixer_option_changed):
+	* gst-libs/gst/mixer/mixer.h:
+	* gst-libs/gst/mixer/mixeroptions.c: (gst_mixer_options_get_type),
+	(gst_mixer_options_class_init), (gst_mixer_options_init),
+	(gst_mixer_options_dispose):
+	* gst-libs/gst/mixer/mixeroptions.h:
+	  Add GstMixerOptions.
+	* sys/oss/gstosselement.c: (gst_osselement_class_probe_devices):
+	  Rename Audio Mixer to OSS Mixer (similar to Alsa Mixer). Fix
+	  broken device detection on computers with multiple OSS sound
+	  cards.
+
+2004-05-26  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_fixate):
+	  fixate nicely even when the peer is not negotiating
+
+2004-05-25  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/audioconvert/gstaudioconvert.c:
+	(gst_audio_convert_parse_caps):
+	  make sure we don't allow depth > width
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_fixate):
+	  fixate endianness to G_BYTE_ORDER as default
+	* gst/audioscale/gstaudioscale.c:
+	  we don't handle another endianness as host-endianness
+
+2004-05-25  David Schleef  <ds@schleef.org>
+
+	* gst/ffmpegcolorspace/mem.c:  malloc() is in stdlib.h, not malloc.h
+
+2004-05-24  Benjamin Otte  <otte@gnome.org>
+
+	* ext/vorbis/oggvorbisenc.c: (gst_oggvorbisenc_sinkconnect),
+	(gst_oggvorbisenc_setup):
+	  properly fail when we can't setup the vorbis encoder due to
+	  unsupported settings
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_sinkconnect),
+	(gst_vorbisenc_setup):
+	  same
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	  fix case where warnings occured when one pad was unlinked while the
+	  other's link function was called
+
+2004-05-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/Makefile.am:
+          use GST_ENABLE_NEW
+
+2004-05-24  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/resample/private.h:
+	  don't use optimizations that are #if 0'ed
+
+2004-05-24  Wim Taymans  <wim@fluendo.com>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_handle_src_query):
+	Fix potential division by zero error and hopefully get
+	the position query right to get correct timestamps on avi
+	audio.
+
+2004-05-24  Wim Taymans  <wim@fluendo.com>
+
+	* gst/videoscale/videoscale.c: (gst_videoscale_scale_nearest),
+	(gst_videoscale_scale_nearest_str2),
+	(gst_videoscale_scale_nearest_str4),
+	(gst_videoscale_scale_nearest_32bit),
+	(gst_videoscale_scale_nearest_24bit),
+	(gst_videoscale_scale_nearest_16bit):
+	Fix the scaling algorithm and avoid a buffer overflow.
+        removed the while loop in the scaling function as it
+	was used for point sampling only.
+
+2004-05-24  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_get_type),
+	(gst_id3_tag_class_init), (gst_id3_tag_init),
+	(gst_id3_tag_set_property), (gst_id3_tag_get_tag_to_render),
+	(gst_id3_tag_handle_event), (gst_id3_tag_do_caps_nego),
+	(gst_id3_tag_send_tag_event):
+	  lots of fixes to make id3mux work and id3demux work correctly
+
+2004-05-24  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/Makefile.am:
+	  add rules to build shout2send (was removed by accident
+	  when this module was no more marked experimental/broken)
+
+2004-05-24  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	* ext/shout2/gstshout2.c:
+	* ext/shout2/gstshout2.h:
+	  adding a "connection problem" signal to shout2send
+	  (fixes #142954)
+
+2004-05-21  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/kio/kioreceiver.cpp:
+	* ext/kio/kioreceiver.h:
+          fix sign comparison issues
+
+2004-05-21  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/cdxaparse/gstcdxaparse.c:
+	* gst/cdxaparse/gstcdxaparse.h:
+	  some renaming
+	  add some checks/sanity
+	  prepare for seek addition
+
+	* sys/sunaudio/gstsunaudio.c:
+	  remove exported dupe init function
+
+2004-05-21  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_init), (gst_dvdec_get_formats),
+	(gst_dvdec_src_convert), (gst_dvdec_sink_convert):
+	  Fix format conversion and position querying.
+	* gst/debug/progressreport.c: (gst_progressreport_report):
+	  Don't output a bogus total value that we didn't query.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support):
+	  Always set XV_AUTOPAINT_COLORKEY to true. Fixes xvimagesink showing
+	  only a blank window after xine has been used.
+
+2004-05-21  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* m4/as-arts.m4:
+	  sync with upstream version to fix test on FC2
+	  readd with -ko to preserve Id header
+
+2004-05-20  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* configure.ac:
+	  test for FIONREAD ioctl in sys/filio.h for Solaris compat.
+	* gst/tcp/gsttcpclientsrc.c: idem
+	* gst/tcp/gsttcpserversink.c: idem
+	* gst/tcp/gsttcpserversrc.c: idem
+	* m4/gst-fionread.m4: idem
+
+	* sys/sunaudio/gstsunaudio.c: change category to Sink/Audio
+
+	* configure.ac: enable speex plugin for speex 1.1.5+
+	* ext/speex/gstspeexenc.c: fix cast warning
+
+	* ext/esd/README: fix typo
+
+2004-05-20  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Minor cosmetic change to convince the buildbot to
+	reautogen.
+	* sys/sunaudio/gstsunaudio.c: (gst_sunaudiosink_class_init),
+	(gst_sunaudiosink_init), (gst_sunaudiosink_getcaps),
+	(gst_sunaudiosink_pad_link), (gst_sunaudiosink_chain),
+	(gst_sunaudiosink_setparams), (gst_sunaudiosink_open),
+	(gst_sunaudiosink_close), (gst_sunaudiosink_change_state),
+	(gst_sunaudiosink_set_property), (gst_sunaudiosink_get_property):
+	More hacking.  Plays audio now.
+
+2004-05-20  David Schleef  <ds@schleef.org>
+
+	* configure.ac:
+	* sys/Makefile.am:
+
+2004-05-20  David Schleef  <ds@schleef.org>
+
+	* sys/osxaudio/Makefile.am:  New OS X audio plugin by Zaheer Abbas Merali
+	* sys/osxaudio/gstosxaudio.c:
+	* sys/osxaudio/gstosxaudioelement.c:
+	* sys/osxaudio/gstosxaudioelement.h:
+	* sys/osxaudio/gstosxaudiosink.c:
+	* sys/osxaudio/gstosxaudiosink.h:
+	* sys/osxaudio/gstosxaudiosrc.c:
+	* sys/osxaudio/gstosxaudiosrc.h:
+
+2004-05-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_set_header_on_caps),
+	(gst_vorbisenc_chain):
+          put the codec headers on the caps as streamheader as well as
+          pushing them out
+
+2004-05-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisenc.c: (vorbis_granule_time_copy),
+	(gst_vorbisenc_buffer_from_packet), (gst_vorbisenc_push_buffer),
+	(gst_vorbisenc_push_packet), (gst_vorbisenc_chain):
+        split up push_packet into two functions
+
+2004-05-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/.cvsignore:
+	  ignore enums
+	* gst/tcp/Makefile.am:
+	* gst/tcp/README:
+	* gst/tcp/gsttcp.c:
+	* gst/tcp/gsttcp.h:
+	* gst/tcp/gsttcpclientsink.c:
+	* gst/tcp/gsttcpclientsink.h:
+	* gst/tcp/gsttcpclientsrc.c:
+	* gst/tcp/gsttcpclientsrc.h:
+	* gst/tcp/gsttcpplugin.c:
+	* gst/tcp/gsttcpserversink.c:
+	* gst/tcp/gsttcpserversink.h:
+	* gst/tcp/gsttcpserversrc.c:
+	* gst/tcp/gsttcpserversrc.h:
+          add new tcp elements
+
+2004-05-19  Wim Taymans  <wim@fluendo.com>
+
+	* gst/law/mulaw-conversion.c: (mulaw_encode):
+	Fix overflow bug in ulaw encoding.
+
+2004-05-19  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstmad.c: (gst_mad_handle_event):
+	  don't unref the event twice
+
+2004-05-19  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  remove -Wno-sign-compare
+
+2004-05-19  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  remove -DG_DISABLE_DEPRECATED. It's not usable without workarounds
+	  if you want to work against glib 2.2 and 2.4
+
+2004-05-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tcp/Makefile.am:
+	* gst/tcp/gsttcp.c:
+	* gst/tcp/gsttcp.h:
+	* gst/tcp/gsttcpsink.h:
+	* gst/tcp/gsttcpsrc.h:
+          gsttcp -> gsttcpplugin + CVS surgery in preparation for tcp merge
+
+2004-05-19  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/debug/tests.c: (md5_get_value):
+	  fix segfault on gst-inspect
+
+2004-05-19  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/debug/testplugin.c:
+	* gst/debug/tests.c:
+	* gst/debug/tests.h:
+	  add new extensible and configurable testing element. Current tests
+	  include buffer count, stream length, timestamp/duration matching and
+	  md5.
+	* gst/debug/Makefile.am:
+	* gst/debug/gstdebug.c: (plugin_init):
+	  add infrastructure for new element
+
+2004-05-19  Johan Dahlin  <johan@gnome.org>
+
+	* ext/dv/gstdvdec.c (gst_dvdec_quality_get_type): Add proper
+	ending of the array. Fixes gst-inspect segfault on ppc.
+
+2004-05-19  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/dirac/gstdiracdec.cc : change category to Codec/Decoder/Video
+
+	* m4/a52.m4 : don't fix a test that should fail with current a52dec lib
+
+2004-05-18  David Schleef  <ds@schleef.org>
+
+	* gst/ffmpegcolorspace/imgconvert.c: (img_convert): Fixes for
+	warnings (bugs, actually) noticed by gcc but not forte.
+
+2004-05-18  David Schleef  <ds@schleef.org>
+
+	* sys/sunaudio/Makefile.am:
+	* sys/sunaudio/gstsunaudio.c: New sunaudiosink
+
+2004-05-18  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_change_state),
+	(gst_qtdemux_loop_header):  Patch from dcm@acm.org (David Moore)
+	to allow qtdemux to use non-seekable streams. (bug #142272)
+
+2004-05-18  David Schleef  <ds@schleef.org>
+
+	* gst-libs/gst/resample/resample.c: (gst_resample_sinc_ft_s16),
+	(gst_resample_sinc_ft_float): Remove use of static temporary
+	buffer.  This code was obviously not supposed to last long, but
+	it's stuck in our ABI, so it required a little hack to make it
+	ABI-compatible.  Fixes #142585.
+	* gst-libs/gst/resample/resample.h: same.
+
+2004-05-18  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Add sunaudio
+	* examples/Makefile.am: make gstplay depend on gconf
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c: Remove c99-isms
+	* gst/ffmpegcolorspace/imgconvert.c: (build_rgb_palette),
+	(convert_table_lookup), (img_convert): remove c99-isms
+	* gst/ffmpegcolorspace/imgconvert_template.h: make a constant
+          unsigned, to fix a warning on Solaris
+	* gst/mpeg1sys/systems.c: bcopy->memcpy
+	* gst/rtjpeg/RTjpeg.c: (RTjpeg_yuvrgb8): bcopy->memcpy
+	* sys/Makefile.am: Add sunaudio
+
+2004-05-18  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_get_type), (gst_ogg_mux_init),
+	(gst_ogg_mux_sinkconnect), (gst_ogg_mux_request_new_pad),
+	(gst_ogg_mux_next_buffer), (gst_ogg_mux_push_page),
+	(gst_ogg_mux_compare_pads), (gst_ogg_mux_queue_pads),
+	(gst_ogg_mux_loop):
+	Fix an ugly memleak where the muxer didn't flush enough ogg
+	pages. This also resulted in badly muxed ogg files.
+
+2004-05-18  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/asfdemux/asfheaders.c :
+	* gst/asfdemux/asfheaders.h :
+	* gst/asfdemux/gstasfdemux.c :
+	  - fix ASF_OBJ_PADDING guid
+	  - add 3 new object guids (language list, metadata,
+            extended stream properties)
+          - add a function to parse extended header objects
+
+2004-05-18  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/oss/gstosselement.c: (gst_osselement_sync_parms):
+	  remove leftover debugging g_print
+
+2004-05-17  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstmad.c: (gst_mad_handle_event):
+	  Fix for when the first format in a discont event is not a
+	  byte-based one. Should fix #137710.
+
+2004-05-18  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* m4/a52.m4 : fix compilation with -Wall -Werror
+	* m4/libfame.m4 : idem
+	* m4/libmikmod.m4 : idem
+
+2004-05-17  Benjamin Otte  <otte@gnome.org>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_comment):
+	  signal the new tags before giving up the reference
+
+2004-05-17  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/shout2/gstshout2.c:
+	  use application/ogg instead of application/x-ogg (patch by Patrick
+	  Guimond, fixes #142432)
+	* sys/oss/gstosselement.c: (gst_osselement_reset),
+	(gst_osselement_sync_parms):
+	  don't set fragment size unless specified (fixes #142493)
+
+2004-05-17  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* configure.ac : fix compilation of v4l2src with "-Wall -Werror"
+	  fixes #142664
+
+2004-05-17  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_chain):
+	  compute offsets correctly for internal buffers so timestamps are set
+	  correctly when we can't seek. Also handle cases where there are no
+	  offsets. (based on a patch by David Moore, fixes #142507)
+
+2004-05-17  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  use correct variable when determining amount of data to skip so we
+	  don't skip into the void and segfault
+
+2004-05-16  Benjamin Otte  <otte@gnome.org>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_audio_caps):
+	  Hi, I'm a memleak
+
+2004-05-16  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/asfdemux/gstasfdemux.c:
+	  - fix a mem leak and always propagate tags
+	  - add WMV3 to known video codecs (but no decoder yet)
+	  - replace "surplus data" at end of audio header for what
+	    it is : codec specific data
+	  - fix a typo
+
+2004-05-16  Arwed v. Merkatz  <v.merkatz@gmx.net>
+
+	reviewed by: Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/audio/audioclock.c:
+	  Fix wrong return type (#142205).
+
+2004-05-16  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mad/gstmad.c: (gst_mad_class_init), (gst_mad_init):
+	  Ignore CRCs by default (fixes #142566).
+
+2004-05-16  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_open),
+	(gst_alsa_mixer_close), (gst_alsa_mixer_supported),
+	(gst_alsa_mixer_build_list), (gst_alsa_mixer_free_list),
+	(gst_alsa_mixer_change_state), (gst_alsa_mixer_list_tracks),
+	(gst_alsa_mixer_get_volume), (gst_alsa_mixer_set_volume),
+	(gst_alsa_mixer_set_mute), (gst_alsa_mixer_set_record):
+	  Fix for cases where we fail to attach to a mixer.
+
+2004-05-16  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_seek):
+	  Don't touch events after not owning them anymore.
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_base_init),
+	(gst_wavparse_fmt), (gst_wavparse_other),
+	(gst_wavparse_handle_seek), (gst_wavparse_loop),
+	(gst_wavparse_pad_convert), (gst_wavparse_pad_query),
+	(gst_wavparse_srcpad_event):
+	* gst/wavparse/gstwavparse.h:
+	  Add seeking, fix querying.
+
+2004-05-16  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_comment):
+	  - process comments even if they don't end with \0\0
+            g_convert would ignore them if present and works well without them
+
+2004-05-16  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_caps), (gst_alsa_get_caps):
+	  simplify caps
+
+2004-05-16  Benjamin Otte  <otte@gnome.org>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_comment):
+	  don't write to memory we might not write to - g_convert does that
+	  for us anyway (fixes #142613)
+	(gst_asf_demux_audio_caps):
+	  comment out gst_util_dump_mem
+
+2004-05-16  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  compute correct expected timestamps after seek (broken since
+	  last commit)
+	* ext/gdk_pixbuf/pixbufscale.c: (pixbufscale_init):
+	  rename element and debugging category to gdkpixbufscale
+
+2004-05-16  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  add error checking to snd_pcm_delay and remove duplicate call to
+	  snd_pcm_delay that caused issues (see inline code comments)
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_get_time):
+	  make more readable and fix return value when snd_pcm_delay fails
+	(fixes #142586)
+
+2004-05-15  Jan Schmidt  <thaytan@mad.scientisti.com>
+	* ext/gdk_pixbuf/pixbufscale.c: (gst_pixbufscale_method_get_type),
+	(gst_pixbufscale_get_type), (gst_pixbufscale_base_init),
+	(gst_pixbufscale_class_init), (gst_pixbufscale_getcaps),
+	(gst_pixbufscale_link), (gst_pixbufscale_init),
+	(gst_pixbufscale_handle_src_event), (pixbufscale_scale),
+	(gst_pixbufscale_chain), (gst_pixbufscale_set_property),
+	(gst_pixbufscale_get_property), (pixbufscale_init):
+	* ext/gdk_pixbuf/pixbufscale.h:
+	Add these files I forgot earlier
+
+2004-05-15  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/gdk_pixbuf/Makefile.am:
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (plugin_init):
+	* ext/gdk_pixbuf/gstgdkpixbuf.h:
+	Add new pixbufscale element to scale RGB video
+	using gdk_pixbuf, because gdk_pixbuf does BILINEAR
+	and HYPER interpolation correctly.
+	* ext/theora/theoraenc.c: (theora_enc_chain),
+	Discard buffer and return if explicit caps could not be set
+	(theora_enc_get_property):
+	Make _get return kbps for the bitrate consistent with
+	the _set function.
+
+
+2004-05-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/libvisual/visual.c: (gst_visual_chain):
+	  add missing visual_audio_analyze
+
+2004-05-14  David Schleef  <ds@schleef.org>
+
+	* ext/esd/esdsink.c: (gst_esdsink_chain): Fix crash when ESD
+	is killed while we're playing.
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse): call
+	gst_element_no_more_pads().
+
+2004-05-14  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst-libs/gst/riff/riff-read.c :
+	  - fix INFO tag extraction in RIFF/AVI files
+            because gst_event_unref (event) also freed taglist
+          - avoid a mem leak
+
+2004-05-13  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/mad/gstid3tag.c : move from "Codec/(Dem/M)uxer" to "Codec/(Dem/M)uxer/Audio"
+	* gst/wavenc/gstwavenc.c : move from "Codec/Encoder/Audio" to "Codec/Muxer/Audio"
+
+	* gst/auparse/gstauparse.c :
+	  - add code (commented for now) to support audio/x-adpcm on src pad
+	    (we have no decoder for those layout yet)
+
+	* gst/cdxaparse/gstcdxaparse.c :
+	* gst/cdxaparse/gstcdxaparse.h :
+	  - partial rewrite using RiffRead (ripped iain's wavparse code)
+
+	* gst/rtp/gstrtpL16enc.c : typo
+	* gst/rtp/gstrtpgsmenc.c : typo
+
+2004-05-13  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	  check for exact version of libvisual, it's not supposed to be
+	  API/ABI stable yet
+
+2004-05-13  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_push):
+	  signal no-more-pads
+
+2004-05-13  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_src_convert)
+	Report which format was used for GST_FORMAT_DEFAULT
+	* gst/debug/Makefile.am:
+	* gst/debug/gstdebug.c: (plugin_init):
+	* gst/debug/progressreport.c: (gst_progressreport_base_init),
+	(gst_progressreport_class_init), (gst_progressreport_init),
+	(gst_progressreport_report), (gst_progressreport_set_property),
+	(gst_progressreport_get_property), (gst_progressreport_chain),
+	(gst_progressreport_plugin_init):
+	Add progressreport element for testing.
+
+2004-05-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_get), (gst_v4lsrc_change_state):
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/v4lmjpegsink_calls.c: (gst_v4lmjpegsink_playback_init):
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_capture_init):
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_capture_init),
+	(gst_v4lsrc_grab_frame):
+          add more debugging
+          send a discont at start
+
+2004-05-12  Colin Walters  <walters@redhat.com>
+
+	* gst/asfdemux/gstasfdemux.c (gst_asf_demux_process_segment): Avoid
+	inflooping if we can't find a chunk.  Or in other words, don't blow
+	chunks if we don't have a chunk to blow.
+
+2004-05-13  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/audiofile/gstafsrc.c: (gst_afsrc_get):
+	Remove old debug output
+	* ext/dv/gstdvdec.c: (gst_dvdec_quality_get_type),
+	(gst_dvdec_class_init), (gst_dvdec_loop), (gst_dvdec_change_state),
+	(gst_dvdec_set_property), (gst_dvdec_get_property):
+	Change the quality setting to an enum, so it works from gst-launch
+	Don't renegotiate a non-linked pad. Allows audio only decoding.
+	* gst/deinterlace/gstdeinterlace.c: (gst_deinterlace_getcaps),
+	(gst_deinterlace_link), (gst_deinterlace_init):
+	* gst/videodrop/gstvideodrop.c: (gst_videodrop_getcaps),
+	(gst_videodrop_link):
+	Some caps negotiation fixes
+
+2004-05-12  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/tarkin/gsttarkin.c :
+	  - Change RANK from NONE to PRIMARY
+	* ext/gdk_pixbuf/gstgdkpixbuf.c :
+	  - Change RANK from NONE to MARGINAL
+	* ext/divx/gstdivxenc.c :
+	  - Change RANK from PRIMARY to NONE (encoder/spider issue)
+
+2004-05-12  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisenc.c: (vorbis_granule_time_copy),
+	(gst_vorbisenc_push_packet):
+          copy a function that was added between 1.0 and 1.0.1 until we
+          depend on worthwhile features of post-1.0
+
+2004-05-12  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  enable shout2 by default
+	* ext/shout2/gstshout2.c: (gst_shout2send_protocol_get_type),
+	(gst_shout2send_base_init), (gst_shout2send_init),
+	(gst_shout2send_connect), (gst_shout2send_change_state):
+	* ext/shout2/gstshout2.h:
+	  make this work again. Based on a patch by Zaheer Abbas Merali (fixes
+	  #142262)
+	* ext/theora/theora.c: (plugin_init):
+	  don't set rank on encoders
+
+2004-05-11  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_audio_caps):
+	  Use codec_data property instead of flag1 and flag2 for wma
+
+2004-05-11  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/cdxaparse/gstcdxaparse.c :
+	  - Add mpegversion to CAPS to make it link
+	  - Rank is as GST_RANK_SECONDARY instead of NONE
+	* gst/auparse/gstauparse.c :
+	  - Document all audio encoding we can encounter from Solaris 9
+	    headers and libsndfile information.
+	  - Increase max. rate from 48000 to 192000 (to match other elements)
+	  - Don't try to play junk data between header and samples
+
+2004-05-11  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/libvisual/visual.c: (gst_visual_getcaps):
+	  use the right caps depending on endianness (I hope)
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_plugin_init):
+	  use GST_RANK_NONE for all non-decoding elements or spider gets
+	  mighty confused
+
+2004-05-11  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_comment):
+	  Fix some odd cases and fix BE metadata parsing of unicode16 text.
+
+2004-05-11  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/switch/gstswitch.c: (gst_switch_release_pad),
+	(gst_switch_request_new_pad), (gst_switch_poll_sinkpads),
+	(gst_switch_loop), (gst_switch_get_type):
+	  whoever that was: DO NOT IMPORT PRIVATE SYMBOLS THAT ARE NOT IN
+	  HEADERS. Had to be said.
+
+2004-05-10  David Schleef  <ds@schleef.org>
+
+	* configure.ac: Add prototype Dirac support.
+	* ext/Makefile.am:
+	* ext/dirac/Makefile.am:
+	* ext/dirac/gstdirac.cc:
+	* ext/dirac/gstdiracdec.cc:
+
+2004-05-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/auparse/gstauparse.c: (gst_auparse_class_init),
+	(gst_auparse_init), (gst_auparse_chain),
+	(gst_auparse_change_state):
+	  Hack around spider. Remove me some day please.
+
+2004-05-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/auparse/gstauparse.c: (gst_auparse_chain):
+	  Fix for some uninitialized variables in previous patch, also
+	  makes it work. Fixes #142286 while we're at it.
+
+2004-05-11  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/auparse/gstauparse.c:
+		fixes a-law, adds mu-law, linear pcm (8,16,24,32), ieee (32, 64)
+		only unsupported formats are ADPCM/CCITT G.72x
+		reviewed by Ronald
+	* gst-libs/gst/audio/audio.h: adds 24bit depth to PCM (x-raw-int)
+
+2004-05-10  Wim Taymans  <wim@fluendo.com>
+
+	* ext/vorbis/Makefile.am:
+	* ext/vorbis/README:
+	* ext/vorbis/oggvorbisenc.c: (gst_oggvorbisenc_get_formats),
+	(oggvorbisenc_get_type), (vorbis_caps_factory), (raw_caps_factory),
+	(gst_oggvorbisenc_base_init), (gst_oggvorbisenc_class_init),
+	(gst_oggvorbisenc_sinkconnect), (gst_oggvorbisenc_convert_src),
+	(gst_oggvorbisenc_convert_sink),
+	(gst_oggvorbisenc_get_query_types), (gst_oggvorbisenc_src_query),
+	(gst_oggvorbisenc_init), (gst_oggvorbisenc_get_tag_value),
+	(gst_oggvorbisenc_metadata_set1), (gst_oggvorbisenc_set_metadata),
+	(get_constraints_string), (update_start_message),
+	(gst_oggvorbisenc_setup), (gst_oggvorbisenc_write_page),
+	(gst_oggvorbisenc_chain), (gst_oggvorbisenc_get_property),
+	(gst_oggvorbisenc_set_property), (gst_oggvorbisenc_change_state):
+	* ext/vorbis/oggvorbisenc.h:
+	* ext/vorbis/vorbis.c: (plugin_init):
+	* ext/vorbis/vorbisenc.c: (vorbis_caps_factory),
+	(raw_caps_factory), (gst_vorbisenc_class_init),
+	(gst_vorbisenc_init), (gst_vorbisenc_setup),
+	(gst_vorbisenc_push_packet), (gst_vorbisenc_chain),
+	(gst_vorbisenc_get_property), (gst_vorbisenc_set_property):
+	* ext/vorbis/vorbisenc.h:
+	Added a raw vorbis encoder to be used with the oggmuxer.
+	We still need the old encoder for some gnome applications,
+	read the README to find out how that works.
+	The raw encoder is called "rawvorbisenc" until 0.9.
+
+2004-05-10  Wim Taymans  <wim@fluendo.com>
+
+	* ext/ogg/gstogg.c: (plugin_init):
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_plugin_init),
+	(gst_ogg_print):
+	* ext/ogg/gstoggmux.c: (gst_ogg_mux_get_type),
+	(gst_ogg_mux_base_init), (gst_ogg_mux_class_init),
+	(gst_ogg_mux_get_sink_event_masks), (gst_ogg_mux_init),
+	(gst_ogg_mux_sinkconnect), (gst_ogg_mux_pad_link),
+	(gst_ogg_mux_pad_unlink), (gst_ogg_mux_request_new_pad),
+	(gst_ogg_mux_handle_src_event), (gst_ogg_mux_next_buffer),
+	(gst_ogg_mux_push_page), (gst_ogg_mux_compare_pads),
+	(gst_ogg_mux_queue_pads), (gst_ogg_mux_loop),
+	(gst_ogg_mux_get_property), (gst_ogg_mux_set_property),
+	(gst_ogg_mux_change_state), (gst_ogg_mux_plugin_init):
+	Added an ogg muxer.
+	Small typo fixes in the demuxer.
+
+2004-05-10  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init),
+	(theora_enc_sink_link), (theora_push_packet), (theora_enc_chain),
+	(theora_enc_change_state), (theora_enc_set_property),
+	(theora_enc_get_property):
+	Mark the last packet with an EOS flag which is not really needed
+	in gstreamer.
+	Do some better video framerate initialisation.
+	Update the buffer timestamp.
+
+2004-05-10  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_change_state):
+	Return the result of the parent state change call
+
+2004-05-10  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* gst/law/alaw.c : alawdec should be registered with type ALAWDEC, not ALAWENC
+	* gst/law/alaw-decode.c : put audio/x-alaw on pads, instead of audio/x-mulaw
+	* gst/law/alaw-encode.c : (idem)
+	* ext/a52dec/gsta52dec.c : mark audio/a52, audio/ac3 as deprecated in a comment
+	* gst/ac3parse/gstac3parse.c : audio/ac3 => audio/x-ac3
+	* gst/realmedia/rmdemux.c : audio/a52 => audio/x-ac3
+
+2004-05-09  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_loop):
+	  don't use a fixed buffer size when writing variable length data to
+	  it. Fixes memory corruption and makes alsasrc work
+
+2004-05-09  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/gstgnomevfssink.c:
+	(_gst_boolean_allow_overwrite_accumulator),
+	(gst_gnomevfssink_class_init), (gst_gnomevfssink_open_file):
+	  Run glib's default signal handler (??) in RUN_CLEANUP rather than
+	  RUN_LAST, and don't use that to set the accumulator value because
+	  then it's always FALSE.
+
+2004-05-09  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_audio_caps),
+	(gst_riff_create_audio_template_caps):
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head):
+	  Fix for unaligned RIFF files (i.e. where all the chunks together
+	  in a LIST chunk are not of the same size as the size given in
+	  the LIST chunk header). Fixes several odd WAVE files. Also fix
+	  ADPCM (block_align property) in audio, so that wavparse based
+	  on this works now as it used to stand-alone.
+
+2004-05-09  Edward Hervey  <bilboed@bilboed.com>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* ext/a52dec/gsta52dec.c:
+	* ext/divx/gstdivxdec.c:
+	* ext/divx/gstdivxenc.c:
+	* ext/dts/gstdtsdec.c: (gst_dtsdec_base_init):
+	* ext/faac/gstfaac.c: (gst_faac_base_init):
+	* ext/faad/gstfaad.c: (gst_faad_base_init):
+	* ext/ivorbis/vorbisfile.c:
+	* ext/lame/gstlame.c:
+	* ext/libfame/gstlibfame.c:
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	* ext/musicbrainz/gsttrm.c: (gst_musicbrainz_base_init):
+	* ext/sidplay/gstsiddec.cc:
+	* ext/speex/gstspeexdec.c:
+	* ext/speex/gstspeexenc.c:
+	* ext/xvid/gstxviddec.c:
+	* ext/xvid/gstxvidenc.c:
+	  correct klasses. Mostly s,Codec/(Audio|Video),\1/Codec,
+	  (fixes #142193)
+
+2004-05-08  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (device_list),
+	(gst_alsa_class_probe_devices):
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_open):
+	  Fix alsa oddness in mixer after the combination of using mixer
+	  in source/sink elements and using hw:x,y instead of just hw:x.
+
+2004-05-09  Benjamin Otte  <otte@gnome.org>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_destroy_sourcepad),
+	(gst_wavparse_create_sourcepad):
+	  make PAUSED=>READY=>PAUSED=READY work by not destroying NULL
+	  sourcepads
+
+2004-05-09  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  allow discont events before caps nego
+
+2004-05-08  Benjamin Otte  <otte@gnome.org>
+
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event):
+	  don't leak events
+
+2004-05-08  Benjamin Otte  <otte@gnome.org>
+
+	* gst/level/gstlevel.c: (gst_level_link), (gst_level_chain),
+	(gst_level_change_state), (gst_level_init):
+	* gst/level/gstlevel.h:
+	  figure out if we're initialized directly instead of keeping a
+	  variable that's wrong in 90% of cases
+	  don't initialize pads and then leak them and use a new unitialized
+	  pad. (fixes #142084)
+	  these were bugs so n00bish I didn't find them for an hour :/
+
+2004-05-08 Iain <iain@prettypeople.org>
+
+	* gst/wavparse/gstwavparse.[ch]: Rewrote to use RiffRead instead.
+	* gst-libs/gst/riff/riff-read.c (gst_riff_read_peek_head): Unstatic it
+	(gst_riff_read_element_data): Ditto, and added a got_bytes argument to
+	return the length that was read.
+	(gst_riff_read_strf_auds): Allow fmt tags as well.
+
+2004-05-07  David Schleef  <ds@schleef.org>
+
+	* ext/faad/gstfaad.c: (gst_faad_sinkconnect): HACK to correct
+	signed char assumption in faad.h.
+
+2004-05-07  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_v4l2fourcc_to_caps):
+	  Missing break, detected by Daniel Gazard <daniel.gazard@free.fr>.
+
+2004-05-07  Colin Walters  <walters@redhat.com>
+
+	* gst/volume/gstvolume.c (gst_volume_dispose): Unref dpman.
+	* ext/flac/gstflacdec.c (gst_flacdec_dispose): Add dispose
+	function.
+	* gst/audioscale/gstaudioscale.c (gst_audioscale_dispose):
+	Add dispose function.
+
+2004-05-08  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/dv/gstdvdec.c: (gst_dvdec_video_link):
+	  Fix caps nego and pad templates. RGB mode caps should
+	  work now.
+	* ext/dvdnav/gst-dvd:
+	  Move mpeg2dec inside the thread because otherwise the
+	  queue rejects cap changes mid-stream
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_get_type),
+	(gst_mpeg2dec_flush_decoder):
+	  For mpeg2dec > 0.4.0, call the flush function instead of
+	  manually extracting all in-flight frames.
+	* ext/raw1394/gstdv1394src.c: (gst_dv1394src_factory),
+	(gst_dv1394src_init), (gst_dv1394src_iso_receive):
+	  Change mime type video/dv go video/x-dv to match the
+	  rest of gst-plugins
+
+2004-05-07  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_build_list):
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_get_type),
+	(gst_alsa_sink_class_init):
+	* ext/alsa/gstalsasink.h:
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_get_type),
+	(gst_alsa_src_class_init):
+	* ext/alsa/gstalsasrc.h:
+	  Make alsasink/src a subclass of alsamixer so that mixer stuff
+	  shows up in gst-rec. Needs some finetuning.
+
+2004-05-05  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/lame/gstlame.c: (gst_lame_chain):
+	  simplify
+	* ext/mad/gstmad.c: (gst_mad_handle_event):
+	  fix event leak
+	* gst/typefind/gsttypefindfunctions.c: (mp3_type_find):
+	  be able to detect mp3 files < 4096 bytes
+
+2004-05-06  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/theoraenc.c: (gst_theora_enc_class_init),
+	(theora_enc_sink_link), (theora_push_packet), (theora_enc_chain),
+	(theora_enc_set_property), (theora_enc_get_property):
+	Also encode the first frame, cleanup some code.
+
+2004-05-06  Wim Taymans  <wim@fluendo.com>
+
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	Forward events first before deciding that negotiation was
+	not performed.
+
+2004-05-06  Wim Taymans  <wim@fluendo.com>
+
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_chain):
+	First process the events before deciding that negotiation
+	was not performed.
+
+2004-05-06  Wim Taymans  <wim@fluendo.com>
+
+	* ext/theora/Makefile.am:
+	* ext/theora/theora.c: (plugin_init):
+	* ext/theora/theoradec.c: (theora_dec_change_state):
+	* ext/theora/theoraenc.c: (gst_theora_enc_base_init),
+	(gst_theora_enc_class_init), (gst_theora_enc_init),
+	(theora_enc_sink_link), (theora_enc_event), (theora_push_packet),
+	(theora_enc_chain), (theora_enc_change_state),
+	(theora_enc_set_property), (theora_enc_get_property):
+	Added a theora encoder, grouped the encoder and decoder into the
+	same plugin.
+
+2004-05-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_get_type),
+	(gst_jpegenc_chain):
+        fix DURATION on outgoing buffers
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_handle_sink_event):
+        debug using time formats
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support),
+	(gst_xvimagesink_sink_link):
+        windows with width/height 0 generate X errors, so don't allow them
+
+2004-05-05  Wim Taymans  <wim@fluendo.com>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (src_templ),
+	(gst_mpeg2dec_base_init), (gst_mpeg2dec_init),
+	(gst_mpeg2dec_negotiate_format):
+	* ext/mpeg2dec/gstmpeg2dec.h:
+	  removed the static pad template so that we can add the
+	  more accurate framerate value to the caps.
+
+
+2004-05-04  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	  check for kdemacros.h, too (should fix #141821)
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event), (vorbis_dec_chain):
+	  don't crash if no header was sent, but nicely error out (fixes part
+	  of #141554)
+
+2004-05-04  Wim Taymans  <wim@fluendo.com>
+
+	* ext/mpeg2enc/gstmpeg2enc.cc: (gst_mpeg2enc_dispose): call the
+	parent dispose function to avoid segfault on destroy.
+
+2004-05-04  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sink_link),
+	(plugin_init):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_sink_link):
+        clean up debugging caps
+        also recreate xvimage when format has changed
+
+2004-05-04  Benjamin Otte  <otte@gnome.org>
+
+	* ext/libvisual/Makefile.am:
+	* ext/libvisual/visual.c: (gst_visual_class_init),
+	(gst_visual_init), (gst_visual_dispose), (gst_visual_getcaps),
+	(gst_visual_srclink), (gst_visual_chain),
+	(gst_visual_change_state), (plugin_init):
+	  use a GstAdapter to correctly adapt buffer sizes - allows using a
+	  framerate
+
+2004-05-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/gstv4lelement.h:
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_class_init):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_get_fps), (gst_v4lsrc_getcaps),
+	(gst_v4lsrc_buffer_free):
+	* sys/v4l/v4l_calls.c: (gst_v4l_get_capabilities):
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_queue_frame),
+	(gst_v4lsrc_sync_frame), (gst_v4lsrc_grab_frame),
+	(gst_v4lsrc_requeue_frame):
+        move some debugging categories around
+        query for fps index and set accordingly if found
+
+2004-05-03  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/lame/gstlame.c:
+	correct defaults that lame_init puts out of range
+
+2004-05-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/divx/gstdivxenc.c: (gst_divxenc_get_type),
+	(gst_divxenc_class_init):
+        fix range since -1 is the default
+	* gst/mpeg1sys/gstmpeg1systemencode.c:
+	(gst_mpeg1_system_encode_get_type), (gst_system_encode_multiplex):
+	* gst/rtjpeg/gstrtjpegdec.c: (gst_rtjpegdec_get_type),
+	(gst_rtjpegdec_chain):
+	* gst/rtjpeg/gstrtjpegenc.c: (gst_rtjpegenc_get_type),
+	(gst_rtjpegenc_chain):
+	* sys/qcam/gstqcamsrc.c: (gst_autoexp_mode_get_type),
+	(gst_qcamsrc_get_type), (gst_qcamsrc_change_state):
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_get_type):
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_get_type):
+	* sys/v4l/gstv4lsrc.c:
+	* sys/v4l/v4l_calls.c: (gst_v4l_open):
+	* sys/v4l/v4lmjpegsink_calls.c: (gst_v4lmjpegsink_playback_init):
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_capture_init):
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_capture_init):
+	* sys/vcd/vcdsrc.c: (vcdsrc_get_type), (vcdsrc_get):
+          remove gst_info calls
+
+2004-05-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* po/af.po:
+	* po/az.po:
+	* po/en_GB.po:
+	* po/nl.po:
+	* po/sr.po:
+	* po/sv.po:
+          Updated translations
+
+2004-05-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/audioconvert/gstaudioconvert.c: (_fixate_caps_to_int):
+          refactor/comment code
+
+2004-05-02  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/Makefile.am:
+	* gst/asfdemux/asfheaders.c:
+	* gst/asfdemux/asfheaders.h:
+	* gst/asfdemux/gstasf.c: (plugin_init):
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_get_type),
+	(gst_asf_demux_base_init), (gst_asf_demux_process_comment),
+	(gst_asf_demux_setup_pad):
+	* gst/asfdemux/gstasfdemux.h:
+	* gst/asfdemux/gstasfmux.c:
+	* gst/asfdemux/gstasfmux.h:
+	  Add tagging support to demuxer, split out registration in its own
+	  file instead of in demux (hacky), and prevent having some tables
+	  in our memory multiple times (in asfheaders.h).
+
+2004-05-01  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_metadata):
+	* gst/matroska/matroska-ids.h:
+	  Basic tag reading support.
+
+2004-04-30  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_audio_caps):
+	  Really detect ac-3 audio.
+	* gst/typefind/gsttypefindfunctions.c: (matroska_type_find):
+	  really detect matroska files (off-by-1).
+
+2004-04-30  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(gst_qtdemux_add_stream), (qtdemux_parse), (qtdemux_type_get),
+	(qtdemux_dump_stsz), (qtdemux_dump_stco), (qtdemux_dump_co64),
+	(qtdemux_dump_unknown), (qtdemux_parse_tree), (qtdemux_parse_udta),
+	(qtdemux_tag_add), (get_size), (gst_qtdemux_handle_esds): More qtdemux
+	hackage -- parse a lot more atoms, extract a few tags.  One might even
+	mistake this for tag support.  Maybe it is.
+	* gst/qtdemux/qtdemux.h:
+
+2004-04-30  Colin Walters  <walters@verbum.org>
+
+	* ext/alsa/gstalsasink.c (gst_alsa_sink_mmap): Plug a memleak.
+
+2004-04-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_getcaps):
+          remove broken nego fix
+
+2004-04-30  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/libvisual/Makefile.am:
+	* ext/libvisual/visual.c:
+	  add initial support for libvisual (http://libvisual.sourceforge.net)
+	  libvisual is still quite alpha, so expect crashes in there :)
+
+2004-04-29  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_add_stream), (qtdemux_parse),
+	(qtdemux_parse_trak), (get_size), (gst_qtdemux_handle_esds): Hacked
+	up qtdemux to make it spit out codec_data.  Do _not_ look at this
+	code; you will no longer respect me.
+
+2004-04-29  Stephane Loeuillet <stephane.loeuillet@tiscali.fr>
+
+	* ext/alsa/gstalsa.c : (gst_alsa_class_probe_devices)
+	* ext/alsa/gstalsa.h :
+	change alsa pcm device discovery to find more than 1 device
+	per card. code review by Ronald.
+
+2004-04-29  David Schleef  <ds@schleef.org>
+
+	* sys/oss/gstosselement.c: (gst_osselement_rate_probe_check):
+	Add a check for a driver bug on FreeBSD.  (bug #140565)
+
+2004-04-29  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/jpeg/gstjpegdec.c: (gst_jpegdec_get_type):
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_get_type),
+	(gst_jpegenc_getcaps):
+          move format setting to inner loop
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_getcaps):
+          use GST_PAD_CAPS if available so that we use already negotiated
+          caps
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(qtdemux_parse_moov), (qtdemux_parse):
+          extra debugging
+	* sys/qcam/qcam-Linux.c: (qc_lock_wait), (qc_unlock):
+	* sys/qcam/qcam-os.c: (qc_lock_wait), (qc_unlock):
+          move hardcoded path to DEFINE
+
+2004-04-28  David Schleef  <ds@schleef.org>
+
+	* gst/speed/gstspeed.c: (speed_parse_caps):  Fix caps parsing.
+	(bug #140064)
+
+2004-04-28  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_class_probe_devices):
+	  Don't probe for playback device if we're a source element. Fixes
+	  #139658.
+
+2004-04-29  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event),
+	(gst_id3_tag_chain):
+	  rewrite buffer offset
+
+2004-04-28  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/dts/Makefile.am:
+	* ext/dts/gstdtsdec.c: (gst_dtsdec_get_type),
+	(gst_dtsdec_base_init), (gst_dtsdec_class_init), (gst_dtsdec_init),
+	(gst_dtsdec_channels), (gst_dtsdec_renegotiate),
+	(gst_dtsdec_handle_event), (gst_dtsdec_update_streaminfo),
+	(gst_dtsdec_loop), (gst_dtsdec_change_state),
+	(gst_dtsdec_set_property), (gst_dtsdec_get_property),
+	(plugin_init):
+	* ext/dts/gstdtsdec.h:
+	  New DTS decoder.
+	* ext/faad/gstfaad.c: (gst_faad_sinkconnect),
+	(gst_faad_srcconnect):
+	  Add ESDS atom handling (.m4a).
+
+2004-04-27  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c: (plugin_init):
+	  Remove comment that makes no sense.
+	* ext/mad/gstid3tag.c: (gst_id3_tag_set_property):
+	  Fix for obvious typo that resulted in warnings during gst-register.
+	* ext/xvid/gstxviddec.c: (gst_xviddec_src_link),
+	(gst_xviddec_sink_link):
+	  Fix caps negotiation a bit better.
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse_trak):
+	  We call this 'codec_data', not 'esds'.
+
+2004-04-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/monoscope/gstmonoscope.c:
+	  make sure we only provide 256x128
+	* gst/monoscope/monoscope.c: (monoscope_init):
+	  assert size of 256x128
+
+2004-04-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_init), (gst_v4lsrc_fixate),
+	(gst_v4lsrc_getcaps), (gst_v4lsrc_buffer_free):
+          fixate to max width and height of device
+
+2004-04-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* sys/v4l/gstv4l.c:
+	* sys/v4l/gstv4lsrc.c:
+	* sys/v4l/v4l_calls.c:
+	* sys/v4l/v4lsrc_calls.c:
+          fix for qc-usb driver which fakes having more than one buffer
+          by handing the same buffer twice, which confused GStreamer's/v4lsrc
+          buffer_free override
+          add debugging
+
+2004-04-27  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* gst/videotestsrc/gstvideotestsrc.c:
+	(gst_videotestsrc_class_init), (gst_videotestsrc_change_state),
+	(gst_videotestsrc_init), (gst_videotestsrc_get),
+	(gst_videotestsrc_set_property), (gst_videotestsrc_get_property):
+	* gst/videotestsrc/gstvideotestsrc.h:
+          add num-buffers property
+
+	2004-04-26  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (plugin_init):
+	  set id3mux rank to NONE so it doesn't confuse spider
+	  require audio/mpeg,mpegversion=1 in id3mux
+
+2004-04-26  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	  detect faad correctly as non-working if it's indeed non-working
+
+2004-04-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_get_type),
+	(gst_jpegenc_class_init), (gst_jpegenc_getcaps):
+        fix _getcaps so it only negotiates to its supported format
+
+2004-04-25  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (_fixate_caps_to_int):
+	  fix memleak
+
+2004-04-23  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_audio_caps):
+	  audio/x-raw-int with height rules! not. Now it's depth.
+
+2004-04-22  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_create_sourcepad),
+	(gst_wavparse_parse_fmt), (gst_wavparse_handle_sink_event),
+	(gst_wavparse_loop):
+	  Missing variable initialization. Add handling of DVI ADPCM. Fix
+	  mis-parsing of LIST chunks. This works around a bug where we mis-
+	  parse non-aligning LIST chunks (so LIST chunks where the contents
+	  don't align with the actual LIST size). The correct fix is to use
+	  rifflib, I'm not going to fix wavparse - too much work. All this
+	  fixes #104878.
+
+2004-04-22  Zaheer Abbas Merali  <zaheerabbas at merali dot org>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* ext/shout/gstshout.c: (gst_icecastsend_change_state):
+	  fix shoutcast not working (fixes #140844)
+
+2004-04-22  Benjamin Otte  <otte@gnome.org>
+
+	* ext/hermes/gsthermescolorspace.c:
+	(gst_hermes_colorspace_caps_remove_format_info):
+	* gst/colorspace/gstcolorspace.c:
+	(gst_colorspace_caps_remove_format_info):
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_caps_remove_format_info):
+	  s/gst_caps_simplify/gst_caps_do_simplify/
+
+2004-04-22  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data):
+	  mpegversion is an int
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_base_init):
+	  don't try to create pad templates with NULL caps, use any caps
+	  instead.
+
+2004-04-20  David Schleef  <ds@schleef.org>
+
+	* ext/sdl/Makefile.am: Link against libgstinterfaces, not
+	libgstxoverlay.  jmmv@menta.net (Julio M. Merino Vidal)
+	(bug #140384)
+
+2004-04-20  Daniel Gazard  <daniel.gazard@epita.fr>
+
+	reviewed by David Schleef
+
+	* ext/mad/gstid3tag.c: Add stdlib.h
+	* gst/rtp/gstrtpgsmenc.c: same
+	* gst/tags/gstid3tag.c: same
+	* gst/udp/gstudpsrc.c: (gst_udpsrc_get): Fix GST_DISABLE_LOADSAVE
+	* gst/tcp/gsttcpsink.c: (gst_tcpsink_sink_link): Adjust
+	GST_DISABLE_LOADSAVE use.
+	* gst/udp/gstudpsink.c: (gst_udpsink_sink_link): Likewise.
+	* gst/tcp/gsttcpsrc.c: (gst_tcpsrc_get): Likewise.
+	* ext/gnomevfs/gstgnomevfssrc.c: Include <stdlib.h> (needed by
+	atol(3)).
+	* sys/oss/gstosselement.h: Include <sys/types.h> (needed for dev_t).
+	* gst/tags/gstvorbistag.c: Include <stdlib.h> (needed by
+	strtoul(3)).
+	* gst/rtp/gstrtpL16enc.c: Include <stdlib.h> (needed by random(3)).
+	* ext/mad/Makefile.am: (libgstmad_la_CFLAGS): Add $(MAD_CFLAGS)
+	$(ID3_CFLAGS).
+	* ext/libfame/Makefile.am: (libgstlibfame_la_CFLAGS): Add
+	$(LIBFAME_CFLAGS).
+
+2004-04-20  David Schleef  <ds@schleef.org>
+
+	* gst/realmedia/rmdemux.c:  This was supposed to part of the
+	last checkin.  Same idea.
+
+2004-04-20  Daniel Gazard  <daniel.gazard@epita.fr>
+
+	reviewed by David Schleef
+
+	* configure.ac: bump required gstreamer version to 0.8.1.1
+	because of following changes [--ds]
+
+	* gst-libs/gst/riff/riff-read.c:  Include gst/gstutils.h.
+	(gst_riff_peek_head, gst_riff_peek_list, gst_riff_read_list)
+	(gst_riff_read_header):  Use GST_READ_UINT*
+	macros to access possibly unaligned memory.
+
+	* gst/typefind/gsttypefindfunctions.c: Include gst/gstutils.h.
+	(mp3_type_find):  Use GST_READ_UINT*
+	macros to access possibly unaligned memory.
+	(mp3_type_find, mpeg1_parse_header, qt_type_find)
+	(speex_type_find): Likewise
+
+	* gst/tags/gstvorbistag.c: (ADVANCE): Likewise
+
+	* gst/qtdemux/qtdemux.c: Include stdlib.h (needed by realloc).
+	(QTDEMUX_GUINT32_GET, QTDEMUX_GUINT16_GET, QTDEMUX_FP32_GET)
+	(QTDEMUX_FP16_GET, QTDEMUX_FOURCC_GET)
+	(gst_qtdemux_loop_header, gst_qtdemux_loop_header)
+	(qtdemux_node_dump_foreach, qtdemux_tree_get_child_by_type)
+	(qtdemux_tree_get_sibling_by_type):  Use GST_READ_UINT*
+	macros to access possibly unaligned memory.
+
+	* gst/mpegstream/gstmpegpacketize.c: (parse_generic, parse_chunk):
+	Likewise.
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead)
+	(gst_mpeg_demux_parse_packet, gst_mpeg_demux_parse_pes): Likewise.
+
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (gst_mp3parse_chain):
+	Likewise.
+
+	* gst/mpeg2sub/gstmpeg2subt.c: (GST_BUFFER_DATA)
+	(gst_mpeg2subt_chain_subtitle): Likewise.
+
+	* gst/mpeg1videoparse/gstmp1videoparse.c: (mp1videoparse_parse_seq)
+	(gst_mp1videoparse_time_code, gst_mp1videoparse_real_chain):
+	Likewise.
+
+	* gst/mpeg1sys/buffer.c: (mpeg1mux_buffer_update_audio_info):
+	Likewise.
+
+	* gst/cdxaparse/gstcdxaparse.c: (gst_bytestream_peek_bytes):
+	Likewise.
+
+	* gst/asfdemux/gstasfdemux.c: (_read_var_length, _read_uint):
+	Likewise.
+
+2004-04-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+          update required version of GStreamer because of GST_TIME_FORMAT
+
+2004-04-20  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_init):
+	  remove leftover g_print
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	  don't try setting only a subset of the caps. We don't want to kill
+	  autoplugging on purpose
+
+2004-04-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/ximage/ximagesink.c: (plugin_init):
+	* sys/xvimage/xvimagesink.c: (plugin_init):
+          add debugging categories
+
+2004-04-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/en_GB.po:
+        * po/LINGUAS:
+          Adding en_GB translation (Gareth Owen)
+
+2004-04-20  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_handle_sink_event),
+	(qtdemux_parse), (qtdemux_type_get), (qtdemux_dump_mvhd),
+	(qtdemux_dump_tkhd), (qtdemux_dump_stsd), (qtdemux_dump_unknown),
+	(qtdemux_parse_trak), (qtdemux_video_caps), (qtdemux_audio_caps):
+	A number of new features and hacks to extract the esds atom and
+	put it into the caps.  (bug #137724)
+
+2004-04-19  David Schleef  <ds@schleef.org>
+
+	* gconf/Makefile.am: Fix for non-GNU make
+	* gst-libs/gst/Makefile.am: Change directory order to handle
+	GstPlay linking with gstinterfaces
+	* gst-libs/gst/audio/make_filter: make use of tr portable
+	* gst-libs/gst/play/Makefile.am: Add intended \
+	* gst-libs/gst/xwindowlistener/xwindowlistener.c:
+	(gst_xwin_set_clips): Switch to ISO variadic macro. Use a
+	function prototype instead of void *.
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c: Switch to ISO variadic
+	macro.
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_chain): wrap NULL in GST_ELEMENT_ERROR call
+	* gst/videofilter/make_filter: make use of tr portable
+	* pkgconfig/Makefile.am: Remove GNU extension in Makefile target
+
+2004-04-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/uk.po:
+          Added Ukrainian translation (Maxim V. Dziumanenko)
+
+2004-04-18  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gsm/gstgsmdec.c: (gst_gsmdec_init), (gst_gsmdec_getcaps),
+	(gst_gsmdec_link), (gst_gsmdec_chain):
+	  Fix capsnego, simplify chain function slightly.
+	* gst/qtdemux/qtdemux.c: (qtdemux_audio_caps):
+	  Add GSM.
+
+2004-04-18  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_init),
+	(gst_wavparse_destroy_sourcepad), (gst_wavparse_create_sourcepad),
+	(gst_wavparse_parse_fmt), (gst_wavparse_change_state):
+	  Hack to make wavparse work with spider (always -> sometimes pad).
+	  Fixes #135862 && #140411.
+
+2004-04-18  Benjamin Otte  <otte@gnome.org>
+
+	* sys/oss/gstosselement.c: (gst_osselement_sync_parms),
+	(gst_osselement_rate_probe_check),
+	(gst_osselement_rate_check_rate), (gst_osselement_rate_add_rate):
+	  get rid of \n in debug output
+
+2004-04-17  Iain <iain@prettypeople.org>
+
+	* gst/wavparse/gstwavparse.c (gst_wavparse_loop): Allow all events,
+	not just EOS.
+
+2004-04-17  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_get_type),
+	(gst_id3_tag_class_init), (gst_id3_tag_get_caps),
+	(gst_id3_tag_add_src_pad), (gst_id3_tag_init),
+	(gst_id3_tag_set_property), (gst_id3_tag_do_caps_nego),
+	(gst_id3_tag_src_link), (gst_id3_tag_chain),
+	(gst_id3_tag_change_state), (plugin_init):
+	  deprecate id3tag element and replace with id3demux/id3mux.
+	  great side effect: this ugly file is now even uglier, yay!
+	* ext/mad/gstmad.h:
+	  remove non-available function
+	  update for new get_type
+
+2004-04-17  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  require mpeg2dec >= 0.4.0
+
+2004-04-17  Benjamin Otte  <otte@gnome.org>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support),
+	(gst_xvimagesink_xcontext_get), (gst_xvimagesink_change_state),
+	(gst_xvimagesink_set_xwindow_id):
+	  call GST_ELEMENT_ERROR whenever get_xcontext fails. Includes
+	  assorted cleanup fixes.
+
+2004-04-16  David Schleef  <ds@schleef.org>
+
+	* sys/ximage/ximagesink.h: Compile fix for FreeBSD. (bug #140268)
+	* sys/xvimage/xvimagesink.h: same
+
+2004-04-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_open_file):
+          Fix GST_ELEMENT_ERROR with (NULL)
+
+2004-04-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data):
+	  Add div[3456] as fourccs for DivX 3 (fixes #140137).
+
+2004-04-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c:
+	(gst_riff_create_video_caps_with_data),
+	(gst_riff_create_video_caps), (gst_riff_create_audio_caps),
+	(gst_riff_create_video_template_caps),
+	(gst_riff_create_audio_template_caps):
+	* gst-libs/gst/riff/riff-media.h:
+	* gst-libs/gst/riff/riff-read.c:
+	(gst_riff_read_strf_vids_with_data), (gst_riff_read_strf_vids):
+	* gst-libs/gst/riff/riff-read.h:
+	* gst/avi/gstavidemux.c: (gst_avi_demux_add_stream):
+	  Add MS RLE support. I added some functions to read out strf chunks
+	  into strf chunks and the data behind it. This is usually color
+	  palettes (as in RLE, but also in 8-bit RGB). Also use those during
+	  caps creation. Lastly, add ADPCM (similar to wavparse - which
+	  should eventually be rifflib based).
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_class_init),
+	(gst_matroska_demux_init), (gst_matroska_demux_reset):
+	* gst/matroska/matroska-demux.h:
+	  Remove placeholders for some prehistoric tagging system. Didn't add
+	  support for any tag system really anyway.
+	* gst/qtdemux/qtdemux.c:
+	  Add support for audio/x-m4a (MPEG-4) through spider.
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_parse_fmt),
+	(gst_wavparse_loop):
+	  ADPCM support (#135862). Increase max. buffer size because we
+	  cannot split buffers for ADPCM (screws references) and I've seen
+	  files with 2048 byte chunks. 4096 seems safe for now.
+
+2004-04-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: bump nano to 1
+
+=== release 0.8.1 ===
+
+2004-04-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: releasing 0.8.1, "Comforting Sounds"
+
+2004-04-14  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_video_caps):
+	  Fix typo in divxversion (3 instead of 4 for "DIVX" fourcc).
+	  Fixes #140058
+
+2004-04-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_plugin_init):
+          lower rank of dvddemux so that it's not used for mpeg playback.
+
+2004-04-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  save libs correctly when checking mad
+
+2004-04-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mad/gstid3tag.c: (plugin_init):
+          lower rank of id3tag as proposed by Benjamin.  Fixes #139926.
+
+2004-04-13  David Schleef  <ds@schleef.org>
+
+	* common/m4/gst-feature.m4: Call -config scripts with
+	--plugin-libs if it is supported.
+	* gst/avi/gstavimux.c: (gst_avimux_vidsinkconnect): sequences of
+	JPEG images are image/jpeg.
+	* gst/debug/Makefile.am:
+	* gst/debug/negotiation.c: (gst_negotiation_class_init),
+	(gst_negotiation_getcaps), (gst_negotiation_pad_link),
+	(gst_negotiation_update_caps), (gst_negotiation_get_property),
+	(gst_negotiation_plugin_init): Add a property that acts like
+	filter caps.
+	* testsuite/gst-lint:  Move license checking to be a standard
+	test.
+
+2004-04-13  David Schleef  <ds@schleef.org>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_reset): Fix memleak.
+	patch from Sebastien Cote (bug #139958)
+
+2004-04-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* examples/gstplay/Makefile.am:
+	* examples/gstplay/player.c: (main):
+          make the commandline player example use gconf settings
+
+2004-04-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/libcaca/gstcacasink.c: (gst_cacasink_class_init),
+	(gst_cacasink_sinkconnect), (gst_cacasink_init),
+	(gst_cacasink_chain), (gst_cacasink_open), (gst_cacasink_close):
+          init/end library during state transition, not object
+          creation/disposal.  get rid of custom dispose handler.
+
+
+2004-04-12  Christian Schaller <Uraeus@gnome.org>
+
+	* sys/oss/gstosselement.c: s/lstat/stat/ from freeBSD, since it can
+	be a symlink
+
+2004-04-11  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_data):
+	  Handle JUNK chunks inside data section. Prevents warnings.
+
+2004-04-11  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_video_caps),
+	(gst_riff_create_video_template_caps):
+	  Add MS video v1.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_index),
+	(gst_avi_demux_stream_data):
+	  Add support for "rec-list" chunks.
+
+2004-04-11  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_audio_caps):
+	  Fix another codecname mismatch.
+
+2004-04-11  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_video_caps):
+	  Fix divx caps mismatch and move from video/x-jpeg to image/jpeg
+	  so that MJPEG plays back.
+
+2004-04-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpeg1videoparse/gstmp1videoparse.c: (gst_mp1videoparse_init),
+	(gst_mp1videoparse_real_chain), (gst_mp1videoparse_change_state):
+	* gst/mpeg1videoparse/gstmp1videoparse.h:
+	  Fix for some slight mis-cuts in buffer parsing, and for some
+	  potential overflows or faults-causers. Adds disconts. Also fixes
+	  #139105 while we're at it.
+
+2004-04-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* sys/v4l2/gstv4l2element.h:
+	  Workaround for missing struct v4l2_buffer declaration in Suse 9
+	  and Mandrake 10 linux/videodev2.h header file (#135919).
+
+2004-04-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_open_file):
+	  Bail out if no filename was given.
+
+2004-04-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_v4l2fourcc_to_caps),
+	(gst_v4l2_fourcc_from_structure):
+	  Add Y41B/Y42B YUV formats (see #125732), fix Y41P (was typo'ed to
+	  Y41B somewhere).
+
+2004-04-09  Benjamin Otte  <otte@gnome.org>
+
+	* ext/gnomevfs/gstgnomevfssink.c:
+	(_gst_boolean_allow_overwrite_accumulator),
+	(gst_gnomevfssink_class_init):
+	  fix erase signal - if any handler returns false the file will not be
+	  overwritten. If no handler is connected, the file will not be
+	  overwritten either.
+	  renamed signal to "allow-overwrite"
+	* ext/mad/gstid3tag.c: (tag_list_to_id3_tag_foreach):
+	  free string when adding it to ID3 failed
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event):
+	  unref event when done
+	* gst/audioconvert/gstaudioconvert.c: (_fixate_caps_to_int):
+	  free caps
+	* gst/typefind/gsttypefindfunctions.c:
+	(mpeg_video_stream_type_find):
+	  fix invalid read
+
+2004-04-08  David Schleef  <ds@schleef.org>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_register): Change rank to PRIMARY.
+
+2004-04-08  David Schleef  <ds@schleef.org>
+
+	* gst/colorspace/gstcolorspace.c: Don't advertise a conversion
+	we don't support (bug #139532)
+
+2004-04-07  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mad/gstmad.c: (gst_mad_handle_event),
+	(gst_mad_check_caps_reset), (gst_mad_chain),
+	(gst_mad_change_state):
+          only set explicit caps if they haven't been set before for
+          this stream.  MPEG-audio sample rate/channels aren't allowed
+          to change in-stream.
+          Fixes #139382
+
+2004-04-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_base_init),
+	(_gst_boolean_did_something_accumulator),
+	(gst_gnomevfssink_class_init), (gst_gnomevfssink_dispose),
+	(gst_gnomevfssink_init), (gst_gnomevfssink_set_property),
+	(gst_gnomevfssink_get_property), (gst_gnomevfssink_open_file),
+	(gst_gnomevfssink_close_file), (gst_gnomevfssink_chain),
+	(gst_gnomevfssink_change_state):
+	  Fix erase signal. Don't erase by default. Remove handoff signal.
+	  Remove erase property. Don't segfault. General cleanup.
+
+2004-04-07  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/gconf/test-gconf.c: (main):
+	  add missing gst_init
+
+2004-04-07  Benjamin Otte  <otte@gnome.org>
+
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_dispose):
+	  free the mutexes, too
+
+2004-04-07  Benjamin Otte  <otte@gnome.org>
+
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_dispose):
+	  actually free the URI string
+	* ext/mad/gstid3tag.c: (gst_id3_tag_src_event):
+	  compute offset correctly when passing discont events
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event):
+	  don't leak discont events
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_video_caps):
+	  add some missing breaks so caps aren't copied randomly
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_get_video_stream):
+	  if we realloc memory, we better use it
+
+2004-04-06  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstmad.c: (normal_seek):
+	  fix GST_FORMAT_TIME usage
+
+2004-04-05  David Schleef  <ds@schleef.org>
+
+	* ext/kio/kiosrc.cpp:  Undefine KDE_DEPRECATED so we can use
+	a deprecated function (hack!)
+
+2004-04-05  Benjamin Otte  <otte@gnome.org>
+
+	* ext/esd/esdmon.c: (gst_esdmon_get):
+	  fix nonterminated vararg and memleak
+
+2004-04-05  Benjamin Otte  <otte@gnome.org>
+
+	* ext/ladspa/gstladspa.c: (gst_ladspa_class_init),
+	(gst_ladspa_init), (gst_ladspa_force_src_caps),
+	(gst_ladspa_set_property), (gst_ladspa_get_property),
+	(gst_ladspa_instantiate), (gst_ladspa_activate),
+	(gst_ladspa_deactivate), (gst_ladspa_loop), (gst_ladspa_chain):
+	  clean up debugging
+
+2004-04-05  Stefan Kost <kost@imn.htwk-leipzig.de>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* ext/ladspa/gstladspa.c: (gst_ladspa_class_init):
+	  check for broken LADSPA parameters (fixes #138635)
+
+2004-04-05  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_getcaps):
+	  advertise buffer-frames correctly on sinkpads
+
+2004-04-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mad/gstmad.c: (gst_mad_get_type), (gst_mad_layer_get_type),
+	(gst_mad_mode_get_type), (gst_mad_emphasis_get_type),
+	(gst_mad_get_event_masks), (gst_mad_get_query_types), (index_seek),
+	(normal_seek), (gst_mad_src_event), (gst_mad_handle_event),
+	(gst_mad_check_caps_reset), (gst_mad_chain):
+        add more debugging, only reset caps when we're not in error state
+
+2004-04-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mad/gstmad.c: add debugging category, comment + cleanups
+
+2004-04-05  Julio M. Merino Vidal  <jmmv@menta.net>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	  fix == in test(1) operator
+
+2004-04-05  Julio M. Merino Vidal  <jmmv@menta.net>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	  fix --export-symblos-regex to a working regex.
+
+2004-04-04  Benjamin Otte  <otte@gnome.org>
+
+	* sys/oss/.cvsignore:
+	  add for oss_probe
+
+2004-04-03  Tim-Phillip Müller <t.i.m@zen.co.uk>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event):
+	  add missing 'new_media' argument (fixes #138168)
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_handle_seek_event):
+	  add vararg terminator (fixes #138169)
+
+2004-04-02  David Schleef  <ds@schleef.org>
+
+	* ext/gdk_pixbuf/Makefile.am:  Make sure gstgdkanimation.h is
+	disted (bug #138914)
+
+2004-04-01  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state),
+	(gst_alsa_close_audio):
+	  handle case better where a soundcard can't pause
+	* ext/ogg/gstoggdemux.c:
+	  don't crash when we get events but don't have pads yet
+
+2004-04-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/oss/gstosselement.c: (gst_osselement_probe_caps):
+          throw an error if we couldn't probe any caps.
+
+2004-04-01  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dvdnav/gst-dvd:
+	Add a really simple sample DVD player
+
+2004-04-01  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_get_type), (gst_a52dec_init),
+	(gst_a52dec_push), (gst_a52dec_handle_event),
+	(gst_a52dec_update_streaminfo), (gst_a52dec_loop),
+	(gst_a52dec_change_state):
+	* ext/a52dec/gsta52dec.h:
+	  Use a debug category, Output timestamps correctly
+	  Emit tag info, Handle events, tell liba52dec about cpu
+	  capabilities so it can use MMX etc.
+	* ext/dv/gstdvdec.c: (gst_dvdec_loop), (gst_dvdec_change_state):
+	  Fix a crasher accessing invalid memory
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_init),
+	(dvdnavsrc_update_highlight), (dvdnavsrc_loop),
+	(dvdnavsrc_get_event_mask), (dvdnav_handle_navigation_event),
+	(dvdnavsrc_event), (dvdnavsrc_get_formats), (dvdnavsrc_convert),
+	(dvdnavsrc_query):
+	  Some support for byte-format seeking.
+	  Small fixes for still frames and menu button overlays
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_get_type),
+	(gst_mpeg2dec_alloc_buffer):
+	  Use a debug category. Adjust the report level of several items to
+	  LOG. Call mpeg2_custom_fbuf to mark our buffers as 'custom buffers'
+	  so it doesn't lose the GstBuffer pointer
+	* gst/debug/Makefile.am:
+	* gst/debug/gstdebug.c: (plugin_init):
+	* gst/debug/gstnavseek.c: (gst_navseek_get_type),
+	(gst_navseek_base_init), (gst_navseek_class_init),
+	(gst_navseek_init), (gst_navseek_seek),
+	(gst_navseek_handle_src_event), (gst_navseek_set_property),
+	(gst_navseek_get_property), (gst_navseek_chain),
+	(gst_navseek_plugin_init):
+	* gst/debug/gstnavseek.h:
+	  Add the navseek debug element for seeking back and forth in a
+	  video stream using arrow keys.
+	* gst/mpeg2sub/gstmpeg2subt.c: (gst_mpeg2subt_get_type),
+	(gst_mpeg2subt_base_init), (gst_mpeg2subt_class_init),
+	(gst_mpeg2subt_init), (gst_mpeg2subt_finalize),
+	(gst_mpeg2subt_getcaps_video), (gst_mpeg2subt_link_video),
+	(gst_mpeg2subt_handle_video), (gst_mpeg2subt_src_event),
+	(gst_mpeg2subt_parse_header), (gst_get_nibble),
+	(gst_setup_palette), (gst_get_rle_code), (gst_draw_rle_line),
+	(gst_merge_uv_data), (gst_mpeg2subt_merge_title),
+	(gst_update_still_frame), (gst_mpeg2subt_handle_subtitle),
+	(gst_mpeg2subt_handle_dvd_event), (gst_mpeg2subt_loop):
+	* gst/mpeg2sub/gstmpeg2subt.h:
+	  Pretty much a complete rewrite. Now a loopbased element. May still
+	  require work to properly synchronise subtitle buffers.
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_process_private),
+	(gst_dvd_demux_send_subbuffer):
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_send_subbuffer):
+	  Don't attempt to create subbuffers of size 0
+	  Reduce a couple of error outputs to warnings.
+	* gst/y4m/gsty4mencode.c: (gst_y4mencode_sinkconnect),
+	(gst_y4mencode_chain):
+	Output the y4m frame header correctly.
+
+2004-04-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/adder/gstadder.c: (gst_adder_get_type), (gst_adder_loop):
+          throw errors instead of allowing SIGFPE
+
+2004-04-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/gconf/gconf.c: (gst_gconf_get_string),
+	(gst_gconf_render_bin_from_key):
+          leak plugging and style fixing
+
+2004-03-31  David Schleef  <ds@schleef.org>
+
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_expand_value),
+	(gst_audioscale_getcaps): Fix getcaps to expand and union lists.
+	(bug #138225)
+	* gst/debug/Makefile.am:
+	* gst/debug/breakmydata.c: (gst_break_my_data_plugin_init):
+	* gst/debug/gstdebug.c: (plugin_init):  Merge elements into one
+	plugin.
+	* gst/debug/negotiation.c: (gst_gst_negotiation_get_type),
+	(gst_negotiation_base_init), (gst_negotiation_class_init),
+	(gst_negotiation_init), (gst_negotiation_getcaps),
+	(gst_negotiation_pad_link), (gst_negotiation_chain),
+	(gst_negotiation_set_property), (gst_negotiation_get_property),
+	(gst_negotiation_plugin_init):  New element to talk about random
+	negotiation things happening in a pipeline.
+
+2004-03-31  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/adder/gstadder.c: (gst_adder_get_type), (gst_adder_loop):
+          fix integer addition with help of Stefan Kost
+
+2004-03-31  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/nl.po: updated Dutch translation (Elros Cyriatan)
+
+2004-03-30  David Schleef  <ds@schleef.org>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_alloc_buffer),
+	(gst_mpeg2dec_negotiate_format):  Handle Y42B-format MPEG
+	video, patch from Matthew.Spencer@eu.sony.com (Matthew Spencer)
+	(bug #137504)
+	* ext/mpeg2dec/gstmpeg2dec.h:
+
+2004-03-30  David Schleef  <ds@schleef.org>
+
+	* ext/gdk_pixbuf/Makefile.am: Remove spurious rules. (bug #136527)
+
+2004-03-30  David Schleef  <ds@schleef.org>
+
+	* tools/gst-launch-ext-m.m:  Applied patch from gnome@flyn.org (W.
+	Michael Petullo) to handle .mov
+
+2004-03-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/oss/gstosselement.c: (gst_osselement_probe_caps),
+	(gst_osselement_rate_check_rate):
+	  probe caps correctly for sound cards that only support one format
+
+2004-03-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/kio/kiosrc.cpp: (process_events):
+	  update handling event processing if inside KDE - untested
+
+2004-03-29  David Schleef  <ds@schleef.org>
+
+	* ext/hermes/gsthermescolorspace.c: (plugin_init): decrease rank
+	by 2 to not interfere with other colorspaces.
+	* ext/pango/gsttextoverlay.c: (plugin_init): change rank to NONE
+	* gst/colorspace/gstcolorspace.c: (plugin_init): decrease rank by
+	one to not interfere with ffmpeg_colorspace.
+
+2004-03-29  David Schleef  <ds@schleef.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_fixate): Don't fixate fields that
+	aren't in the caps.
+	* gst/sine/gstsinesrc.c: change rate caps to [1,MAX]
+	* gst/videocrop/gstvideocrop.c: (plugin_init): Change rank to NONE.
+
+2004-03-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/riff/riff-media.c:
+	  fail on error, don't try to set stuff on NULL caps
+
+2004-03-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/kio/Makefile.am:
+	* ext/kio/kioreceiver.cpp:
+	* ext/kio/kioreceiver.h:
+	* ext/kio/kiosrc.cpp:
+	* ext/kio/kiosrc.h:
+	  add experimental kiosrc plugin
+	* ext/alsa/gstalsaplugin.c: (plugin_init):
+	  initialize debugging category only when we're sure registering the
+	  plugins worked.
+
+2004-03-29  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* examples/gstplay/player.c: (main):
+	* gst-libs/gst/play/play.c: (gst_play_class_init),
+	(gst_play_set_location), (gst_play_set_data_src),
+	(gst_play_set_video_sink), (gst_play_set_audio_sink),
+	(gst_play_set_visualization), (gst_play_connect_visualization):
+          check return values of element_set_state and return FALSE where
+          failed
+
+2004-03-29  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event):
+	  try harder to check if an event is really a discont
+
+2004-03-29  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS: adding Azerbaijani (Mətin Əmirov)
+	* po/az.po:
+
+2004-03-28  Benjamin Otte  <otte@gnome.org>
+
+	* gst/mpegstream/gstdvddemux.c: (gst_dvd_demux_process_private):
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead),
+	(gst_mpeg_demux_parse_packet), (gst_mpeg_demux_parse_pes):
+	  get rid of non-standard "..." ranges in case statements.
+
+2004-03-27  Martin Soto  <martinsoto@users.sourceforge.net>
+
+	* gst/mpegstream/gstmpegdemux.c:
+	* gst/mpegstream/gstmpegdemux.h: Complete overhaul. All DVD
+	specific functionality split to the new dvddemux element.
+	* gst/mpegstream/gstdvddemux.c:
+	* gst/mpegstream/gstdvddemux.h: New demultiplexer for DVD (VOB)
+	streams, derived from mpegdemux.
+	* gst/mpegstream/gstmpegparse.c: Discontinuity handling cleaned
+	up. SCR based timestamp rewriting can be turned off (will probably
+	completely disappear soon).
+	* ext/dvdnav/dvdnavsrc.c: Changes resulting from a few months
+	hacking. General cleanup. All printf statements replaced by
+	debugging messages. Almost complete libdvdnav support.
+	(dvdnavsrc_class_init): Got rid of unnecessary signals (replaced
+	by events. New properties for audio and subpicture languages.
+	(dvdnavsrc_update_highlight): Now uses events.
+	(dvdnavsrc_user_op): Cleaned up.
+	(dvdnavsrc_get): Renamed to dvdnavsrc_loop (element is now loop
+	based). Lots of cleanup, and propper support for most libdvdnav
+	events.
+	(dvdnavsrc_make_dvd_event): New function.
+	(dvdnavsrc_make_dvd_nav_packet_event): New function.
+	(dvdnavsrc_make_clut_change_event): New function.
+
+2004-03-26  Benjamin Otte  <otte@gnome.org>
+
+	* gst/typefind/gsttypefindfunctions.c: (theora_type_find):
+	  fix bug where typefinding would claim it's theora whenever less then
+	  7 bytes of data were available
+
+2004-03-25  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/law/alaw-decode.c: (alawdec_getcaps), (alawdec_link),
+	(gst_alawdec_base_init), (gst_alawdec_class_init),
+	(gst_alawdec_init), (gst_alawdec_chain):
+	* gst/law/alaw-encode.c: (alawenc_getcaps), (alawenc_link),
+	(gst_alawenc_base_init), (gst_alawenc_class_init),
+	(gst_alawenc_init), (gst_alawenc_chain):
+	* gst/law/mulaw-decode.c: (mulawdec_getcaps), (mulawdec_link),
+	(gst_mulawdec_base_init), (gst_mulawdec_class_init),
+	(gst_mulawdec_init), (gst_mulawdec_chain):
+	* gst/law/mulaw-encode.c: (mulawenc_getcaps), (mulawenc_link),
+	(gst_mulawenc_base_init), (gst_mulawenc_class_init),
+	(gst_mulawenc_init), (gst_mulawenc_chain):
+	  Fix capsnego in all four, remove the unused property functions and
+	  simplify the chain functions slightly. I guess we could use macros
+	  or something similar for those, since the code is so similar, but
+	  I'm currently too lazy...
+
+2004-03-24  David Schleef  <ds@schleef.org>
+
+	* sys/oss/gstosselement.c: (gst_osselement_sync_parms),
+	(gst_osselement_close_audio), (gst_osselement_probe_caps),
+	(gst_osselement_get_format_structure),
+	(gst_osselement_rate_probe_check), (gst_osselement_rate_add_range),
+	(gst_osselement_rate_check_rate), (gst_osselement_rate_add_rate),
+	(gst_osselement_rate_int_compare): Add code to handle rate probing
+	(bug #120883)
+	* sys/oss/gstosselement.h: same
+	* sys/oss/gstosssink.c: (gst_osssink_init), (gst_osssink_getcaps):
+	Use rate probing provided by osselement.
+	* sys/oss/gstosssrc.c: (gst_osssrc_init), (gst_osssrc_getcaps): same
+
+2004-03-24  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/xvid/gstxvidenc.c: (gst_xvidenc_set_property),
+	(gst_xvidenc_get_property):
+	  ulong/int mess-up.
+
+2004-03-24  David Schleef  <ds@schleef.org>
+
+	* ext/speex/gstspeexdec.c: (gst_speexdec_base_init),
+	(gst_speexdec_init):
+	* ext/speex/gstspeexenc.c: (gst_speexenc_base_init),
+	(gst_speexenc_init):  Create the pad template correctly (from
+	the static pad template, not a NULL pointer.)
+
+2004-03-25  Benjamin Otte  <otte@gnome.org>
+
+	* gst/debug/Makefile.am:
+	* gst/debug/breakmydata.c:
+	  add element that quasi-randomly changes bytes in the stream.
+	  Intended use is robustness checking of demuxers and decoders in
+	  media tests.
+
+2004-03-24  Benjamin Otte  <otte@gnome.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_open_audio),
+	(gst_alsa_probe_hw_params):
+	* ext/alsa/gstalsa.h:
+	  debugging output fixes
+
+2004-03-24  Benjamin Otte  <otte@gnome.org>
+
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_set_property):
+	  don't g_return_if_fail if element is PLAYING, fail silently as every
+	  other element.
+	* gst/effectv/gstquark.c: (gst_quarktv_chain):
+	  only fix needed for cast lvalue issues in gst-plugins
+	* gst/volenv/gstvolenv.c: (gst_volenv_init):
+	  add proxy_getcaps
+
+2004-03-24  Benjamin Otte  <otte@gnome.org>
+
+	* gst/level/gstlevel.c: (gst_level_init):
+	  add proxying getcaps function, so level doesn't advertise impossible
+	  caps
+
+2004-03-24  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_handle_sink_event),
+	(gst_qtdemux_loop_header), (qtdemux_parse_moov), (qtdemux_parse),
+	(qtdemux_node_dump_foreach), (qtdemux_dump_mvhd),
+	(qtdemux_dump_tkhd), (qtdemux_dump_elst), (qtdemux_dump_mdhd),
+	(qtdemux_dump_hdlr), (qtdemux_dump_vmhd), (qtdemux_dump_dref),
+	(qtdemux_dump_stsd), (qtdemux_dump_stts), (qtdemux_dump_stss),
+	(qtdemux_dump_stsc), (qtdemux_dump_stsz), (qtdemux_dump_stco),
+	(qtdemux_dump_co64), (qtdemux_dump_dcom), (qtdemux_dump_cmvd),
+	(qtdemux_parse_tree), (qtdemux_parse_trak):  Fix debugging
+	messages.  Divide the chunk size by the compression ratio
+	(needed for MACE audio)
+
+2004-03-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (gst_mp3parse_chain):
+	  Fix buffer overflow read error.
+
+2004-03-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.h:
+	  Remove unused entry.
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_video_caps):
+	  Add cinepak.
+	* gst/videodrop/gstvideodrop.c: (gst_videodrop_getcaps),
+	(gst_videodrop_link), (gst_videodrop_chain):
+	  Fix, sort of. Was horribly broken with new capsnego. Bah...
+
+2004-03-23  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* gst/typefind/gsttypefindfunctions.c: (ape_type_find),
+	(plugin_init):
+	Add a monkeysaudio typefind function
+
+2004-03-23  Johan Dahlin  <johan@gnome.org>
+
+	* gst-libs/gst/play/play.c (gst_play_audio_fixate)
+	(gst_play_video_fixate): Check so the structure has the field
+	before trying to fixate them, this makes it possible to have
+	fakesinks for video and audio output without printing errors on
+	the output console.
+
+2004-03-22  David Schleef  <ds@schleef.org>
+
+	* sys/oss/Makefile.am:
+	* sys/oss/oss_probe.c: (main), (probe_check), (add_range),
+	(check_rate), (add_rate):  Rate probing test app.
+
+2004-03-21  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link),
+	(_fixate_caps_to_int), (gst_audio_convert_fixate):
+	  add a fixation function that pretty much does the right thing (fixes
+	  #137556)
+
+2004-03-20  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* configure.ac: GST_PACKAGE default: s/GStreamer/GStreamer Plugins/
+
+2004-03-20  Tim-Phillip Müller <t.i.m@zen.co.uk>
+
+	reviewed by: Benjamin Otte  <otte@gnome.org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	  terminate gst_event_new_discontinuous correctly (fixes parts of
+	  #137711)
+
+2004-03-19  David Schleef  <ds@schleef.org>
+
+	* gst-libs/gst/Makefile.am:  Enable xoverlay unconditionally,
+	since it doesn't depend on X, and it's part of our ABI.
+
+2004-03-19  Iain <iain@prettypeople.org>
+
+	* gst/interleave/deinterleave.c (deinterleave_sink_link): Use the
+	is_int in the structure, not the local variable.
+
+2004-03-19  David Schleef  <ds@schleef.org>
+
+	* ext/librfb/gstrfbsrc.c: (gst_rfbsrc_change_state),
+	(gst_rfbsrc_init), (gst_rfbsrc_getcaps), (gst_rfbsrc_fixate),
+	(gst_rfbsrc_link), (gst_rfbsrc_paint_rect), (gst_rfbsrc_get):
+	Improvements in caps negotiation.
+
+2004-03-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/af.po:
+          adding Afrikaans (Petri Jooste)
+
+2004-03-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_chain):
+        throw error instead of g_critical (#137588)
+
+2004-03-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am:
+	* configure.ac:
+          dist common and m4 correctly
+	* po/sv.po:
+
+2004-03-17  David Schleef  <ds@schleef.org>
+
+	* pkgconfig/gstreamer-media-info.pc.in:  Add Version.
+	(bug #137348)
+
+2004-03-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/sv.po:
+          adding Swedish translation (Christian Rose)
+
+2004-03-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* Makefile.am: use release.mak
+
+2004-03-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* common/ChangeLog:
+	* common/gst-autogen.sh:
+          add some explanation about the version detection
+	* configure.ac:
+          fix X check
+
+2004-03-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: bump nano to 1
+
+=== release 0.8.0 ===
+
+2004-03-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: release 0.8.0, "Pharmaceutical Itch"
+
+2004-03-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+          update libtool version
+	* gst-libs/gst/media-info/Makefile.am:
+          actually use libtool version
+
+2004-03-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: fix speex detection to work with 1.0 but not 1.1
+
+2004-03-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* gst-plugins.spec.in:
+	* pkgconfig/Makefile.am:
+	* pkgconfig/gstreamer-gconf-uninstalled.pc.in:
+	* pkgconfig/gstreamer-interfaces-uninstalled.pc.in:
+	* pkgconfig/gstreamer-libs-uninstalled.pc.in:
+	* pkgconfig/gstreamer-libs.pc.in:
+	* pkgconfig/gstreamer-media-info-uninstalled.pc.in:
+	* pkgconfig/gstreamer-play-uninstalled.pc.in:
+	* pkgconfig/gstreamer-plugins-uninstalled.pc.in:
+	* pkgconfig/gstreamer-plugins.pc.in:
+          remove @VERSION@ from some of the pc files since core and plugins
+          are decoupled.
+          created gstreamer-plugins.pc as it's a better name, but keeping
+          -libs around for now to get fixes upstream done first.
+
+2004-03-15  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/play/play.c: (gst_play_get_framerate),
+	(gst_play_get_sink_element): First draft of gst_play_get_framerate.
+	* gst-libs/gst/play/play.h:
+
+2004-03-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* *.c, *.cc: don't mix tabs and spaces
+
+2004-03-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/play.c: (gst_play_pipeline_setup):
+          use the new ffmpegcolorspace
+	* gst-plugins.spec.in:
+          package new colorspace and media-info
+	* configure.ac:
+	* pkgconfig/Makefile.am:
+          fix some more disting issues
+	* pkgconfig/gstreamer-media-info-uninstalled.pc.in:
+	* pkgconfig/gstreamer-media-info.pc.in:
+          generate media-info pc files
+
+2004-03-15  Johan Dahlin  <johan@gnome.org>
+
+	* *.h: Revert indenting
+
+2004-03-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+          adding ffmpegcolorspace element
+	* gst/ffmpegcolorspace/Makefile.am:
+	* gst/ffmpegcolorspace/avcodec.h:
+	* gst/ffmpegcolorspace/common.h:
+	* gst/ffmpegcolorspace/dsputil.c: (dsputil_static_init):
+	* gst/ffmpegcolorspace/dsputil.h:
+	* gst/ffmpegcolorspace/gstffmpeg.c: (plugin_init):
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.c:
+	(gst_ffmpeg_pixfmt_to_caps), (gst_ffmpeg_pix_fmt_to_caps),
+	(gst_ffmpeg_caps_to_pix_fmt):
+	* gst/ffmpegcolorspace/gstffmpegcodecmap.h:
+	* gst/ffmpegcolorspace/gstffmpegcolorspace.c:
+	(gst_ffmpegcolorspace_caps_remove_format_info),
+	(gst_ffmpegcolorspace_getcaps), (gst_ffmpegcolorspace_pad_link),
+	(gst_ffmpegcolorspace_get_type), (gst_ffmpegcolorspace_base_init),
+	(gst_ffmpegcolorspace_class_init), (gst_ffmpegcolorspace_init),
+	(gst_ffmpegcolorspace_chain), (gst_ffmpegcolorspace_change_state),
+	(gst_ffmpegcolorspace_set_property),
+	(gst_ffmpegcolorspace_get_property),
+	(gst_ffmpegcolorspace_register):
+	* gst/ffmpegcolorspace/imgconvert.c:
+	(avcodec_get_chroma_sub_sample), (avcodec_get_pix_fmt_name),
+	(avcodec_get_pix_fmt), (avpicture_fill), (avpicture_layout),
+	(avpicture_get_size), (avcodec_get_pix_fmt_loss),
+	(avg_bits_per_pixel), (avcodec_find_best_pix_fmt1),
+	(avcodec_find_best_pix_fmt), (img_copy_plane), (img_copy),
+	(yuv422_to_yuv420p), (yuv422_to_yuv422p), (yuv422p_to_yuv422),
+	(C_JPEG_TO_CCIR), (img_convert_init), (img_apply_table),
+	(shrink41), (shrink21), (shrink12), (shrink22), (shrink44),
+	(grow21_line), (grow41_line), (grow21), (grow22), (grow41),
+	(grow44), (conv411), (gif_clut_index), (build_rgb_palette),
+	(bitcopy_n), (mono_to_gray), (monowhite_to_gray),
+	(monoblack_to_gray), (gray_to_mono), (gray_to_monowhite),
+	(gray_to_monoblack), (avpicture_alloc), (avpicture_free),
+	(is_yuv_planar), (img_convert), (get_alpha_info_pal8),
+	(img_get_alpha_info), (deinterlace_line),
+	(deinterlace_line_inplace), (deinterlace_bottom_field),
+	(deinterlace_bottom_field_inplace), (avpicture_deinterlace):
+	* gst/ffmpegcolorspace/imgconvert_template.h:
+	* gst/ffmpegcolorspace/mem.c: (av_malloc), (av_realloc), (av_free):
+	* gst/ffmpegcolorspace/mmx.h:
+	* gst/ffmpegcolorspace/utils.c: (avcodec_init):
+          adding ffmpegcolorspace element supplied by Ronald after cleaning
+          up and pulling in the right bits of upstream source.
+          I'm sure a better C/compiler wizard could do some cleaning up (for
+          example use GLIB's malloc stuff), but as a first pass this
+          works very well
+
+2004-03-15  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/alsa/gstalsa.h:
+	  I assume Ronald forgot to commit the change to have cardname
+          as a struct member.  Expect some public spanking at the next
+          opportunity.
+
+2004-03-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_property),
+	(gst_alsa_open_audio), (gst_alsa_close_audio):
+	* ext/alsa/gstalsa.c:
+	  Don't open the device if we're a mixer (= padless).
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_class_init),
+	(gst_alsa_mixer_init), (gst_alsa_mixer_open),
+	(gst_alsa_mixer_close), (gst_alsa_mixer_change_state):
+	  Open mixer during state change rather than during object
+	  initialization. Also, get a device name. Currently in a somewhat
+	  hackish fashion, but I didn't really find something better.
+
+2004-03-14  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* *.c, *.h: run gst-indent
+
+2004-03-14  Benjamin Otte  <otte@gnome.org>
+
+	* gst/modplug/gstmodplug.cc:
+	* gst/modplug/gstmodplug.h:
+	  set correct timestamps on outgoing buffers
+
+2004-03-14  Benjamin Otte  <otte@gnome.org>
+
+	* gst/modplug/gstmodplug.cc:
+	  handle events - don't do crap when a discont arrives that's not
+	  necessary
+	  This allows correct loading and playback of mods in Rhythmbox
+
+2004-03-14  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	* gst-libs/gst/gconf/Makefile.am:
+	* pkgconfig/Makefile.am:
+	  move gstreamer-gconf pkgconfig files to pkgconfig/ dir. Make sure
+	  they get rebuilt properly
+	* configure.ac:
+	  when checking for vorbis, try pkgconfig first.
+	* gst/modplug/gstmodplug.cc:
+	  add fixate function
+
+2004-03-14  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse_trak):
+	  Fix for obvious mistake, where we first shift the offset and then
+	  read a samplesize element assuming the old offset. Note that this
+	  part still has something weird, i.e. my movies containing those
+	  don't actually play well, but at least there's something that looks
+	  like sound now.
+
+2004-03-14  Jan Schmidt  <thaytan@mad.scientist.com>
+	* gst/typefind/gsttypefindfunctions.c: (speex_type_find),
+	(plugin_init):
+	Add a typefind function for speex format
+
+2004-03-13  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_video_caps),
+	(gst_asf_demux_setup_pad):
+	  Use 25fps as our "fake" fps value (marked for fixage in 0.9.x)
+	  instead of 0. Reason is simple: some elements have a fps range
+	  of 1-max instead of 0-max. So now ASF video actually works.
+
+2004-03-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* po/LINGUAS:
+	* po/sr.po:
+	  adding serbian as a language
+
+2004-03-13  Benjamin Otte  <otte@gnome.org>
+
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_get):
+	  return taglist correctly from _get function, don't gst_pad_push it.
+	  (fixes #137042)
+
+2004-03-13  Jan Schmidt  <thaytan@mad.scientist.com>
+	* ext/alsa/gstalsa.c: (gst_alsa_class_probe_devices):
+
+2004-03-13  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_free_list):
+	* ext/alsa/gstalsamixertrack.c: (gst_alsa_mixer_track_class_init),
+	(gst_alsa_mixer_track_new):
+	* ext/alsa/gstalsamixertrack.h:
+	  Fix ancient leftovers... MixerTrack is a GObject.
+
+2004-03-13  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_class_probe_devices):
+	* sys/oss/gstosselement.c: (gst_osselement_class_probe_devices):
+	  Don't block during probing...
+
+2004-03-12  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_type), (gst_alsa_class_init),
+	(gst_alsa_get_property), (gst_alsa_probe_get_properties),
+	(gst_alsa_class_probe_devices), (gst_alsa_class_list_devices),
+	(gst_alsa_probe_probe_property), (gst_alsa_probe_needs_probe),
+	(gst_alsa_probe_get_values), (gst_alsa_probe_interface_init),
+	(gst_alsa_open_audio), (gst_alsa_close_audio):
+	* ext/alsa/gstalsa.h:
+	  Add propertyprobe interface implementation, add some device-name
+	  property, all this so that it looks good in gnome-volume-control.
+
+2004-03-12  David Schleef  <ds@schleef.org>
+
+	* configure.ac: the Hermes library controls hermescolorspace, not
+	colorspace.
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_base_init),
+	(gst_mpeg2dec_init): minor pet peeve: disable code with #ifdef,
+	not /* */
+	* ext/sdl/sdlvideosink.c: Change XID to unsigned long.
+	* ext/sdl/sdlvideosink.h: ditto.
+	* gst/colorspace/gstcolorspace.c: Fix old comments about Hermes
+
+2004-03-12  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/xoverlay/xoverlay.c: (gst_x_overlay_set_xwindow_id),
+	(gst_x_overlay_got_xwindow_id):
+	* gst-libs/gst/xoverlay/xoverlay.h:
+	  replace XID with unsigned long to get rid of the xlibs dependency in
+	  XOverlay (fixes #137004)
+
+2004-03-13  Jan Schmidt  <thaytan@mad.scientist.com>
+	* gst/effectv/gstaging.c: (gst_agingtv_base_init),
+	(gst_agingtv_setup):
+	* gst/effectv/gstdice.c: (gst_dicetv_get_type),
+	(gst_dicetv_base_init), (gst_dicetv_class_init),
+	(gst_dicetv_setup), (gst_dicetv_init), (gst_dicetv_draw):
+	* gst/effectv/gstedge.c: (gst_edgetv_get_type),
+	(gst_edgetv_base_init), (gst_edgetv_class_init), (gst_edgetv_init),
+	(gst_edgetv_setup), (gst_edgetv_rgb32):
+	* gst/effectv/gsteffectv.c:
+	* gst/effectv/gstquark.c: (gst_quarktv_link), (gst_quarktv_init),
+	(gst_quarktv_set_property):
+	* gst/effectv/gstrev.c: (gst_revtv_get_type),
+	(gst_revtv_base_init), (gst_revtv_class_init), (gst_revtv_init),
+	(gst_revtv_setup), (gst_revtv_rgb32):
+	* gst/effectv/gstshagadelic.c: (gst_shagadelictv_get_type),
+	(gst_shagadelictv_base_init), (gst_shagadelictv_class_init),
+	(gst_shagadelictv_init), (gst_shagadelictv_setup),
+	(gst_shagadelictv_rgb32):
+	* gst/effectv/gstvertigo.c: (gst_vertigotv_get_type),
+	(gst_vertigotv_base_init), (gst_vertigotv_class_init),
+	(gst_vertigotv_setup), (gst_vertigotv_init), (gst_vertigotv_rgb32):
+	* gst/effectv/gstwarp.c:
+	Port everything that can be ported to videofilter and fix up the caps.
+	Can someone with a big-endian machine please check these?
+
+2004-03-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosssink.c: (gst_osssink_init), (gst_osssink_get_time),
+	(gst_osssink_chain), (gst_osssink_change_state):
+	  Latest fixes for A/V sync, audio playback and such. This is about
+	  all... MPEG playback issues are mostly related to the async build-
+	  up of MPEG files, I cannot fix that. Use basicgthread to solve it.
+
+2004-03-10  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	patch from: Stephane Loeuillet
+
+	* configure.ac:
+	  use pkg-config for some libraries, falling back to the old .m4 way
+          (fixes #131270)
+	* m4/libdv.m4:
+          removed
+
+2004-03-10  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* tools/Makefile.am:
+	* tools/Makefile.in:
+	* tools/gst-launch-ext-m.m:
+	* tools/gst-launch-ext.1.in:
+	* tools/gst-visualise-m.m:
+	* tools/gst-visualise.1:
+	* tools/gst-visualise.1.in:
+          reorganizing generation of script tools
+
+2004-03-10  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c:
+	  Downgrade priority. We prefer ffdec_mpeg4.
+	* ext/faad/gstfaad.c: (gst_faad_srcgetcaps), (gst_faad_srcconnect),
+	(gst_faad_chain), (gst_faad_change_state):
+	  Fix capsnego. Doesn't work for some sounds because we don't have
+	  a 5:1 to stereo element.
+	* ext/xvid/gstxvid.c: (plugin_init):
+	  Add priority.
+	* sys/oss/gstosssink.c: (gst_osssink_init), (gst_osssink_chain),
+	(gst_osssink_change_state):
+	  Add discont handling.
+
+2004-03-09  Colin Walters  <walters@verbum.org>
+
+	* gst/audioconvert/gstaudioconvert.c: Fix typo in width 8
+	conversion.
+
+2004-03-09  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/mixer/mixer.c: (gst_mixer_class_init):
+	  the signals take 2 arguments
+
+2004-03-09  David Schleef  <ds@schleef.org>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_request_new_pad),
+	(gst_alsa_fixate): Add fixate function.  (bug #136686)
+	* ext/alsa/gstalsa.h:
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_init):
+
+2004-03-09  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mikmod/gstmikmod.c: (gst_mikmod_init), (gst_mikmod_loop),
+	(gst_mikmod_change_state):
+	* ext/mikmod/gstmikmod.h:
+	  make mikmod's loop function not loop infinitely and call
+	  gst_element_yield anymore
+	* gst/modplug/gstmodplug.cc:
+	  fix pad negotiation (fixes #136590)
+
+2004-03-09  David Schleef  <ds@schleef.org>
+
+	* ext/lcs/Makefile.am:  Fix so that the lcs colorspace plugin
+	doesn't conflict with the internal colorspace plugin.
+	* gst-libs/gst/audio/make_filter:  Use `` instead of $() to
+	satisfy the crappy-ass shell shipped by a certain vendor.
+	* gst/videofilter/make_filter: same (bug #135299)
+
+2004-03-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: bump nano to 1
+
+=== release 0.7.6 ===
+
+2004-03-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.in: releasing 0.7.6, "There"
+
+2004-03-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* pkgconfig/gstreamer-play-uninstalled.pc.in:
+	* pkgconfig/gstreamer-play.pc.in:
+          synchronize the two
+
+2004-03-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_base_init),
+	(cdparanoia_open), (cdparanoia_event):
+	  fix/add error handling
+	* po/POTFILES.in:
+	  add cdparanoia source
+	* tools/Makefile.am:
+	  make scripts executable
+
+2004-03-09  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* ext/vorbis/Makefile.am:
+	* sys/Makefile.am:
+	  remove id3types, vorbisfile and xvideosink from the build (#133783)
+
+2004-03-08  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_info):
+	  Fix metadata read crash (#136537).
+
+2004-03-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/media-info/media-info-priv.c: (gmi_set_mime):
+	* gst-libs/gst/media-info/media-info.c: (gst_media_info_read):
+          adding mime types, fixing the one-stop function
+
+2004-03-08  Christian Schaller <Uraeus@gnome.org>
+
+	* ext/nas/nassink.c and /ext/nas/nassink.h:
+	More NAS love from Arwed von Merkatz
+	So lets all sing 'Can you feel the NAS tonight'
+
+2004-03-08  Christian Schaller <Uraeus@gnome.org>
+
+	* tools/gst-launch-ext.in:
+	Replace vorbisfile with oggdemux/vorbisdec/audioconvert
+
+2004-03-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_base_init),
+	(gst_mpeg2dec_init):
+        remove the user_data pad for now, because it is being used in
+        fixating causing MPEG playback to fixate on 1000 Hz for playback.
+        If someone knows how to fix this properly, please do.
+
+2004-03-08  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/oss/gstosssink.c: (gst_osssink_get_delay),
+	(gst_osssink_get_time):
+        add a warning, IMO this won't get triggered anymore, remove later
+
+2004-03-07  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (qtdemux_video_caps):  Added Cinepak
+	format (bug #136470)
+
+2004-03-07  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/Makefile.am:
+	* gst-libs/gst/media-info/Makefile.am:
+	* gst-libs/gst/media-info/media-info-priv.c: (found_tag_callback),
+	(error_callback), (gst_media_info_error_create),
+	(gst_media_info_error_element), (gmip_init), (gmip_reset),
+	(gmi_clear_decoder), (gmip_find_type_pre), (gmip_find_type):
+	* gst-libs/gst/media-info/media-info-priv.h:
+	* gst-libs/gst/media-info/media-info-test.c: (main):
+	* gst-libs/gst/media-info/media-info.c: (gst_media_info_init),
+	(gst_media_info_class_init), (gst_media_info_instance_init),
+	(gst_media_info_set_source), (gst_media_info_read_with_idler),
+	(gst_media_info_read_idler), (gst_media_info_read):
+	* gst-libs/gst/media-info/media-info.h:
+	fixed, should work now
+
+2004-03-07  Christian Schaller <Uraeus@gnome.org>
+
+	* ext/nas/nassink.c:
+	A bunch of NAS fixes from Arwed von Merkatz
+
+2004-03-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_add_stream),
+	(qtdemux_parse_trak):
+	  Fix crash (j might be greater than n_samples, in which case we're
+	  writing outside the allocated space for the array) and memleak.
+
+2004-03-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosssink.c: (gst_osssink_chain):
+	  And another caller that couldn't handle delay < 0 (unsigned
+	  integer overflow). Video now continues playing on an audio
+	  buffer underrun, and the clock continues working. Audio still
+	  stalls.
+
+2004-03-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosssink.c: (gst_osssink_get_delay),
+	(gst_osssink_get_time):
+	  get_delay() may return values lower than 0. In those cases, we
+	  should not actually cast to *unsigned* int64, that will break
+	  stuff horribly. In my case, it screwed up A/V sync in movies
+	  in totem rather badly.
+
+2004-03-06  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/faac/gstfaac.c: (gst_faac_chain):
+	* ext/flac/gstflactag.c: (gst_flac_tag_chain):
+	* ext/libpng/gstpngenc.c: (user_write_data):
+	* ext/mikmod/gstmikmod.c: (gst_mikmod_loop):
+	* gst/ac3parse/gstac3parse.c: (gst_ac3parse_chain):
+	* gst/mpeg2sub/gstmpeg2subt.c: (gst_mpeg2subt_chain_subtitle):
+	* gst/mpegstream/gstrfc2250enc.c: (gst_rfc2250_enc_add_slice):
+	Fix several misuse of gst_buffer_merge (it doesn't take ownership
+	of any buffer), should fix some leaks. I hope I didn't unref buffers
+	that shouldn't be...
+
+2004-03-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/media-info/media-info-priv.c: (have_type_callback),
+	(deep_notify_callback), (tag_flag_score), (found_tag_callback),
+	(error_callback), (gmi_reset), (gmi_seek_to_track),
+	(gmi_get_decoder), (gmi_set_mime), (gmip_find_type_pre),
+	(gmip_find_type_post), (gmip_find_stream_post),
+	(gmip_find_track_streaminfo_post):
+	* gst-libs/gst/media-info/media-info-priv.h:
+	* gst-libs/gst/media-info/media-info-test.c: (print_tag),
+	(info_print), (main):
+	* gst-libs/gst/media-info/media-info.c:
+	(gst_media_info_error_create), (gst_media_info_error_element),
+	(gst_media_info_instance_init), (gst_media_info_get_property),
+	(gst_media_info_new), (gst_media_info_set_source),
+	(gst_media_info_read_idler), (gst_media_info_read):
+	* gst-libs/gst/media-info/media-info.h:
+          first pass at making this work again.  This seems to work on
+          tagged ogg/vorbis and mp3 files.
+
+2004-03-06  Benjamin Otte  <otte@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_chain):
+	  fix huge leak: gst_buffer_merge doesn't unref the first argument
+	  itself.
+
+2004-03-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mad/gstmad.c: (gst_mad_class_init), (gst_mad_update_info):
+          report layer/mode/emphasis
+
+2004-03-06  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/mad/gstmad.c: (gst_mad_chain): fixed caps leak
+
+2004-03-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_new):
+          signal serial
+
+2004-03-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbis.c: (plugin_init):
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_get_formats),
+	(gst_vorbis_dec_init), (vorbis_dec_event):
+        add debug category
+        make vorbisdec handle _BYTE and _TIME queries
+
+2004-03-06  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/mad/gstmad.c: (gst_mad_chain): send the average bitrate read
+	  from the xing header
+
+2004-03-06  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_getcaps),
+	(gst_audio_convert_link), (gst_audio_convert_change_state),
+	(gst_audio_convert_buffer_from_default_format):
+	  do conversions from/to float correctly, fix some caps nego errors,
+	  export correct supported caps in template and getcaps, use correct
+	  caps in try_set_caps functions
+
+2004-03-06  Christophe Fergeau  <teuf@gnome.org>
+
+	For some reason, I only committed a ChangeLog entry yesterday and
+	not the corresponding code...
+	* ext/mad/gstmad.c: Fix detection of Xing headers
+	* gst/tags/gstid3tag.c: Changes to support TLEN tags
+
+2004-03-06  Benjamin Otte  <otte@gnome.org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_get_pad_by_pad),
+	(gst_ogg_demux_src_query):
+	  make sure to handle the case where there's no current chain
+	  gracefully.
+
+2004-03-05  David Schleef  <ds@schleef.org>
+
+	* ext/aalib/gstaasink.c: (gst_aasink_fixate), (gst_aasink_init):
+	Add fixate function. (bug #131128)
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_init),
+	(gst_sdlvideosink_fixate):  Add fixate function.
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	Fix attempt to print a non-pointer using GST_PTR_FORMAT.
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_parse_fmt):
+	Fix missing break that was causing ulaw to be interpreted as
+	raw int.
+
+2004-03-05  David Schleef  <ds@schleef.org>
+
+	* gst/mpegstream/gstrfc2250enc.c: (gst_rfc2250_enc_add_slice):
+	Fix code that ignores return value of gst_buffer_merge().
+	(bug #114560)
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_descramble_segment):
+	* gst/mpegstream/gstrfc2250enc.c: (gst_rfc2250_enc_add_slice): same
+	* testsuite/gst-lint:  Check for above.
+
+2004-03-05  David Schleef  <ds@schleef.org>
+
+	* gst/udp/gstudpsrc.c: (gst_udpsrc_get):  Check for unfixed
+	caps and throw an element error.  (bug #136334)
+
+2004-03-05  David Schleef  <ds@schleef.org>
+
+	* ext/faad/gstfaad.c: (gst_faad_init), (gst_faad_srcgetcaps),
+	(gst_faad_chain): Fix negotiation.
+	* ext/librfb/gstrfbsrc.c: (gst_rfbsrc_handle_src_event): Add
+	key and button events.
+	* gst-libs/gst/floatcast/floatcast.h: Fix a minor bug in this
+	dung heap of code.
+	* gst-libs/gst/gconf/gstreamer-gconf-uninstalled.pc.in: gstgconf
+	depends on gconf
+	* gst-libs/gst/gconf/gstreamer-gconf.pc.in: same
+	* gst-libs/gst/play/play.c: (gst_play_pipeline_setup),
+	(gst_play_video_fixate), (gst_play_audio_fixate): Add a fixate
+	function to encourage better negotiation, particularly between
+	audioconvert and osssink.
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_chain):
+	* gst/qtdemux/qtdemux.c: (qtdemux_parse_trak):  Make some debugging
+	more important.
+	* gst/typefind/gsttypefindfunctions.c:  Fix mistake in flash
+	typefinding.
+	* gst/vbidec/vbiscreen.c:  Add glib header
+	* pkgconfig/gstreamer-play.pc.in:  Depends on gst-interfaces.
+
+2004-03-06  Christophe Fergeau  <teuf@users.sourceforge.net>
+
+	* ext/mad/gstmad.c: Fix detection of Xing headers
+	* gst/tags/gstid3tag.c: Changes to support TLEN tags
+
+2004-03-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_parse_fmt),
+	(gst_wavparse_pad_convert), (gst_wavparse_pad_query):
+          debug updates
+
+2004-03-06  Christophe Fergeau  <teuf@gnome.org>
+
+	* ext/mad/gstid3tag.c: (gst_mad_id3_to_tag_list):
+	* ext/mad/gstmad.c: (gst_mad_init), (is_xhead),
+	(mpg123_parse_xing_header), (gst_mad_chain): parse Xing header in vbr
+	files, and report the parsed length as a GST_TAG_DURATION tag.
+	* gst/tags/gstid3tag.c: support TLEN (duration) tag
+
+2004-03-05  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_channels):
+	  convert channels correctly. convert correctly to unsigned.
+
+2004-03-05  Julien MOUTTE <julien@moutte.net>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_change_state): Check if
+	we have a window before clearing it.
+
+2004-03-05  Julien MOUTTE <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_change_state): Check if we
+	have a window before clearing it.
+
+2004-03-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gconf/gstreamer.schemas.in:
+	* gst-libs/gst/gconf/Makefile.am:
+          version installation path the same way as for 0.6
+	* pkgconfig/gstreamer-interfaces-uninstalled.pc.in:
+	* pkgconfig/gstreamer-libs-uninstalled.pc.in:
+	* pkgconfig/gstreamer-play-uninstalled.pc.in:
+          remove comment that was fixed
+
+2004-03-05  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_get_src_formats),
+	(gst_qtdemux_src_convert), (gst_qtdemux_get_src_query_types),
+	(gst_qtdemux_get_event_mask), (gst_qtdemux_handle_src_query),
+	(gst_qtdemux_handle_src_event), (gst_qtdemux_add_stream):
+	Add prototype code for handling seeking and querying.
+
+2004-03-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* examples/gstplay/player.c: (main):
+	  Initialize variables to NULL. Prevents a segfault because the
+	  (uninitialized) variable is not NULL, resulting in a crash on
+	  trying to reach error->message.
+
+2004-03-05  Benjamin Otte  <otte@gnome.org>
+
+	* gst/audioconvert/gstaudioconvert.c:
+	(gst_audio_convert_buffer_to_default_format):
+	make float=>int conversion work correctly even in cornercases.
+
+2004-03-04  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* debian/README.Debian:
+	* debian/build-deps:
+	* debian/changelog:
+	* debian/control:
+	* debian/control.in:
+	* debian/copyright:
+	* debian/gstreamer-a52dec.files:
+	* debian/gstreamer-aa.files:
+	* debian/gstreamer-alsa.files:
+	* debian/gstreamer-alsa.manpages:
+	* debian/gstreamer-arts.files:
+	* debian/gstreamer-artsd.files:
+	* debian/gstreamer-audiofile.files:
+	* debian/gstreamer-avifile.files:
+	* debian/gstreamer-cdparanoia.files:
+	* debian/gstreamer-colorspace.files:
+	* debian/gstreamer-doc.files:
+	* debian/gstreamer-dv.files:
+	* debian/gstreamer-dvd.files:
+	* debian/gstreamer-esd.files:
+	* debian/gstreamer-festival.files:
+	* debian/gstreamer-flac.files:
+	* debian/gstreamer-gconf.conffiles:
+	* debian/gstreamer-gconf.files:
+	* debian/gstreamer-gconf.postinst:
+	* debian/gstreamer-gnomevfs.files:
+	* debian/gstreamer-gsm.files:
+	* debian/gstreamer-http.files:
+	* debian/gstreamer-jack.files:
+	* debian/gstreamer-jpeg.files:
+	* debian/gstreamer-mad.files:
+	* debian/gstreamer-mikmod.files:
+	* debian/gstreamer-misc.files:
+	* debian/gstreamer-mpeg2dec.files:
+	* debian/gstreamer-oss.files:
+	* debian/gstreamer-plugin-apps.files:
+	* debian/gstreamer-plugin-apps.manpages:
+	* debian/gstreamer-plugin-libs-dev.files:
+	* debian/gstreamer-plugin-libs.files:
+	* debian/gstreamer-plugin-template.postinst:
+	* debian/gstreamer-plugin-template.postrm:
+	* debian/gstreamer-sdl.files:
+	* debian/gstreamer-sid.files:
+	* debian/gstreamer-vorbis.files:
+	* debian/gstreamer-x.files:
+	* debian/mk.control:
+	* debian/rules:
+	Debian package info not maintained here.
+
+2004-03-04  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/aalib/gstaasink.c: (gst_aasink_class_init):
+	* ext/cdaudio/gstcdaudio.c: (gst_cdaudio_class_init):
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_class_init):
+	* ext/divx/gstdivxenc.c: (gst_divxenc_class_init):
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_class_init):
+	* ext/gsm/gstgsmenc.c: (gst_gsmenc_class_init):
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_class_init):
+	* ext/musicbrainz/gsttrm.c: (gst_musicbrainz_class_init):
+	* ext/speex/gstspeexenc.c: (gst_speexenc_class_init):
+	* ext/xvid/gstxvidenc.c: (gst_xvidenc_class_init):
+	* gst-libs/gst/colorbalance/colorbalance.c:
+	(gst_color_balance_class_init):
+	* gst-libs/gst/colorbalance/colorbalancechannel.c:
+	(gst_color_balance_channel_class_init):
+	* gst-libs/gst/mixer/mixer.c: (gst_mixer_class_init):
+	* gst-libs/gst/play/play.c: (gst_play_class_init):
+	* gst-libs/gst/propertyprobe/propertyprobe.c:
+	(gst_property_probe_iface_init):
+	* gst-libs/gst/tuner/tuner.c: (gst_tuner_class_init):
+	* gst-libs/gst/tuner/tunerchannel.c:
+	(gst_tuner_channel_class_init):
+	* gst-libs/gst/xoverlay/xoverlay.c: (gst_x_overlay_base_init):
+	* gst/cutter/gstcutter.c: (gst_cutter_class_init):
+	* gst/effectv/gstvertigo.c: (gst_vertigotv_class_init):
+	* sys/cdrom/gstcdplayer.c: (cdplayer_class_init):
+	* sys/dxr3/dxr3spusink.c: (dxr3spusink_class_init):
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_class_init):
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_class_init):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_class_init):
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_class_init):
+          fix signals to use - instead of _
+	* ext/libcaca/gstcacasink.h:
+	* ext/sdl/sdlvideosink.h:
+          fix header rename
+
+2004-03-04  David Schleef  <ds@schleef.org>
+
+	* testsuite/gst-lint:  Add a check for bad signal names.
+
+2004-03-04  <kost@imn.htwk-leipzig.de>
+
+	reviewed by David Schleef
+
+	* gst/videofilter/gstgamma.c: (gst_gamma_rgb32): Fix typo that
+	modified the alpha channel and caused a warning. (bug #136192)
+
+2004-04-03  Christian Schaller <Uraeus@gnome.org>
+
+	* gst-plugins.spec.in:
+	Change names of plugins to actually be correct. Try to keep things
+	alphabetical to avoid getting beat up by Thomas
+
+2004-03-03  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/gconf/gconf.c: (gst_gconf_get_default_video_sink):
+	Using ximagesink as a default if no gconf key found. We should
+	probably consider using alsasink instead of osssink for the audio
+	part.
+
+2004-03-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	  fix --with-plugins, don't think it ever worked before
+	* gst-plugins.spec.in:
+          even more updates
+
+2004-03-01  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/sdl/sdlvideosink.h:
+	* sys/ximage/ximagesink.h:
+	* sys/xvideo/xvideosink.h:
+	* sys/xvimage/xvimagesink.h:
+	  Fix for move of gstvideosink.h -> videosink.h.
+
+2004-03-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/xwindowlistener/Makefile.am:
+	  this is a plugin library, not a library
+
+2004-03-01  David Schleef  <ds@schleef.org>
+
+	* AUTHORS:  Added some names.  Add yourself if you're still
+	missing.
+
+2004-03-01  David Schleef  <ds@schleef.org>
+
+	* MAINTAINERS: Add
+
+2004-03-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-plugins.spec.in: clean up spec file
+
+2004-03-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/video/Makefile.am:
+	* gst-libs/gst/video/gstvideosink.c:
+	* gst-libs/gst/video/gstvideosink.h:
+          rename gstvideosink.h to videosink.h to match other headers
+	* gst/mixmatrix/Makefile.am:
+          fix plugin filename
+	* gst/tags/Makefile.am: fix plugin filename
+
+2004-03-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/tags/Makefile.am: fix plugin filename
+
+2004-03-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* examples/gstplay/player.c: (got_time_tick), (main):
+	  add error handler
+          display time_tick more readably
+	* gst/mixmatrix/Makefile.am:
+          fix plugin file name
+
+2004-02-29  Christophe Fergeau  <teuf@gnome.org>
+
+	* sys/oss/gstosselement.c: (gst_osselement_probe),
+	(device_combination_append), (gst_osselement_class_probe_devices):
+	* sys/oss/gstosselement.h:
+	  Reworked enumeration of oss dsps and mixers so that gst-mixer works
+	  on my system using alsa oss emulation, fixes bug #135597
+
+2004-02-29  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/videodrop/gstvideodrop.c: (gst_videodrop_init),
+	(gst_videodrop_chain), (gst_videodrop_change_state):
+	* gst/videodrop/gstvideodrop.h:
+	  Work based on timestamp of input data, not based on the expected
+	  framerate from the input. The consequence is that this element now
+	  not only scales framerates, but also functions as a framerate
+	  corrector or framerate stabilizer/constantizer.
+
+2004-02-27  David Schleef  <ds@schleef.org>
+
+	patches from jmmv@menta.net (Julio M. Merino Vidal)
+
+	* gst/interleave/deinterleave.c: (deinterleave_chain): Fix
+	GST_ELEMENT_ERROR call (bug #135634)
+	* gst/interleave/interleave.c: (interleave_buffered_loop),
+	(interleave_bytestream_loop): Don't use alloca() (bug #135640)
+	* sys/cdrom/gstcdplayer_ioctl_bsd.h: Fix ioctls on NetBSD (bug #135645)
+	* sys/oss/gstosssink.c: (gst_osssink_get_delay),
+	(gst_osssink_chain): Fix ioctls on NetBSD. (bug #135644)
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_sync_next_frame),
+	(gst_v4lmjpegsrc_set_capture), (gst_v4lmjpegsrc_set_capture_m),
+	(gst_v4lmjpegsrc_capture_init), (gst_v4lmjpegsrc_requeue_frame):
+	Fix GST_ELEMENT_ERROR call.
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_try_palette): Fix
+	GST_ELEMENT_ERROR call.
+
+2004-02-27  Benjamin Otte  <otte@gnome.org>
+
+	* gst-libs/gst/audio/audio.h:
+	  add macro to make sure header isn't included twice
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_chunk):
+	  don't use gst_buffer_free
+	* gst/playondemand/filter.func:
+	  don't use gst_data_free. Free data only once.
+
+2004-02-26  David Schleef  <ds@schleef.org>
+
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/tuner/Makefile.am:
+	* gst/level/Makefile.am: -marshal.[ch] and -enum.[ch] files
+	should not be disted, -marshal.h files should not be installed,
+	and -enum.h files _should_ be installed.  Fix to make this the
+	case.
+
+=== release 0.7.5 ===
+
+2004-02-26  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: release 0.7.5, "Under The Sea"
+
+2004-02-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link),
+	(gst_audio_convert_change_state), (gst_audio_convert_get_buffer):
+	* gst/videoscale/gstvideoscale.c:
+	* sys/oss/gstosselement.c: (gst_osselement_sync_parms):
+          assorted debug/warning fixes
+
+2004-02-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_getcaps),
+	(gst_videoscale_init), (gst_videoscale_chain),
+	(gst_videoscale_set_property), (plugin_init):
+	* gst/videoscale/gstvideoscale.h:
+	* gst/videoscale/videoscale.c: (gst_videoscale_setup),
+	(gst_videoscale_scale_rgb), (gst_videoscale_planar411),
+	(gst_videoscale_planar400), (gst_videoscale_packed422),
+	(gst_videoscale_packed422rev), (gst_videoscale_32bit),
+	(gst_videoscale_24bit), (gst_videoscale_16bit),
+	(gst_videoscale_bilinear), (gst_videoscale_bicubic),
+	(gst_videoscale_scale_plane_slow),
+	(gst_videoscale_scale_point_sample),
+	(gst_videoscale_scale_nearest),
+	(gst_videoscale_scale_nearest_str2),
+	(gst_videoscale_scale_nearest_str4),
+	(gst_videoscale_scale_nearest_32bit),
+	(gst_videoscale_scale_nearest_24bit),
+	(gst_videoscale_scale_nearest_16bit):
+        add debugging category and use it properly
+        fix use of GST_PTR_FORMAT
+
+2004-02-25  Andy Wingo  <wingo@pobox.com>
+
+	* gst/interleave/interleave.c (interleave_buffered_loop): Always
+	push only when channel->buffer is NULL. Prevents segfaults doing
+	the state change after a nonlocal exit, like a scheme exception.
+
+	* gst/audioconvert/gstaudioconvert.c (gst_audio_convert_getcaps):
+	Handle the case where the intersected caps is empty.
+
+2004-02-25  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/law/mulaw-decode.c: (mulawdec_link):
+	* gst/law/mulaw.c: (plugin_init):
+          fix mulawdec so it actually works again
+
+2004-02-24  Arwed v. Merkatz  <v.merkatz@gmx.net>
+
+	reviewed by: David Schleef  <ds@schleef.org>
+
+	* gst/videofilter/gstgamma.c: (gst_gamma_class_init),
+	(gst_gamma_init), (gst_gamma_set_property),
+	(gst_gamma_get_property), (gst_gamma_calculate_tables),
+	(gst_gamma_rgb24), (gst_gamma_rgb32):  Adds gamma correction
+	for RGB, with separate r g and b correction factors. (#131167)
+
+2004-02-24  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_chain):
+          only signal tags for bitrate if they're > 0 (#134894)
+
+2004-02-24  David Schleef  <ds@schleef.org>
+
+	* gst/qtdemux/qtdemux.c: (plugin_init), (gst_qtdemux_loop_header),
+	(qtdemux_parse_moov), (qtdemux_parse), (qtdemux_node_dump_foreach),
+	(qtdemux_dump_mvhd), (qtdemux_dump_tkhd), (qtdemux_dump_elst),
+	(qtdemux_dump_mdhd), (qtdemux_dump_hdlr), (qtdemux_dump_vmhd),
+	(qtdemux_dump_dref), (qtdemux_dump_stsd), (qtdemux_dump_stts),
+	(qtdemux_dump_stss), (qtdemux_dump_stsc), (qtdemux_dump_stsz),
+	(qtdemux_dump_stco), (qtdemux_dump_co64), (qtdemux_dump_dcom),
+	(qtdemux_dump_cmvd), (qtdemux_parse_tree), (qtdemux_parse_trak):
+	Cleanups.  Convert g_prints to GST_LOGs.  Add qtdemux debug
+	category.  Attempt to fix timestamp calculation.
+
+2004-02-24  Johan Dahlin  <johan@gnome.org>
+
+	* gst-libs/gst/gconf/gconf.c: Add \n to g_print error messages
+
+2004-02-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* gconf/Makefile.am:
+	* gconf/gstreamer.schemas:
+	* gst-libs/gst/gconf/Makefile.am:
+	* gst-libs/gst/gconf/gconf.c:
+          version gconf schemas and install locations
+
+2004-02-23  Benjamin Otte  <otte@gnome.org>
+
+	* ext/xine/xineinput.c: (gst_xine_input_dispose):
+	(gst_xine_input_subclass_init):
+	  call parent dispose.
+	  change pad template for CD reader correctly
+	* ext/xine/Makefile.am:
+	* ext/xine/gstxine.h:
+	* ext/xine/xine.c: (plugin_init):
+	* ext/xine/xineaudiosink.c:
+	  wrap audio sinks, too
+	* gst-libs/gst/resample/private.h:
+	* gst-libs/gst/resample/resample.c: (gst_resample_init),
+	(gst_resample_reinit), (gst_resample_scale),
+	(gst_resample_nearest_s16), (gst_resample_bilinear_s16),
+	(gst_resample_sinc_slow_s16), (gst_resample_sinc_s16),
+	(gst_resample_sinc_ft_s16), (gst_resample_nearest_float),
+	(gst_resample_bilinear_float), (gst_resample_sinc_slow_float),
+	(gst_resample_sinc_float), (gst_resample_sinc_ft_float):
+	* gst-libs/gst/resample/resample.h:
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_method_get_type),
+	(gst_audioscale_class_init), (gst_audioscale_link),
+	(gst_audioscale_get_buffer), (gst_audioscale_init),
+	(gst_audioscale_chain), (gst_audioscale_set_property),
+	(gst_audioscale_get_property):
+	* gst/audioscale/gstaudioscale.h:
+	  s/resample_*/gst_resample_*/i to not clobber namespaces
+
+2004-02-23  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/riff/riff-media.c: (gst_riff_create_video_caps),
+	(gst_riff_create_audio_caps), (gst_riff_create_iavs_caps),
+	(gst_riff_create_video_template_caps),
+	(gst_riff_create_audio_template_caps),
+	(gst_riff_create_iavs_template_caps):
+	* gst-libs/gst/riff/riff-media.h:
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_base_init),
+	(gst_asf_demux_audio_caps), (gst_asf_demux_add_audio_stream),
+	(gst_asf_demux_video_caps), (gst_asf_demux_add_video_stream):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_add_stream):
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_add_stream),
+	(gst_matroska_demux_video_caps), (gst_matroska_demux_audio_caps),
+	(gst_matroska_demux_plugin_init): First batch implementing audio and
+	video codec tags in demuxers.
+
+2004-02-22  Benjamin Otte  <otte@gnome.org>
+
+	* ext/xine/Makefile.am:
+	* ext/xine/gstxine.h:
+	* ext/xine/xine.c: (plugin_init):
+	* ext/xine/xineinput.c:
+	  add input plugin wrapper. Playback from files, http, mms and cdda
+	  works.
+	* ext/xine/xineaudiodec.c: (gst_xine_audio_dec_chain):
+	  remove leftover G_GNUC_UNUSED
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_stream),
+	(gst_asf_demux_identify_guid):
+	  improve debugging output
+
+2004-02-22  Benjamin Otte  <otte@gnome.org>
+
+	reported by: Padraig O'Briain <padraig.obriain@sun.com>
+
+	* autogen.sh:
+	  replace test -e with test -x for mkinstalldirs to be more portable.
+	  (fixes #134816)
+
+2004-02-22  Benjamin Otte  <otte@gnome.org>
+
+	reported by: Stefan Kost <kost@imn.htwk-leipzig.de>
+
+	* gst/audioconvert/gstaudioconvert.c: (plugin_init):
+	  set rank to PRIMARY
+	* gst/volume/gstvolume.c: (plugin_init):
+	  set rank to NONE
+	fixes #134960
+
+2004-02-22   Julio M. Merino Vidal <jmmv@menta.net>
+
+	reviewed by Benjamin Otte  <otte@gnome.org>
+
+	* ext/flac/gstflacenc.c: (gst_flacenc_chain):
+	  escape NULL strings in GST_ELEMENT_ERROR properly (fixes #135116)
+
+2004-02-22  Benjamin Otte  <otte@gnome.org>
+
+	* configure.ac:
+	  export [_]*{gst,Gst,GST}.* symbols from plugins
+
+2004-02-22  Christophe Fergeau <teuf@gnome.org>
+
+	reviewed by: Benjamin Otte  <otte@gnome.org>
+
+	* ext/lame/gstlame.c: (add_one_tag):
+	* ext/mad/gstid3tag.c: (gst_mad_id3_to_tag_list):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_get_tag_value),
+	(gst_vorbisenc_metadata_set1):
+	* gst/tags/gstid3tag.c:
+	* gst/tags/gstvorbistag.c: (gst_vorbis_tag_add):
+	  apply fixes from bugs #135042 (lame can't write tags) and #133817
+	  (add GST_ALBUM_VOLUME_{COUNT,NUMBER} tags)
+
+2004-02-22 Ramon Garcia <ramon_garcia_f@yahoo.com>
+
+	* configure.ac: Export only gst_plugin_desc from plugins.
+         Note that this change only makes any effect with Linux using libtool
+	 1.5.2 or higher. Otherwise it is silently ignored, but it would build
+         fine. And don't try to have several versions of libtool in different
+         directories.
+
+2004-02-20  Andy Wingo  <wingo@pobox.com>
+
+	* gst/intfloat/, gst/oneton: Removed, replaced by audioconvert and
+	interleave respectively.
+
+	* gst/interleave/deinterleave.c: New plugin: deinterleave
+	(replaces on oneton).
+	* gst/interleave/interleave.c: New plugin: interleave.
+	* gst/interleave/plugin.h: Support file.
+	* gst/interleave/plugin.c: Support file.
+
+	* configure.ac: Remove intfloat and oneton, add interleave.
+
+	* ext/sndfile/gstsf.c: Handle events better.
+
+	* gst/audioconvert/gstaudioconvert.c: Change to support int2float
+	and float2int operation. int2float has scheduling problems as
+	noted in in2float_chain.
+
+2004-02-20  Benjamin Otte  <otte@gnome.org>
+
+	* ext/xine/Makefile.am:
+	* ext/xine/gstxine.h:
+	* ext/xine/xine.c:
+	* ext/xine/xineaudiodec.c:
+	* ext/xine/xinecaps.c:
+	  add first version of xine plugin wrapper. Currently only wraps the
+	  QDM2 win32 DLL, and even that only in proof-of-concept quality.
+	* configure.ac:
+	* ext/Makefile.am:
+	  add xine plugin wrapper, disabled by default. Use --enable-xine to
+	  build. Note that it'll segfault on gst-register if you don't remove
+	  the goom and tvtime post plugins from xine.
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_handle_sink_event),
+	(qtdemux_parse), (qtdemux_parse_trak), (qtdemux_audio_caps):
+	  add extradata parsing for QDM2.
+	  change around debugging prints.
+
+2004-02-19  Benjamin Otte  <otte@gnome.org>
+
+	* ext/lame/gstlame.c: (gst_lame_chain):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_chain):
+	  use gst_tag_list_insert when you want to insert tags
+
+2004-02-18  David Schleef  <ds@schleef.org>
+
+	* configure.ac:  Move massink to gst-rotten
+	* ext/Makefile.am:
+	* ext/mas/Makefile.am:
+	* ext/mas/massink.c:
+	* ext/mas/massink.h:
+
+2004-02-18  David Schleef  <ds@schleef.org>
+
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (plugin_init): Disable gdk_pixbuf
+	typefinding, since it seems to be worse than nothing.
+	* gst/typefind/gsttypefindfunctions.c: (qt_type_find):  Add ftyp
+	atom to recognize .mp4 and .m4a files as video/quicktime.
+
+2004-02-18  David Schleef  <ds@schleef.org>
+
+	* gst/sine/demo-dparams.c: (quit_live),
+	(dynparm_log_value_changed), (dynparm_value_changed), (main):
+	Use double dparams, not float.
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_class_init),
+	(gst_sinesrc_init): Change sync default to FALSE, since multiple
+	sync'd elements don't really work correctly.
+	* gst/volume/gstvolume.c: (volume_class_init), (volume_init),
+	(volume_update_volume), (volume_get_property):  Change dparam
+	to double.
+
+2004-02-18  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c:
+	(gst_ximagesink_xwindow_update_geometry),
+	(gst_ximagesink_renegotiate_size), (gst_ximagesink_handle_xevents),
+	(gst_ximagesink_change_state), (gst_ximagesink_expose),
+	(gst_ximagesink_init): Rework the way software video scaling works. So
+	now we check on each chain call if the video frames are feeling the
+	window. If not we try to renegotiate caps. On failure we memorize that
+	and we won't try again for that PLAYING sessions.
+	* sys/ximage/ximagesink.h: Adding a boolean to store the caps renego
+	failure.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_init): initialize the
+	synchronous flag.
+
+2004-02-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/play.c: (gst_play_pipeline_setup):
+          break up _link so we can give a better debug message for errors
+
+2004-02-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (plugin_init):
+          set up debug category
+
+2004-02-18  Julien MOUTTE <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_renegotiate_size),
+	(gst_ximagesink_handle_xevents), (gst_ximagesink_expose): Reorganizing
+	the way renegotiation work. The event handling function is not taking
+	care of external windows and renegotiate method check for pad flags
+	NEGOTIATING. Should fix : #133209
+
+2004-02-17  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_expose): Checking if the
+	pad is negotiating before trying renegotiation.
+
+2004-02-17  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_type_find):
+          pass on all possible mime types as typefind hints
+
+2004-02-17  Julien MOUTTE <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_new):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_new): Fix a
+	possible SHM leak if we crash. All other apps using XShm are doing
+	that.
+
+2004-02-17  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_renegotiate_size),
+	(gst_ximagesink_expose): Renegotiate size on expose.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_expose): Update window
+	size on expose.
+
+2004-02-16  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* testsuite/alsa/sinesrc.c:
+	  cosmetic fix to fix compile issue with gcc 2.95.4
+
+2004-02-16  Julien MOUTTE <julien@moutte.net>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_open_audio),
+	(gst_alsa_timestamp_to_bytes): Alsa should trigger an error if it
+	failed opening the audio device.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_new),
+	(gst_ximagesink_ximage_destroy), (gst_ximagesink_ximage_put),
+	(gst_ximagesink_xwindow_new), (gst_ximagesink_xwindow_destroy),
+	(gst_ximagesink_xwindow_resize), (gst_ximagesink_xwindow_clear),
+	(gst_ximagesink_renegotiate_size), (gst_ximagesink_handle_xevents),
+	(gst_ximagesink_xcontext_get), (gst_ximagesink_xcontext_clear),
+	(gst_ximagesink_change_state), (gst_ximagesink_chain),
+	(gst_ximagesink_set_xwindow_id): Clearing window in READY TO PAUSED.
+	Removing some useless g_return_if_fail like wingo suggested.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_new),
+	(gst_xvimagesink_xvimage_destroy), (gst_xvimagesink_xvimage_put),
+	(gst_xvimagesink_xwindow_new), (gst_xvimagesink_xwindow_destroy),
+	(gst_xvimagesink_xwindow_resize), (gst_xvimagesink_xwindow_clear),
+	(gst_xvimagesink_update_colorbalance),
+	(gst_xvimagesink_handle_xevents), (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_xcontext_clear),
+	(gst_xvimagesink_get_fourcc_from_caps),
+	(gst_xvimagesink_change_state), (gst_xvimagesink_chain),
+	(gst_xvimagesink_set_xwindow_id),
+	(gst_xvimagesink_colorbalance_list_channels),
+	(gst_xvimagesink_colorbalance_set_value),
+	(gst_xvimagesink_colorbalance_get_value): Clearing window in READY TO
+	PAUSED. Removing some useless g_return_if_fail like wingo suggested.
+
+2004-02-16  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_chain):
+          throw error when not negotiated instead of asserting
+
+2004-02-15  Julien MOUTTE  <julien@moutte.net>
+
+	* gst/switch/gstswitch.c: (gst_switch_loop): More fixes for
+	correct data refcounting.
+
+2004-02-15  Julien MOUTTE  <julien@moutte.net>
+
+	* gst/switch/gstswitch.c: (gst_switch_change_state),
+	(gst_switch_class_init): Cleaning the sinkpads correctly on state
+	change, mostly the EOS flag.
+
+2004-02-15  Julien MOUTTE  <julien@moutte.net>
+
+	* examples/gstplay/player.c: (got_eos), (main): Adding some
+	output for debugging.
+	* gst-libs/gst/play/play.c: (gst_play_state_change): Stop our
+	timeouts if we go to any state different from PLAYING.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_seek): Fix some
+	more EOS bugs in riff lib.
+
+2004-02-14  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/play.c: (gst_play_connect_visualization): Disable
+	visualization until i find a way to fix switch correctly.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head): Fix a bug when
+	EOS arrives.
+	* gst/switch/gstswitch.c: (gst_switch_release_pad),
+	(gst_switch_request_new_pad), (gst_switch_poll_sinkpads),
+	(gst_switch_loop), (gst_switch_dispose), (gst_switch_class_init):
+	Reworked switch to get a more correct behaviour with events and refing
+	of data stored in sinkpads.
+	* gst/switch/gstswitch.h: Adding an eos flag for every sinkpad so that
+	we don't pull from a pad in EOS.
+
+2004-02-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_chain):
+	  remove v1 tag even if we can't read it (makes sure we don't detect
+	  it again)
+
+2004-02-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_pcm_wait),
+	(gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsa.h:
+	  try xrun recovery when wait failed. Make xrun recovery function
+	  return TRUE/FALSE to indicate success. (might fix #134354)
+
+2004-02-13  David Schleef  <ds@schleef.org>
+
+	* gst/sine/demo-dparams.c: (dynparm_log_value_changed),
+	(dynparm_value_changed), (main): Convert from float to double.
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_init): same.
+
+2004-02-13  David Schleef  <ds@schleef.org>
+
+	* gst/silence/gstsilence.c: (gst_silence_class_init),
+	(gst_silence_set_clock), (gst_silence_get),
+	(gst_silence_set_property), (gst_silence_get_property):
+	* gst/silence/gstsilence.h: Add sync property.
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_class_init),
+	(gst_sinesrc_init), (gst_sinesrc_set_clock), (gst_sinesrc_get),
+	(gst_sinesrc_set_property), (gst_sinesrc_get_property):
+	* gst/sine/gstsinesrc.h: Add sync property.
+
+2004-02-13  David Schleef  <ds@schleef.org>
+
+	* gst/intfloat/gstint2float.c: (conv_f32_s16),
+	(gst_int2float_chain_gint16):  Change stdint usage to glib types.
+
+2004-02-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* gst-libs/ext/Makefile.am:
+          move ffmpeg plugin to gst-ffmpeg module
+
+2004-02-13  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac: use GST_ARCH to detect architecture
+
+2004-02-12  Julien MOUTTE  <julien@moutte.net>
+
+	* gst/vbidec/vbiscreen.c: Fixing thomasvs fixes. Missing header.
+
+2004-02-12  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/ladspa/gstladspa.c: (gst_ladspa_base_init):
+          classify LADSPA plugins based on number of src/sink pads
+	  (#133663, Stefan Kost)
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_init):
+          fix dparams registration
+	  (#133528, Stefan Kost)
+	* gst/vbidec/vbiscreen.c: (vbiscreen_set_current_cell):
+          fix use of isprint and use g_ascii_isprint instead
+	  (#133316, Stefan Kost)
+
+2004-02-11  David Schleef  <ds@schleef.org>
+
+	Convert a few inner loops to use liboil.  This is currently
+	optional, and is only enabled if liboil is present (duh!).
+	* configure.ac: Check for liboil-0.1
+	* gst/intfloat/Makefile.am:
+	* gst/intfloat/gstint2float.c: (conv_f32_s16), (scalarmult_f32),
+	(gst_int2float_chain_gint16):
+	* gst/videofilter/Makefile.am:
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_class_init),
+	(tablelookup_u8), (gst_videobalance_planar411):
+	* gst/videotestsrc/Makefile.am:
+	* gst/videotestsrc/gstvideotestsrc.c: (plugin_init):
+	* gst/videotestsrc/videotestsrc.c: (splat_u8), (paint_hline_YUY2),
+	(paint_hline_IYU2), (paint_hline_str4), (paint_hline_str3),
+	(paint_hline_RGB565), (paint_hline_xRGB1555):
+
+2004-02-11  David Schleef  <ds@schleef.org>
+
+	* ext/lcs/gstcolorspace.c: (colorspace_find_lcs_format),
+	(gst_colorspace_caps_get_fourcc), (colorspace_setup_converter),
+	(gst_colorspace_getcaps), (gst_colorspace_link),
+	(gst_colorspace_base_init), (gst_colorspace_init),
+	(gst_colorspace_chain), (gst_colorspace_change_state),
+	(plugin_init): Merge Ronald's patch (bug #117897) and update
+	for new caps and negotiation.  Seems to work, although it
+	shows off bugs in lcs.
+
+2004-02-11  David Schleef  <ds@schleef.org>
+
+	* ext/alsa/Makefile.am: Fix linking against libgstinterfaces.
+	(bug #133886)  Noticed by bugs@leroutier.net (Stephane LOEUILLET)
+
+2004-02-11  David Schleef  <ds@schleef.org>
+
+	* ext/librfb/gstrfbsrc.c: (gst_rfbsrc_class_init),
+	(gst_rfbsrc_change_state), (gst_rfbsrc_init),
+	(gst_rfbsrc_set_property), (gst_rfbsrc_get_property):
+	Add server and port properties
+
+2004-02-11  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* m4/a52.m4:
+	* m4/aalib.m4:
+	* m4/as-ffmpeg.m4:
+	* m4/as-liblame.m4:
+	* m4/as-slurp-ffmpeg.m4:
+	* m4/check-libheader.m4:
+	* m4/esd.m4:
+	* m4/freetype2.m4:
+	* m4/gconf-2.m4:
+	* m4/glib.m4:
+	* m4/gst-alsa.m4:
+	* m4/gst-artsc.m4:
+	* m4/gst-ivorbis.m4:
+	* m4/gst-matroska.m4:
+	* m4/gst-sdl.m4:
+	* m4/gst-shout2.m4:
+	* m4/gst-sid.m4:
+	* m4/gtk.m4:
+	* m4/libdv.m4:
+	* m4/libfame.m4:
+	* m4/libmikmod.m4:
+	* m4/ogg.m4:
+	* m4/vorbis.m4:
+          fix underquotedness of macros (#133800)
+	* m4/as-avifile.m4:
+	* m4/xmms.m4:
+          removed because no longer used
+
+2004-02-11  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+          require gettext 0.11.5 so ulonglong.m4 gets checked out and copied
+          by autopoint (fixes #132996)
+
+2004-02-11  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/ffmpeg/gstffmpegdec.c: (gst_ffmpegdec_base_init):
+	* ext/ffmpeg/gstffmpegdemux.c: (gst_ffmpegdemux_base_init):
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_base_init):
+	* ext/ffmpeg/gstffmpegmux.c: (gst_ffmpegmux_base_init):
+	  fix memleaks
+
+2004-02-11  David Schleef  <ds@schleef.org>
+
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_sink_link),
+	(gst_gdk_pixbuf_chain): Fix logic bug causing spurious errors.
+	* ext/jpeg/gstjpegdec.c: (gst_jpegdec_base_init),
+	(gst_jpegdec_init), (gst_jpegdec_chain): Fix negotiation.
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_base_init),
+	(gst_jpegenc_class_init), (gst_jpegenc_init),
+	(gst_jpegenc_getcaps), (gst_jpegenc_link), (gst_jpegenc_resync),
+	(gst_jpegenc_chain), (gst_jpegenc_set_property),
+	(gst_jpegenc_get_property):  Fix negotiation.  Add some properties.
+	* ext/jpeg/gstjpegenc.h: Fix negotiation.
+
+2004-02-10  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mikmod/gstmikmod.c: (gst_mikmod_init),
+	(gst_mikmod_srcfixate), (gst_mikmod_srclink), (gst_mikmod_loop):
+	* ext/mikmod/gstmikmod.h:
+	  fix caps negotiation in mikmod
+	* ext/ogg/gstoggdemux.c: (gst_ogg_print):
+	  output debug information
+
+2004-02-08  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/navigation/Makefile.am:
+	* gst-libs/gst/xoverlay/Makefile.am:
+	  remove unused GST_OPT_CFLAGS from Makefiles
+	  include X_CFLAGS and X_LIBS in xoverlay. (#131948)
+
+2004-02-07  David Schleef  <ds@schleef.org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_handle_event): Don't
+	push events to pads that haven't been created (#133508)
+
+2004-02-07  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_init), (gst_dvdec_src_convert),
+	(gst_dvdec_sink_convert), (gst_dvdec_handle_sink_event),
+	(gst_dvdec_video_getcaps), (gst_dvdec_video_link),
+	(gst_dvdec_loop), (gst_dvdec_change_state):
+	Second attempt at committing a working dvdec element.
+
+2004-02-06  David Schleef  <ds@schleef.org>
+
+	Build fixes for OS X: (see #129600)
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_strh),
+	(gst_riff_read_strf_vids), (gst_riff_read_strf_auds),
+	(gst_riff_read_strf_iavs):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_avih),
+	(gst_avi_demux_stream_odml):
+	* gst/playondemand/Makefile.am:
+	* gst/rtp/rtp-packet.c:
+
+2004-02-05  David Schleef  <ds@schleef.org>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_init), (gst_dvdec_loop): Revert
+	last change, because it Just Doesn't Compile.
+
+2004-02-05  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_chain):
+	  skip undecodable id3v2 tag instead of keeping it
+
+2004-02-05  David Schleef  <ds@schleef.org>
+
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (gst_mp3parse_chain):
+	Unref leaked buffer.  (Noticed by Ronald)
+
+2004-02-05  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* pkgconfig/gstreamer-libs-uninstalled.pc.in:
+	Sync requires with other checks.  >= vs =.
+
+2004-02-06  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_init), (gst_dvdec_video_getcaps),
+	(gst_dvdec_video_link), (gst_dvdec_loop):
+	* ext/dv/gstdvdec.h:
+	  rework the caps negotiation so that dvdec works again instead
+	  of just segfaulting.
+
+=== release 0.7.4 ===
+
+2004-02-06  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* NEWS: GStreamer Plugins 0.7.4 "For Great Justice" released
+	* configure.ac: changed for release
+
+2004-02-05  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/gconf/gstreamer-gconf-uninstalled.pc.in:
+	* pkgconfig/gstreamer-interfaces-uninstalled.pc.in:
+	* pkgconfig/gstreamer-libs-uninstalled.pc.in:
+	* pkgconfig/gstreamer-play-uninstalled.pc.in:
+          reworked patch by David Lehn to fix libdir and includedir for
+          uninstalled libraries
+          removed play and gconf from gstreamer-libs since they have their
+          own pkgconfig files
+
+2004-02-04  David Schleef  <ds@schleef.org>
+
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_parse_fmt): Fix a caps
+	memleak.
+
+2004-02-05  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_info):
+	  use correct GST_TAG_ENCODER tag
+
+2004-02-05  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state):
+	  be sure to stop the clock when going to paused
+	* sys/oss/gstosssink.c: (gst_osssink_change_state):
+	  reset number of transmitted when going to ready.
+	fixes #132935
+
+2004-02-05  Charles Schmidt <cschmidt2@emich.edu>
+
+	reviewed by Benjamin Otte
+
+	* ext/mad/gstid3tag.c: (gst_mad_id3_to_tag_list):
+	  extract track count (fixes #133410)
+
+2004-02-04  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_do_caps_nego):
+	  that should be !=, not == (fixes #132519)
+
+2004-02-04  David Schleef  <ds@schleef.org>
+
+	Make sure set_explicit_caps() is called before adding pad.
+	* ext/ffmpeg/gstffmpegdemux.c: (gst_ffmpegdemux_loop):
+	* gst/id3/gstid3types.c: (gst_id3types_loop):
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead):
+	* gst/realmedia/rmdemux.c: (gst_rmdemux_add_stream):
+
+2004-02-04  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+          bump nano to 2, first prerelease
+          put back AM_PROG_LIBTOOL
+
+2004-02-04  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* testsuite/alsa/Makefile.am:
+          these are user test apps, not automatic testsuite tests
+
+2004-02-04  David Schleef  <ds@schleef.org>
+
+	Convert GST_DEBUG_CAPS() to GST_DEBUG():
+	* gst/mpeg1videoparse/gstmp1videoparse.c:
+	(mp1videoparse_parse_seq):
+	* gst/realmedia/rmdemux.c: (gst_rmdemux_add_stream):
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_getcaps):
+	* sys/xvideo/gstxwindow.c: (_gst_xwindow_new):
+	* sys/xvideo/xvideosink.c: (gst_xvideosink_sinkconnect),
+	(gst_xvideosink_getcaps):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support):
+	* testsuite/gst-lint: more tests
+
+2004-02-04  David Schleef  <ds@schleef.org>
+
+	Replace use of GST_PAD_FORMATS_FUNCTION() and similar macros
+	with the code that they would expand to.
+	* ext/flac/gstflacdec.c: (gst_flacdec_get_src_formats),
+	(gst_flacdec_get_src_query_types),
+	(gst_flacdec_get_src_event_masks):
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_get_formats),
+	(gst_gnomevfssrc_get_query_types),
+	(gst_gnomevfssrc_get_event_mask):
+
+2004-02-04  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_class_init),
+	(gst_sinesrc_dispose):
+	  fix memleak by properly disposing sinesrc
+
+2004-02-04  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/xoverlay/xoverlay.c: (gst_x_overlay_expose):
+	* gst-libs/gst/xoverlay/xoverlay.h: Adding the _expose method to tell
+	an overlay to redraw the image because it has been exposed.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_destroy),
+	(gst_ximagesink_ximage_put), (gst_ximagesink_expose),
+	(gst_ximagesink_xoverlay_init), (gst_ximagesink_init):
+	* sys/ximage/ximagesink.h: Implement expose method from XOverlay
+	interface
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_destroy),
+	(gst_xvimagesink_xvimage_put), (gst_xvimagesink_expose),
+	(gst_xvimagesink_xoverlay_init), (gst_xvimagesink_init):
+	* sys/xvimage/xvimagesink.h: Implement expose method from XOverlay
+	interface
+
+2004-02-03  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_type_find):
+	  more memleak fixage
+
+2004-02-03  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (plugin_init):
+	* gst/typefind/gsttypefindfunctions.c:
+	  fix memleaks shown by gst-typefind
+
+2004-02-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* common/glib-gen.mak:
+          add hack rule to touch .Plo files
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/tuner/Makefile.am:
+          remove glib_root variable
+
+2004-02-03  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_add_stream):
+	  set explicit caps before adding the element, so the autopluggers can
+	  plug correctly.
+	* gst/typefind/gsttypefindfunctions.c: (mp3_type_find),
+	(mpeg2_sys_type_find), (mpeg1_sys_type_find),
+	(mpeg_video_type_find), (mpeg_video_stream_type_find),
+	(dv_type_find):
+	  fix memleaks in typefind functions. gst_type_find_suggest takes a const
+	  argument.
+
+2004-02-03  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/colorbalance/colorbalance-marshal.list:
+	* gst-libs/gst/colorbalance/colorbalance.c:
+	* gst-libs/gst/colorbalance/colorbalance.h:
+	* gst-libs/gst/colorbalance/colorbalancemarshal.list:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/mixer/mixer-marshal.list:
+	* gst-libs/gst/mixer/mixer.c:
+	* gst-libs/gst/mixer/mixer.h:
+	* gst-libs/gst/mixer/mixermarshal.list:
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/play/play.h:
+	* gst-libs/gst/tuner/Makefile.am:
+	* gst-libs/gst/tuner/tuner-marshal.list:
+	* gst-libs/gst/tuner/tuner.c:
+	* gst-libs/gst/tuner/tuner.h:
+	* gst-libs/gst/tuner/tunermarshal.list:
+          use new glib-gen.mak snippet to clean up Makefile.am
+          fix various bugs in Makefile.am's
+
+2004-02-03  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_chain):
+	  handle chain parsing correctly in the multichain case
+	* ext/theora/theoradec.c: (gst_theora_dec_init), (_theora_ilog),
+	(theora_dec_from_granulepos), (theora_dec_to_granulepos),
+	(theora_dec_src_query), (theora_dec_src_event), (theora_dec_event),
+	(theora_dec_chain):
+	  handle events and queries correctly
+
+2004-02-03  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* .cvsignore:
+	Ignore generated file _stdint.h.
+
+2004-02-03  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* gst-libs/gst/colorbalance/Makefile.am:
+	* gst-libs/gst/colorbalance/colorbalance.h:
+	* gst-libs/gst/mixer/Makefile.am:
+	* gst-libs/gst/mixer/mixer.h:
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/play/play.h:
+	* gst-libs/gst/tuner/Makefile.am:
+	* gst-libs/gst/tuner/tuner.h:
+	Generate enum type code with glib-mkenums.
+	* gst-libs/gst/colorbalance/.cvsignore:
+	* gst-libs/gst/mixer/.cvsignore:
+	* gst-libs/gst/play/.cvsignore:
+	* gst-libs/gst/tuner/.cvsignore:
+	Ignore generated files.
+
+2004-02-03  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* gst-libs/gst/audio/.cvsignore:
+	Ignore generated file.
+	* gst-libs/gst/audio/Makefile.am:
+	Do not install example filter.
+
+2004-02-03  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* examples/switch/.cvsignore:
+	Ignore generated file.
+
+2004-02-03  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* common/m4/ax_create_stdint_h.m4:
+	* configure.ac:
+	  add AX_CREATE_STDINT_H to get correct type definitions for a52dec in
+	  _stdint.h.
+	* Makefile.am:
+	  remove generated _stdint.h in DISTCLEANFILES
+	* ext/a52dec/gsta52dec.c:
+	  include _stdint.h for a52dec. (should fix #133064)
+
+2004-02-02  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* gst/tags/gstvorbistag.c: (gst_vorbis_tag_add),
+	(gst_tag_to_vorbis_comments):
+	Add replaygain support to vorbistag
+
+2004-02-02  Jeremy Simon  <jesimon@libertysurf.fr>
+	* ext/ffmpeg/gstffmpegcodecmap.c: (gst_ffmpeg_codecid_to_caps),
+	(gst_ffmpeg_caps_to_extradata):
+	  Fix SVQ3 caps flag properties
+	  Use glib macro for bytes swap
+
+2004-02-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/audiofile/gstafsink.c: (gst_afsink_plugin_init):
+	* ext/audiofile/gstafsrc.c: (gst_afsrc_plugin_init):
+	* ext/gnomevfs/gstgnomevfs.c: (plugin_init):
+	* ext/sndfile/gstsf.c: (plugin_init):
+	* gst/avi/gstavi.c: (plugin_init):
+	* sys/dxr3/dxr3init.c: (plugin_init):
+	* sys/oss/gstossaudio.c: (plugin_init):
+	* sys/v4l/gstv4l.c: (plugin_init):
+	* sys/v4l2/gstv4l2.c: (plugin_init):
+          remove textdomain calls
+	* po/nl.po:
+          update Dutch translation
+
+2004-02-02  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/play.c: (gst_play_pipeline_setup),
+	(gst_play_set_audio_sink): Moving volume in the audio thread for
+	instantaneous volume change. Maybe i will add another volume in front
+	of visualization later, not sure yet though.
+
+2004-02-02  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_renegotiate_size),
+	(gst_ximagesink_handle_xevents): Better X events handling, only take
+	the latest events for configure and motion.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_handle_xevents): same.
+
+2004-02-02  Jon Trowbridge  <trow@gnu.org>
+
+	reviewed by: David Schleef  <ds@schleef.org>
+
+	Fix memory leaks:
+	* ext/ffmpeg/gstffmpegdec.c: (gst_ffmpegdec_register):
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_register):
+
+2004-02-02  David Schleef  <ds@schleef.org>
+
+	code cleanup.  Change bzero() to memset().  Remove duplicate ; at ends
+	of lines.
+	* ext/cdparanoia/gstcdparanoia.c: (cdparanoia_event):
+	* ext/flac/gstflactag.c: (gst_flac_tag_chain):
+	* ext/xvid/gstxviddec.c: (gst_xviddec_src_link):
+	* gst-libs/gst/play/play.c: (gst_play_get_sink_element):
+	* gst/ac3parse/gstac3parse.c: (gst_ac3parse_chain):
+	* gst/effectv/gstedge.c: (gst_edgetv_sinkconnect):
+	* gst/effectv/gstvertigo.c: (gst_vertigotv_sinkconnect):
+	* gst/intfloat/float22int.c: (gst_float2_2_int_getcaps),
+	(gst_float2_2_int_link):
+	* gst/mpeg2sub/gstmpeg2subt.c: (gst_mpeg2subt_chain_subtitle):
+	* gst/rtjpeg/RTjpeg.c: (RTjpeg_init_mcompress):
+	* gst/tcp/gsttcpsink.c: (gst_tcpsink_init_send):
+	* gst/tcp/gsttcpsrc.c: (gst_tcpsrc_init_receive):
+	* gst/udp/gstudpsink.c: (gst_udpsink_init_send):
+	* gst/udp/gstudpsrc.c: (gst_udpsrc_init_receive):
+	* sys/v4l/gstv4lelement.c: (gst_v4lelement_init):
+	* sys/v4l2/v4l2src_calls.c: (gst_v4l2src_set_capture):
+	* testsuite/gst-lint: Add tests for bzero and ;;
+
+2004-02-02  David Schleef  <ds@schleef.org>
+
+	* gst/debug/efence.c: Add fallback if MAP_ANONYMOUS isn't defined.
+
+2004-02-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/aalib/gstaasink.c: (gst_aasink_open):
+	* ext/alsa/gstalsa.c: (gst_alsa_link), (gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_loop):
+	* ext/audiofile/gstafsink.c: (gst_afsink_open_file),
+	(gst_afsink_close_file):
+	* ext/audiofile/gstafsrc.c: (gst_afsrc_open_file),
+	(gst_afsrc_close_file):
+	* ext/divx/gstdivxdec.c: (gst_divxdec_setup), (gst_divxdec_chain):
+	* ext/divx/gstdivxenc.c: (gst_divxenc_setup), (gst_divxenc_chain):
+	* ext/dv/gstdvdec.c: (gst_dvdec_loop):
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_user_op), (dvdnavsrc_get):
+	* ext/esd/esdmon.c: (gst_esdmon_get):
+	* ext/esd/esdsink.c: (gst_esdsink_chain), (gst_esdsink_open_audio):
+	* ext/faac/gstfaac.c: (gst_faac_chain):
+	* ext/faad/gstfaad.c: (gst_faad_chain):
+	* ext/ffmpeg/gstffmpegdec.c: (gst_ffmpegdec_chain):
+	* ext/ffmpeg/gstffmpegdemux.c: (gst_ffmpegdemux_loop):
+	* ext/ffmpeg/gstffmpegmux.c: (gst_ffmpegmux_loop):
+	* ext/flac/gstflacdec.c: (gst_flacdec_error_callback),
+	(gst_flacdec_loop):
+	* ext/flac/gstflacenc.c: (gst_flacenc_chain):
+	* ext/flac/gstflactag.c: (gst_flac_tag_chain):
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_chain):
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_open_file),
+	(gst_gnomevfssink_close_file):
+	* ext/gnomevfs/gstgnomevfssrc.c: (audiocast_init),
+	(gst_gnomevfssrc_open_file):
+	* ext/ivorbis/vorbisfile.c: (gst_ivorbisfile_loop):
+	* ext/lame/gstlame.c: (gst_lame_sink_link), (gst_lame_chain):
+	* ext/lcs/gstcolorspace.c: (gst_colorspace_srcconnect_func):
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event),
+	(gst_id3_tag_do_typefind), (gst_id3_tag_chain):
+	* ext/mad/gstmad.c: (gst_mad_chain):
+	* ext/mikmod/gstmikmod.c: (gst_mikmod_loop):
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	* ext/mplex/gstmplex.cc:
+	* ext/mplex/gstmplexibitstream.cc:
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_chain),
+	(gst_ogg_demux_push):
+	* ext/raw1394/gstdv1394src.c:
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_lock),
+	(gst_sdlvideosink_initsdl), (gst_sdlvideosink_create):
+	* ext/sndfile/gstsf.c: (gst_sf_open_file), (gst_sf_close_file),
+	(gst_sf_loop):
+	* ext/speex/gstspeexenc.c: (gst_speexenc_chain):
+	* ext/swfdec/gstswfdec.c: (gst_swfdec_loop):
+	* ext/tarkin/gsttarkindec.c: (gst_tarkindec_chain):
+	* ext/tarkin/gsttarkinenc.c: (gst_tarkinenc_chain):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_chain):
+	* ext/vorbis/vorbisfile.c: (gst_vorbisfile_loop):
+	* ext/xvid/gstxviddec.c: (gst_xviddec_setup), (gst_xviddec_chain):
+	* ext/xvid/gstxvidenc.c: (gst_xvidenc_setup), (gst_xvidenc_chain):
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head),
+	(gst_riff_read_element_data), (gst_riff_read_seek),
+	(gst_riff_peek_list), (gst_riff_read_list), (gst_riff_read_header):
+	* gst/adder/gstadder.c: (gst_adder_loop):
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_segment),
+	(gst_asf_demux_process_stream), (gst_asf_demux_get_stream):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_init),
+	(gst_avi_demux_add_stream), (gst_avi_demux_stream_header):
+	* gst/avi/gstavimux.c: (gst_avimux_stop_file):
+	* gst/flx/gstflxdec.c: (gst_flxdec_loop):
+	* gst/goom/gstgoom.c: (gst_goom_chain):
+	* gst/id3/gstid3types.c: (gst_id3types_loop):
+	* gst/intfloat/float22int.c: (gst_float2_2_int_chain):
+	* gst/intfloat/gstfloat2int.c: (gst_float2int_loop):
+	* gst/intfloat/gstint2float.c: (gst_int2float_chain_gint16):
+	* gst/matroska/ebml-read.c: (gst_ebml_read_element_id),
+	(gst_ebml_read_element_length), (gst_ebml_read_element_data),
+	(gst_ebml_read_seek), (gst_ebml_read_uint), (gst_ebml_read_sint),
+	(gst_ebml_read_float), (gst_ebml_read_header):
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_init_stream),
+	(gst_matroska_demux_parse_blockgroup):
+	* gst/monoscope/gstmonoscope.c: (gst_monoscope_chain):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_loop):
+	* gst/oneton/gstoneton.c: (gst_oneton_chain):
+	* gst/silence/gstsilence.c: (gst_silence_get):
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_get):
+	* gst/smpte/gstsmpte.c: (gst_smpte_loop):
+	* gst/speed/gstspeed.c: (speed_loop):
+	* gst/tags/gstvorbistag.c: (gst_vorbis_tag_chain):
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_get):
+	* gst/volenv/gstvolenv.c: (gst_volenv_chain):
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_chain):
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_parse_fmt),
+	(gst_wavparse_loop):
+	* sys/dxr3/dxr3audiosink.c: (dxr3audiosink_open),
+	(dxr3audiosink_set_mode_pcm), (dxr3audiosink_set_mode_ac3),
+	(dxr3audiosink_close):
+	* sys/dxr3/dxr3spusink.c: (dxr3spusink_open), (dxr3spusink_close):
+	* sys/dxr3/dxr3videosink.c: (dxr3videosink_open),
+	(dxr3videosink_close), (dxr3videosink_write_data):
+	* sys/oss/gstosselement.c: (gst_osselement_open_audio):
+	* sys/oss/gstosssink.c: (gst_osssink_chain):
+	* sys/oss/gstosssrc.c: (gst_osssrc_get):
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_chain):
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_buffer_free):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_buffer_free):
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_overlay),
+	(gst_v4l_set_window), (gst_v4l_enable_overlay):
+	* sys/v4l/v4l_calls.c: (gst_v4l_get_capabilities), (gst_v4l_open),
+	(gst_v4l_set_chan_norm), (gst_v4l_get_signal),
+	(gst_v4l_get_frequency), (gst_v4l_set_frequency),
+	(gst_v4l_get_picture), (gst_v4l_set_picture), (gst_v4l_get_audio),
+	(gst_v4l_set_audio):
+	* sys/v4l/v4l_calls.h:
+	* sys/v4l/v4lmjpegsink_calls.c: (gst_v4lmjpegsink_sync_thread),
+	(gst_v4lmjpegsink_queue_frame), (gst_v4lmjpegsink_set_playback),
+	(gst_v4lmjpegsink_playback_init),
+	(gst_v4lmjpegsink_playback_start):
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_queue_frame):
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_queue_frame),
+	(gst_v4lsrc_sync_frame), (gst_v4lsrc_capture_init),
+	(gst_v4lsrc_requeue_frame), (gst_v4lsrc_try_palette):
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_get):
+	* sys/v4l2/v4l2-overlay_calls.c: (gst_v4l2_set_display),
+	(gst_v4l2_set_window), (gst_v4l2_enable_overlay):
+	* sys/v4l2/v4l2_calls.c: (gst_v4l2_get_capabilities),
+	(gst_v4l2_fill_lists), (gst_v4l2_open), (gst_v4l2_get_norm),
+	(gst_v4l2_set_norm), (gst_v4l2_get_input), (gst_v4l2_set_input),
+	(gst_v4l2_get_output), (gst_v4l2_set_output),
+	(gst_v4l2_get_frequency), (gst_v4l2_set_frequency),
+	(gst_v4l2_signal_strength), (gst_v4l2_get_attribute),
+	(gst_v4l2_set_attribute):
+	* sys/v4l2/v4l2_calls.h:
+	* sys/v4l2/v4l2src_calls.c: (gst_v4l2src_fill_format_list),
+	(gst_v4l2src_queue_frame), (gst_v4l2src_grab_frame),
+	(gst_v4l2src_get_capture), (gst_v4l2src_set_capture),
+	(gst_v4l2src_capture_init), (gst_v4l2src_capture_start),
+	(gst_v4l2src_capture_stop):
+	* sys/vcd/vcdsrc.c: (vcdsrc_open_file):
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get),
+	(gst_ximagesink_chain):
+	* sys/xvideo/xvideosink.c: (gst_xvideosink_buffer_new),
+	(gst_xvideosink_sinkconnect), (gst_xvideosink_chain),
+	(gst_xvideosink_xwindow_new):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_chain):
+
+2004-02-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/volume/gstvolume.c: (gst_volume_set_volume),
+	(gst_volume_get_volume), (volume_class_init), (volume_init),
+	(volume_chain_int16), (volume_update_volume):
+	* gst/volume/gstvolume.h:
+          make code more readable by removing magic numbers
+          make mixer interface export 0-100 range
+          make it internally map to 0.0-1.0 range so users don't distort
+          output by putting the sliders at full volume
+
+2004-02-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/play.c: (gst_play_tick_callback),
+	(gst_play_state_change), (gst_play_seek_to_time):
+        block the tick callback for 0.5 secs after doing a seek
+
+2004-02-02  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/play.c: (gst_play_new):
+          check for GError
+
+2004-02-01  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/play.c: (gst_play_seek_to_time),
+	(gst_play_new): Accepting NULL GError, blocking time tick while seeking.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sink_link),
+	(gst_ximagesink_chain), (gst_ximagesink_init): s/sinkconnect/sink_link
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_sink_link),
+	(gst_xvimagesink_chain), (gst_xvimagesink_init): s/sinkconnect/sink_link
+
+2004-02-01  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* configure.ac:
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event):
+          check for a function added in vorbis 1.1
+
+2004-01-31  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state), (gst_alsa_start),
+	(gst_alsa_drain_audio), (gst_alsa_stop_audio):
+	  really start/stop clock only on PLAYING <=> PAUSED
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	  remove \n from debugging lines
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_chain):
+	  make it work when seeking does not
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event):
+	  reset on DISCONT
+
+2004-01-31  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_change_state), (gst_alsa_start):
+	  start clock on PAUSED=>PLAYING, not later
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  extract correct time for different discont formats
+	(gst_alsa_sink_get_time):
+	  don't segfault when no format is negotiated yet, just return 0
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_event),
+	(gst_ogg_demux_handle_event), (gst_ogg_demux_push),
+	(gst_ogg_pad_push):
+	  handle flush and discont events correctly
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event), (vorbis_dec_chain):
+	  handle discont events correctly
+
+2004-01-31  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/play.c: (gst_play_error_quark),
+	(gst_play_error_create), (gst_play_error_plugin),
+	(gst_play_pipeline_setup), (gst_play_init), (gst_play_new):
+	* gst-libs/gst/play/play.h:
+          add error handling during creation
+	* examples/gstplay/player.c: (main):
+          use new gst_play_new
+
+
+2004-01-31  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/theora/theoradec.c: (theora_dec_chain):
+	  make comments work
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_src_query),
+	(vorbis_dec_src_event), (vorbis_dec_chain):
+	  add encoder tag, fix tag reading to be more error tolerant, change
+	  BITRATE to NOMINAL_BITRATE, add debugging, don't unref events after
+	  gst_pad_event_default.
+	* gst/tags/gstvorbistag.c:
+	(gst_tag_list_from_vorbiscomment_buffer):
+	  undefine function specific define at end of function
+
+2004-01-31  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* ext/flac/gstflac.c: (plugin_init):
+	* ext/flac/gstflacdec.c: (gst_flacdec_class_init):
+	* ext/flac/gstflacdec.h:
+	* ext/flac/gstflacenc.h:
+	  Fix typos
+
+2004-01-30  David I. Lehn  <dlehn@users.sourceforge.net>
+
+	* examples/gstplay/player.c: s/gstplay.h/play.h/
+
+2004-01-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/Makefile.am:
+	* gst-libs/gst/play/gstplay.c:
+	* gst-libs/gst/play/gstplay.h:
+	* gst-libs/gst/play/play.c:
+          more surgery, operation complete
+
+2004-01-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/play/play.old.c:
+	* gst-libs/gst/play/play.old.h:
+          after CVS surgery by moving, remove
+	* gst-libs/gst/play/playpipelines.c:
+          remove
+
+	* gst/intfloat/float22int.c: (gst_float2_2_int_chain):
+          add negotiation error
+
+2004-01-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_event),
+	(gst_ogg_demux_push):
+          add some seeking debug info
+          send a flush when seeking
+
+2004-01-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  use AC_C_INLINE
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/theora/Makefile.am:
+	* ext/theora/theoradec.c:
+	  add theora video decoder. Does just do simple decoding for now and
+	  has been tested against Theora cvs only. It only works when theora
+	  is compiled with --enable-static.
+	* ext/vorbis/vorbisdec.c: (vorbis_dec_event):
+	  always reset packetno on DISCONT
+
+2004-01-30  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead):
+	  Fix audio.
+
+2004-01-30  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegaudioparse/gstmpegaudioparse.c:
+	(mp3_type_frame_length_from_header):
+	  Fix header parsing - stolen from ffmpeg (thank you! :) ).
+
+2004-01-30  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/esd/esdsink.c: (gst_esdsink_init):
+	  Since we have static pad template caps, we don't need to negotiate;
+	  either the core errors out or we know the format.
+
+2004-01-30  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head),
+	(gst_riff_read_seek):
+	* gst/matroska/ebml-read.c: (gst_ebml_read_element_id),
+	(gst_ebml_read_seek):
+	  Fix event handling.
+
+2004-01-30  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/ffmpeg/gstffmpegcodecmap.c: (gst_ffmpeg_codecid_to_caps):
+	  removee video/x-theora from vp3 decoder, it doesn't handle raw
+	  theora streams
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_init):
+	  fix bug with finalizing element that never went to PAUSED
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_src_query):
+	  length and position queries were swapped
+	* ext/vorbis/vorbisdec.c: (gst_vorbis_dec_init),
+	(vorbis_dec_from_granulepos), (vorbis_dec_src_query),
+	(vorbis_dec_src_event):
+	  implement querying time and bytes
+
+2004-01-30  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+        * just about every source file:
+          gst_element_error -> GST_ELEMENT_ERROR
+
+2004-01-29  Julien MOUTTE  <julien@moutte.net>
+
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_get): Fixing seeking
+	emiting FLUSH and even before DISCONT.
+	* gst-libs/gst/play/gstplay.c: (gst_play_seek_to_time): Fix seeking to
+	get the best instant seeking as possible yay!
+
+2004-01-29  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpeg1videoparse/gstmp1videoparse.c:
+	(gst_mp1videoparse_real_chain):
+	  Committed wrong version last week... Grr... Didn't notice until now.
+
+2004-01-29  Julien MOUTTE <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_new):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xwindow_new): Emit the
+	have_xwindow_id signal in xwindow_create.
+
+2004-01-29  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/ogg/gstoggdemux.c:
+	  lots of changes - mainly support for chained bitstreams, seeking,
+	  querying and bugfixes of course
+	* ext/vorbis/Makefile.am:
+	* ext/vorbis/vorbisdec.c:
+	* ext/vorbis/vorbisdec.h:
+	  add vorbisdec raw vorbis decoder
+	* ext/vorbis/vorbis.c: (plugin_init):
+	  register vorbisdec as PRIMARY, vorbisfile as SECONDARY
+	* gst/intfloat/Makefile.am:
+	* gst/intfloat/float22int.c:
+	* gst/intfloat/float22int.h:
+	* gst/intfloat/gstintfloatconvert.c: (plugin_init):
+	  add float2intnew plugin. It converts multichannel interleaved float to
+	  multichannel interleaved int. The name should probably be changed.
+	* gst/typefind/gsttypefindfunctions.c: (theora_type_find),
+	(plugin_init):
+	  add typefinding for raw theora video so oggdemux can detect it.
+
+2004-01-28  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_seek_to_time): seek on video
+	sink element first.
+	* gst/videoscale/gstvideoscale.c:
+	(gst_videoscale_handle_src_event): Fixing src event handler.
+
+2004-01-28  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_class_init), (gst_v4lsrc_init),
+	(gst_v4lsrc_open), (gst_v4lsrc_close),
+	(gst_v4lsrc_palette_to_caps), (gst_v4lsrc_srcconnect),
+	(gst_v4lsrc_getcaps), (gst_v4lsrc_set_clock):
+	* sys/v4l/gstv4lsrc.h:
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_capture_start),
+	(gst_v4lsrc_grab_frame), (gst_v4lsrc_capture_stop):
+	  Implement resizing... Hack. But that's why v4l is b0rked...
+
+2004-01-28  Julien MOUTTE <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_check_xshm_calls),
+	(gst_ximagesink_ximage_new), (gst_ximagesink_ximage_destroy),
+	(gst_ximagesink_ximage_put), (gst_ximagesink_xwindow_new),
+	(gst_ximagesink_xwindow_destroy):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_new), (gst_xvimagesink_xvimage_destroy),
+	(gst_xvimagesink_xwindow_new), (gst_xvimagesink_xwindow_destroy),
+	(gst_xvimagesink_xwindow_resize), (gst_xvimagesink_get_xv_support),
+	(gst_xvimagesink_xcontext_get): Removing some useless debugs messages,
+	correctly cleaning the image created to check xshm calls on succes,
+	added a lot of XSync calls in X11 functions, and fixed a segfault when
+	no image format was defined before negotiation happened.
+
+2004-01-28  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_query_func):
+	  use gst_element_get_time to get correct time
+
+2004-01-28  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xerror),
+	(gst_ximagesink_check_xshm_calls), (gst_ximagesink_ximage_destroy),
+	(gst_ximagesink_xcontext_get), (gst_ximagesink_class_init):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_handle_xerror),
+	(gst_xvimagesink_check_xshm_calls),
+	(gst_xvimagesink_xvimage_destroy), (gst_xvimagesink_xcontext_get): Our
+	X plugins are now able to detect that XShm calls will fail even if the
+	server claims that it has XShm support (remote displays most of the
+	time). We then log the error as a GST_DEBUG and set use_shm to FALSE
+	so that we use non XShm functions. This feature is almost useless for
+	xvimagesink as Xv is not supported on remote displays anyway, but
+	it might happen than even on the local display XShm calls fail.
+
+2004-01-27  David Schleef  <ds@schleef.org>
+
+	* ext/esd/esdsink.c: (gst_esdsink_class_init), (gst_esdsink_init),
+	(gst_esdsink_link), (gst_esdsink_get_time), (gst_esdsink_chain),
+	(gst_esdsink_change_state):  Fix sync issues in esdsink.  Also
+	changed esdsink to only use 44100,16,2, since esd sucks at rate
+	conversion and esdsink has had difficulty negotiating.
+
+2004-01-27  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_tick_callback),
+	(gst_play_seek_to_time): Fixing the way to get current position.
+
+2004-01-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/oss/gstosssink.c: (gst_osssink_sink_query):
+	  use gst_element_get_time to get correct time
+
+2004-01-27  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_set_location): The easiest
+	fix ever... Inverting 2 lines of code make spider autoplug correctly
+	tagged mp3 !
+
+2004-01-27  David Schleef  <ds@schleef.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	Use gst_pad_try_set_caps_nonfixed().
+
+2004-01-27  David Schleef  <ds@schleef.org>
+
+	* gst/ac3parse/gstac3parse.c: update to checklist 5
+	* gst/adder/gstadder.c: rewrite negotiation.  update to checklist 5
+	* gst/audioconvert/gstaudioconvert.c: update to checklist 5
+	* gst/audioscale/gstaudioscale.c: same
+	* gst/auparse/gstauparse.c: same
+	* gst/avi/gstavidemux.c: same
+
+2004-01-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_handle_sink_event):
+	  stop processing after EOS
+
+2004-01-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/asfdemux/asfheaders.h:
+	* gst/asfdemux/gstasfdemux.c:
+	* gst/asfdemux/gstasfmux.c: (gst_asfmux_put_guid),
+	(gst_asfmux_put_string), (gst_asfmux_put_wav_header),
+	(gst_asfmux_put_vid_header), (gst_asfmux_put_bmp_header):
+	  lot's of fixes to make data extraction simpler and get the code
+	  architecture and compiler independant. Add debugging category
+	* gst/goom/gstgoom.c: (gst_goom_change_state):
+	  reset channel count on PAUSED=>READY, not READY=>PAUSED
+
+2004-01-26  Colin Walters  <walters@verbum.org>
+
+	* ext/gnomevfs/gstgnomevfssrc.c (gst_gnomevfssrc_get): Remove ugly
+	code to pull a bigger buffer in iradio mode.  This as a side effect
+	makes typefinding work.
+
+2004-01-26  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* ext/ffmpeg/gstffmpegcodecmap.c: (gst_ffmpeg_caps_to_extradata):
+	Fix SVQ3 decoding on PPC
+
+2004-01-26  Julien MOUTTE <julien@moutte.net>
+
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_chain): Dunno how
+	that one managed to stay there... Fixed.
+
+2004-01-26  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* ext/ffmpeg/gstffmpegcodecmap.c: (gst_ffmpeg_codecid_to_caps),
+	(gst_ffmpeg_caps_to_extradata), (gst_ffmpeg_caps_to_pixfmt):
+	* gst/qtdemux/qtdemux.c: (plugin_init), (qtdemux_parse_trak),
+	(qtdemux_video_caps):
+	* gst/qtdemux/qtdemux.h:
+	Add SVQ3 specific flags to qtdemux and ffmpeg
+
+2004-01-26  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/audio/audio.h:
+	  remove buffer-frames from audio caps
+	* gst/audioconvert/gstaudioconvert.c:
+	  fix plugin to really work.
+
+2004-01-25  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/mixer/mixer.c:
+	* gst-libs/gst/propertyprobe/propertyprobe.c:
+	* gst-libs/gst/tuner/tuner.c: (gst_tuner_find_norm_by_name),
+	(gst_tuner_find_channel_by_name):
+	* gst-libs/gst/tuner/tuner.h:
+	  Add gtk-doc style comments. Also fix a function name.
+
+2004-01-25  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c: (gst_divxdec_init),
+	(gst_divxdec_negotiate):
+	  Fix for new capsnego - also fixes gst-player with divxdec.
+
+2004-01-25  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_pipeline_setup),
+	(gst_play_identity_handoff), (gst_play_set_location),
+	(gst_play_set_visualization), (gst_play_connect_visualization): Another
+	try in visualization implementation. Still have an issue with switch
+	blocking when pulling from video_queue and only audio comes out of
+	spider.
+	* gst/switch/gstswitch.c: (gst_switch_release_pad),
+	(gst_switch_poll_sinkpads), (gst_switch_class_init): Implementing pad
+	release method. And check if the pad is usable before pulling.
+
+2004-01-25  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_dispose),
+	(gst_videobalance_init),
+	(gst_videobalance_colorbalance_list_channels),
+	(gst_videobalance_colorbalance_set_value),
+	(gst_videobalance_colorbalance_get_value),
+	(gst_videobalance_update_properties),
+	(gst_videobalance_update_tables_planar411),
+	(gst_videobalance_planar411):
+	* gst/videofilter/gstvideobalance.h:
+	  Implement lookup-tables. +/- 10x faster.
+
+2004-01-25  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_avih),
+	(gst_avi_demux_stream_odml), (gst_avi_demux_stream_index):
+	  The index reading was broken. The rest worked fine, but the whole
+	  goal of my rewrite was to make avidemux readable, and this was
+	  not at all readable. Please use typed variables.
+
+2004-01-25  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_info):
+	  Additional pad usability check.
+	* gst/mpeg1videoparse/gstmp1videoparse.c: (gst_mp1videoparse_init),
+	(mp1videoparse_find_next_gop), (gst_mp1videoparse_time_code),
+	(gst_mp1videoparse_real_chain):
+	  Fix MPEG video stream parsing. The original plugin had several
+	  issues, including not timestamping streams where the source was
+	  not timestamped (this happens with PTS values in mpeg system
+	  streams, but MPEG video is also a valid stream on its own so
+	  that needs timestamps too). We use the display time code for that
+	  for now. Also, if one incoming buffer contains multiple valid
+	  frames, we push them all on correctly now, including proper EOS
+	  handling. Lastly, several potential segfaults were fixed, and we
+	  properly sync on new sequence/gop headers to include them in next,
+	  not previous frames (since they're header for the next frame, not
+	  the previous). Also see #119206.
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (gst_mp3parse_chain),
+	(bpf_from_header):
+	  Move caps setting so we only do it after finding several valid
+	  MPEG-1 fraes sequentially, not right after the first one (which
+	  might be coincidental).
+	* gst/typefind/gsttypefindfunctions.c: (mpeg1_sys_type_find),
+	(mpeg_video_type_find), (mpeg_video_stream_type_find),
+	(plugin_init):
+	  Add unsynced MPEG video stream typefinding, and change some
+	  probability values so we detect streams rightly. The idea is as
+	  follows: I can have an unsynced system stream which contains
+	  video. In the current code, I would randomly get a type for either
+	  system or video stream type found, because the probabilities are
+	  being calculated rather randomly. I now use fixed values, so we
+	  always prefer system stream if that was found (and that is how it
+	  should be). If no system stream was found, we can still identity		  the stream as video-only.
+
+2004-01-23  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_avih),
+	(gst_avi_demux_stream_odml), (gst_avi_demux_stream_index):
+	  don't write to buffer. Extract data without the need of
+	  __attribute__ ((packed))
+
+2004-01-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c: (mpeg1_parse_header),
+	(mpeg1_sys_type_find):
+	  Fix MPEG-1 stream typefinding.
+
+2004-01-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c: (mpeg2_sys_type_find):
+	  Fix typefinding for MPEG-1 system streams, similar to MPEG-2.
+
+2004-01-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/esd/esdsink.c: (gst_esdsink_open_audio):
+	* ext/esd/gstesd.c: (plugin_init):
+          private debugging, better error reporting
+
+2004-01-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_class_init),
+	(gst_riff_read_init), (gst_riff_read_change_state):
+	* gst-libs/gst/riff/riff-read.h:
+	  Remove stuff fromold metadata system.
+
+2004-01-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ogg/gstoggdemux.c:
+	  Fix wrong file comment.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_info):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_header):
+	  Add metadata reading properly.
+
+2004-01-23  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/Makefile.am:
+          Fix nas DIST_SUBDIRS
+          Uraeus:
+          Fix bug where make distcheck doesn't get run on adding stuff to
+          the build.
+
+2004-01-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c: (gst_divxdec_init), (gst_divxdec_setup):
+	* ext/divx/gstdivxdec.h:
+	  Fix divx3 ("msmpeg4") playback using divxdec.
+
+2004-01-23  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/typefind/gsttypefindfunctions.c:
+	(mp3_type_frame_length_from_header): fix bug in length computation
+	(mp3_type_find): improve debugging output
+
+2004-01-23  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_pipeline_setup),
+	(gst_play_set_location), (gst_play_seek_to_time),
+	(gst_play_set_audio_sink), (gst_play_set_visualization),
+	(gst_play_connect_visualization), (gst_play_get_sink_element): Reworked
+	the pipeline from scratch. Visualization is back and switch went out as
+	i realized it was not possible to use the way i wanted.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_imagepool_clear),
+	(gst_ximagesink_change_state), (gst_ximagesink_dispose): Move xcontext
+	clearing in state change from READY to NULL. So that one can clean the
+	X ressources keeping the element.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_imagepool_clear), (gst_xvimagesink_change_state),
+	(gst_xvimagesink_colorbalance_set_value),
+	(gst_xvimagesink_colorbalance_get_value),
+	(gst_xvimagesink_set_property), (gst_xvimagesink_dispose),
+	(gst_xvimagesink_init): Same xcontext cleaning than ximagesink in state
+	change from READY to NULL and fixed some stupid bugs in colorbalance
+	get/set values. Also added the following feature : when nobody tries to
+	set some values to the colorbalance levels before the xcontext is
+	grabbed, then when creating channels list from Xv attributes we set the
+	internal values to the Xv defaults. This way we handle buggy Xv drivers
+	that set default hue values far from the middle of the range (Thanks
+	to Jon Trowbridge for pointing that issue).
+	* sys/xvimage/xvimagesink.h: Adding a cb_changed boolean to know if
+	colorbalance levels have been set before xcontext is grabbed.
+
+2004-01-22  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/oss/gstosselement.c: (gst_osselement_class_probe_devices):
+	  Fix the ossmixer case where we shouldn't open /dev/dsp* because
+	  it might block operations (which is bad for a mixer).
+
+2004-01-22  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/media-info/media-info-priv.c: (have_type_callback),
+	(deep_notify_callback), (gmi_set_decoder), (gmi_clear_decoder),
+	(gmip_find_type_pre):
+	* gst-libs/gst/media-info/media-info-priv.h:
+	* gst-libs/gst/media-info/media-info.c:
+	(gst_media_info_instance_init), (gst_media_info_read_idler):
+        add fakesink to get caps on decoder src pad again
+        fix callback prototype to match new have_type signal signature
+
+2004-01-22  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/adder/gstadder.c: (gst_adder_link):
+          fix non-compile and cut-n-paste code
+
+2004-01-21  David Schleef  <ds@schleef.org>
+
+	* ext/swfdec/gstswfdec.c: (gst_swfdec_video_getcaps),
+	(gst_swfdec_video_link), (copy_image), (gst_swfdec_loop),
+	(gst_swfdec_init), (gst_swfdec_change_state):
+	* ext/swfdec/gstswfdec.h:
+	Fix negotiation.
+	* gst/adder/gstadder.c: (gst_adder_link), (gst_adder_init),
+	(gst_adder_request_new_pad): Fix negotiation.
+	* gst/goom/gstgoom.c: (gst_goom_init), (gst_goom_src_fixate):
+	Add a fixate function.
+	* gst/intfloat/gstfloat2int.c:
+	* gst/intfloat/gstfloat2int.h:
+	* gst/intfloat/gstint2float.c:
+	* gst/intfloat/gstint2float.h:
+	Completely rewrite the negotiation.  Doesn't quite work yet,
+	due to some buffer-frames problem.
+
+2004-01-21  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/gnomevfs/gstgnomevfssrc.c:
+	* sys/v4l2/v4l2_calls.h:
+          fix includes for distcheck
+
+2004-01-21  Christian Schaller <uraeus@gnome.org>
+
+	* ext/nas/
+	Add libnas (network audio system) plugin, patch from Arwed von Merkatz
+	based on earlier patch from Laurent Vivier
+
+2004-01-20  Jeremy Simon  <jesimon@libertysurf.fr>
+
+	* ext/ffmpeg/gstffmpegcodecmap.c: (gst_ffmpeg_caps_to_extradata):
+	Fix wma caps property
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_audio_caps):
+	Fix typo (flags1 and flags2)
+
+2004-01-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/media-info/media-info-priv.c:
+	(deep_notify_callback), (gmi_seek_to_track), (gmi_get_decoder),
+	(gmip_find_type_pre), (gmip_find_type), (gmip_find_stream_post),
+	(gmip_find_stream), (gmip_find_track_metadata),
+	(gmip_find_track_streaminfo_post), (gmip_find_track_streaminfo),
+	(gmip_find_track_format):
+	* gst-libs/gst/media-info/media-info-priv.h:
+	* gst-libs/gst/media-info/media-info-test.c: (main):
+	* gst-libs/gst/media-info/media-info.c: (gst_media_info_init),
+	(gst_media_info_read_idler), (gst_media_info_read):
+	* gst-libs/gst/media-info/media-info.h:
+          register debugging category and use it for debugging
+
+2004-01-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/vorbis/vorbisfile.c: (gst_vorbisfile_update_streaminfo),
+	(gst_vorbisfile_new_link):
+          signal streaminfo through tags
+
+2004-01-20  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mplex/gstmplex.cc:
+	* ext/mplex/gstmplexibitstream.cc:
+	  g++ doesn't like NULL in our i18n/error macros, should be
+	  either (NULL) or ("").
+
+2004-01-20  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/dxr3/dxr3audiosink.c:
+	* sys/dxr3/dxr3init.c:
+	* sys/dxr3/dxr3spusink.c: (dxr3spusink_close):
+	* sys/dxr3/dxr3videosink.c: (dxr3videosink_close):
+	  Fix more error error error errors (missing includes here).
+
+2004-01-20  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mpeg2enc/gstmpeg2encpicturereader.cc:
+	  fix thomas' error errors.
+
+2004-01-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+          fix error errors.
+
+2004-01-20  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c: (gst_divxdec_setup), (gst_divxdec_chain):
+	* ext/divx/gstdivxenc.c: (gst_divxenc_setup), (gst_divxenc_chain):
+	  Fix for new error system.
+
+2004-01-20  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/divx/gstdivxenc.c: (gst_divxenc_setup), (gst_divxenc_chain):
+          fix for new error reporting
+
+2004-01-20  David Schleef  <ds@schleef.org>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xevents),
+	(gst_ximagesink_xcontext_get), (gst_ximagesink_getcaps),
+	(gst_ximagesink_set_xwindow_id): Change to using a framerate
+	of [1,100] instead of [0,MAX], since 0 isn't handled correctly,
+	and neither is 100+, most likely.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support),
+	(gst_xvimagesink_getcaps): same
+
+2004-01-19  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* configure.ac:
+	  Up version requirement to 2.0.3 (not yet released) to avoid symbol
+	  clashes with ffmpeg.
+
+2004-01-20  Julien MOUTTE  <julien@moutte.net>
+
+	* gst/switch/gstswitch.c: (gst_switch_request_new_pad),
+	(gst_switch_init): Fixed switch element : proxying link and setting
+	caps from src to sink on request.
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_overlay):
+	* sys/v4l2/v4l2-overlay_calls.c: (gst_v4l2_set_display),
+	(gst_v4l2_set_window), (gst_v4l2_enable_overlay):
+        fix element_error
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l/v4l_calls.h:
+	* sys/v4l2/v4l2_calls.h:
+          element_error fixes
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/gst-i18n-plugin.h:
+          add locale.h
+          remove config.h inclusion
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* autogen.sh:
+          adding autopoint invocation
+	* Makefile.am:
+	* configure.ac:
+	* gst-libs/gst/gettext.h:
+          adding gettext bits
+	* ext/audiofile/gstafsink.c: (gst_afsink_plugin_init):
+	* ext/audiofile/gstafsrc.c: (gst_afsrc_plugin_init):
+	* ext/gnomevfs/gstgnomevfs.c: (plugin_init):
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_open_file),
+	(gst_gnomevfssink_close_file):
+	* ext/gnomevfs/gstgnomevfssrc.c: (gst_gnomevfssrc_open_file):
+	* ext/sndfile/gstsf.c: (gst_sf_loop), (plugin_init):
+	* gst-libs/gst/gst-i18n-plugin.h:
+	* gst/avi/gstavi.c: (plugin_init):
+	* sys/dxr3/dxr3init.c: (plugin_init):
+	* sys/dxr3/dxr3videosink.c: (dxr3videosink_write_data):
+	* sys/oss/gstossaudio.c: (plugin_init):
+	* sys/oss/gstosselement.c: (gst_osselement_open_audio):
+	* sys/v4l/gstv4l.c: (plugin_init):
+	* sys/v4l/v4l_calls.c: (gst_v4l_open):
+	* sys/v4l2/gstv4l2.c: (plugin_init):
+	* sys/v4l2/v4l2_calls.c: (gst_v4l2_get_capabilities),
+	(gst_v4l2_fill_lists), (gst_v4l2_get_norm), (gst_v4l2_set_norm),
+	(gst_v4l2_get_input), (gst_v4l2_set_input), (gst_v4l2_get_output),
+	(gst_v4l2_set_output), (gst_v4l2_get_frequency),
+	(gst_v4l2_set_frequency), (gst_v4l2_signal_strength),
+	(gst_v4l2_get_attribute), (gst_v4l2_set_attribute):
+	  make sure locale and translation domain are set
+          fix translated strings
+	* po/.cvsignore:
+	* po/LINGUAS:
+	* po/Makevars:
+	* po/POTFILES.in:
+	* po/nl.po:
+          put translation files into place
+	* sys/xvideo/imagetest.c: (main):
+	* ext/dv/demo-play.c: (main):
+          fix unnecessary translations
+
+2004-01-19  Thomas Vander Stichele  <thomas (at) apestaart (dot) org>
+
+	* ext/sndfile/gstsf.c:
+	* gst/avi/gstavimux.c:
+	* ext/audiofile/gstafsink.c:
+	* ext/audiofile/gstafsrc.c:
+	* ext/gnomevfs/gstgnomevfssink.c:
+	* ext/gnomevfs/gstgnomevfssrc.c:
+	* sys/oss/gstosselement.c:
+	* sys/v4l/v4l_calls.h:
+          fix i18n include
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/v4l2/v4l2_calls.c: (gst_v4l2_get_capabilities),
+	(gst_v4l2_fill_lists), (gst_v4l2_open), (gst_v4l2_get_norm),
+	(gst_v4l2_set_norm), (gst_v4l2_get_input), (gst_v4l2_set_input),
+	(gst_v4l2_get_output), (gst_v4l2_set_output),
+	(gst_v4l2_get_frequency), (gst_v4l2_set_frequency),
+	(gst_v4l2_signal_strength), (gst_v4l2_get_attribute),
+	(gst_v4l2_set_attribute):
+        update to new error handling
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ext/sidplay/gstsiddec.cc:
+	* gst/modplug/gstmodplug.cc:
+          parenthese NULL because C++ seems angry about it
+
+2004-01-19  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/gst-i18n-plugin.h:
+          add skeleton i18n stuff, but needs to be further implemented
+
+2004-01-18  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* examples/gstplay/player.c: (main):
+	* ext/aalib/gstaasink.c: (gst_aasink_open):
+	* ext/alsa/gstalsa.c: (gst_alsa_link), (gst_alsa_xrun_recovery):
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_loop):
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_loop):
+	* ext/audiofile/gstafsink.c: (gst_afsink_open_file),
+	(gst_afsink_close_file):
+	* ext/audiofile/gstafsrc.c: (gst_afsrc_open_file),
+	(gst_afsrc_close_file):
+	* ext/divx/gstdivxdec.c: (gst_divxdec_setup), (gst_divxdec_chain):
+	* ext/dv/gstdvdec.c: (gst_dvdec_loop):
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_user_op), (dvdnavsrc_get):
+	* ext/esd/esdmon.c: (gst_esdmon_get):
+	* ext/esd/esdsink.c: (gst_esdsink_chain):
+	* ext/faac/gstfaac.c: (gst_faac_chain):
+	* ext/faad/gstfaad.c: (gst_faad_chain):
+	* ext/ffmpeg/gstffmpegdec.c: (gst_ffmpegdec_chain):
+	* ext/ffmpeg/gstffmpegdemux.c: (gst_ffmpegdemux_loop):
+	* ext/ffmpeg/gstffmpegmux.c: (gst_ffmpegmux_loop):
+	* ext/flac/gstflacdec.c: (gst_flacdec_error_callback),
+	(gst_flacdec_loop):
+	* ext/flac/gstflacenc.c: (gst_flacenc_chain):
+	* ext/flac/gstflactag.c: (gst_flac_tag_chain):
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_chain):
+	* ext/gnomevfs/gstgnomevfssink.c: (gst_gnomevfssink_open_file),
+	(gst_gnomevfssink_close_file):
+	* ext/gnomevfs/gstgnomevfssrc.c: (audiocast_init),
+	(gst_gnomevfssrc_open_file):
+	* ext/ivorbis/vorbisfile.c: (gst_ivorbisfile_loop):
+	* ext/lame/gstlame.c: (gst_lame_sink_link), (gst_lame_chain):
+	* ext/lcs/gstcolorspace.c: (gst_colorspace_srcconnect_func):
+	* ext/mad/gstid3tag.c: (gst_id3_tag_handle_event),
+	(gst_id3_tag_do_typefind), (gst_id3_tag_chain):
+	* ext/mad/gstmad.c: (gst_mad_chain):
+	* ext/mikmod/gstmikmod.c: (gst_mikmod_loop):
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	* ext/mpeg2enc/gstmpeg2encpicturereader.cc:
+	* ext/mplex/gstmplex.cc:
+	* ext/mplex/gstmplexibitstream.cc:
+	* ext/ogg/gstoggdemux.c: (gst_ogg_demux_chain),
+	(gst_ogg_demux_push), (gst_ogg_pad_push):
+	* ext/raw1394/gstdv1394src.c:
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_lock),
+	(gst_sdlvideosink_initsdl), (gst_sdlvideosink_create):
+	* ext/sidplay/gstsiddec.cc:
+	* ext/sndfile/gstsf.c: (gst_sf_open_file), (gst_sf_close_file),
+	(gst_sf_loop):
+	* ext/speex/gstspeexenc.c: (gst_speexenc_chain):
+	* ext/tarkin/gsttarkindec.c: (gst_tarkindec_chain):
+	* ext/tarkin/gsttarkinenc.c: (gst_tarkinenc_chain):
+	* ext/vorbis/vorbisenc.c: (gst_vorbisenc_chain):
+	* ext/vorbis/vorbisfile.c: (gst_vorbisfile_loop):
+	* ext/xvid/gstxviddec.c: (gst_xviddec_setup), (gst_xviddec_chain):
+	* ext/xvid/gstxvidenc.c: (gst_xvidenc_setup), (gst_xvidenc_chain):
+	* gst-libs/gst/Makefile.am:
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_peek_head),
+	(gst_riff_read_element_data), (gst_riff_read_seek),
+	(gst_riff_peek_list), (gst_riff_read_list), (gst_riff_read_header):
+	* gst/adder/gstadder.c: (gst_adder_parse_caps), (gst_adder_loop):
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_process_segment),
+	(gst_asf_demux_process_stream), (gst_asf_demux_get_stream):
+	* gst/avi/gstavidemux.c: (gst_avi_demux_stream_init),
+	(gst_avi_demux_add_stream), (gst_avi_demux_stream_header):
+	* gst/avi/gstavimux.c: (gst_avimux_stop_file):
+	* gst/flx/gstflxdec.c: (gst_flxdec_loop):
+	* gst/goom/gstgoom.c: (gst_goom_chain):
+	* gst/id3/gstid3types.c: (gst_id3types_loop):
+	* gst/intfloat/gstfloat2int.c: (gst_float2int_loop):
+	* gst/intfloat/gstint2float.c: (gst_int2float_chain_gint16):
+	* gst/matroska/ebml-read.c: (gst_ebml_read_element_id),
+	(gst_ebml_read_element_length), (gst_ebml_read_element_data),
+	(gst_ebml_read_seek), (gst_ebml_read_uint), (gst_ebml_read_sint),
+	(gst_ebml_read_float), (gst_ebml_read_header):
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_init_stream),
+	(gst_matroska_demux_parse_blockgroup):
+	* gst/modplug/gstmodplug.cc:
+	* gst/monoscope/gstmonoscope.c: (gst_monoscope_chain):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_loop):
+	* gst/oneton/gstoneton.c: (gst_oneton_chain):
+	* gst/silence/gstsilence.c: (gst_silence_get):
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_get):
+	* gst/smpte/gstsmpte.c: (gst_smpte_loop):
+	* gst/speed/gstspeed.c: (speed_loop):
+	* gst/tags/gstvorbistag.c: (gst_vorbis_tag_chain):
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_get):
+	* gst/volenv/gstvolenv.c: (gst_volenv_chain):
+	* gst/wavenc/gstwavenc.c: (gst_wavenc_chain):
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_parse_fmt),
+	(gst_wavparse_loop):
+	* sys/dxr3/dxr3audiosink.c: (dxr3audiosink_open),
+	(dxr3audiosink_set_mode_pcm), (dxr3audiosink_set_mode_ac3),
+	(dxr3audiosink_close):
+	* sys/dxr3/dxr3spusink.c: (dxr3spusink_open), (dxr3spusink_close):
+	* sys/dxr3/dxr3videosink.c: (dxr3videosink_open),
+	(dxr3videosink_close), (dxr3videosink_write_data):
+	* sys/oss/gstosselement.c: (gst_osselement_open_audio):
+	* sys/oss/gstosselement.h:
+	* sys/oss/gstosssink.c: (gst_osssink_get_type), (gst_osssink_init),
+	(gst_osssink_chain):
+	* sys/oss/gstosssrc.c: (gst_osssrc_get):
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_chain):
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_buffer_free):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_buffer_free):
+	* sys/v4l/v4l-overlay_calls.c: (gst_v4l_set_window),
+	(gst_v4l_enable_overlay):
+	* sys/v4l/v4l_calls.c: (gst_v4l_get_capabilities), (gst_v4l_open),
+	(gst_v4l_set_chan_norm), (gst_v4l_get_signal),
+	(gst_v4l_get_frequency), (gst_v4l_set_frequency),
+	(gst_v4l_get_picture), (gst_v4l_set_picture), (gst_v4l_get_audio),
+	(gst_v4l_set_audio):
+	* sys/v4l/v4l_calls.h:
+	* sys/v4l/v4lmjpegsink_calls.c: (gst_v4lmjpegsink_sync_thread),
+	(gst_v4lmjpegsink_queue_frame), (gst_v4lmjpegsink_set_playback),
+	(gst_v4lmjpegsink_playback_init),
+	(gst_v4lmjpegsink_playback_start):
+	* sys/v4l/v4lmjpegsrc_calls.c: (gst_v4lmjpegsrc_queue_frame),
+	(gst_v4lmjpegsrc_sync_next_frame), (gst_v4lmjpegsrc_set_capture),
+	(gst_v4lmjpegsrc_set_capture_m), (gst_v4lmjpegsrc_capture_init),
+	(gst_v4lmjpegsrc_requeue_frame):
+	* sys/v4l/v4lsrc_calls.c: (gst_v4lsrc_queue_frame),
+	(gst_v4lsrc_sync_frame), (gst_v4lsrc_capture_init),
+	(gst_v4lsrc_requeue_frame), (gst_v4lsrc_try_palette):
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_get):
+	* sys/v4l2/v4l2src_calls.c: (gst_v4l2src_fill_format_list),
+	(gst_v4l2src_queue_frame), (gst_v4l2src_grab_frame),
+	(gst_v4l2src_get_capture), (gst_v4l2src_set_capture),
+	(gst_v4l2src_capture_init), (gst_v4l2src_capture_start),
+	(gst_v4l2src_capture_stop):
+	* sys/vcd/vcdsrc.c: (vcdsrc_open_file):
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get),
+	(gst_ximagesink_chain):
+	* sys/xvideo/xvideosink.c: (gst_xvideosink_buffer_new),
+	(gst_xvideosink_sinkconnect), (gst_xvideosink_chain),
+	(gst_xvideosink_xwindow_new):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_chain):
+        use new error signal, function and categories
+
+2004-01-18  Jeremy Simon <jesimon@libertysurf.fr>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/musicbrainz/gsttrm.c:
+	* ext/musicbrainz/gsttrm.h:
+	* ext/musicbrainz/Makefile.am:
+	Add a trm plugin
+
+2004-01-18  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_set_property),
+	(gst_ximagesink_get_property), (gst_ximagesink_class_init): Adding
+	synchronous property for debugging.
+	* sys/ximage/ximagesink.h: Adding the synchronous boolean flag.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_set_property): Moving a pointer declaration to a
+	smaller block, fixing indent.
+
+2004-01-16  David Schleef  <ds@schleef.org>
+
+	* gst/videofilter/gstvideobalance.c: Fix regression; changing a
+	property affects the video stream.
+	* sys/xvimage/xvimagesink.c:
+	* sys/xvimage/xvimagesink.h:
+	Add synchronous property for debugging.  Should probably be
+	disabled in non-CVS builds.  Make sure that the Xv attribute
+	exists before we set it (crash!).  Fix a silly float bug that
+	caused colorbalance to just not work.
+
+2004-01-17  Christian Schaller <Uraeus@gnome.org>
+
+	* tools/gst-launch-ext.in - update for new plugins
+
+2004-01-16  David Schleef  <ds@schleef.org>
+
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_connect): Fix use of
+	already-freed caps.
+
+2994-01-16  Christian Schaller <Uraeus@gnome.org>
+
+	* Update spec for new colorspace plugin and libcaca plugin
+	* Fix compilation of libcaca plugin (clock -> id)
+
+2004-01-16  Julien MOUTTE <julien@moutte.net>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_update_colorbalance),
+	(gst_xvimagesink_xcontext_get), (gst_xvimagesink_change_state),
+	(gst_xvimagesink_set_xwindow_id),
+	(gst_xvimagesink_colorbalance_set_value),
+	(gst_xvimagesink_colorbalance_get_value),
+	(gst_xvimagesink_set_property), (gst_xvimagesink_get_property),
+	(gst_xvimagesink_init), (gst_xvimagesink_class_init): Implementing
+	correct colorbalance properties. They can now be set when the element
+	is still in NULL state. The values will be committed to the Xv Port
+	when xcontext is initialized.
+	* sys/xvimage/xvimagesink.h: Added hue, saturation, contrast,
+	brightness int values in the GstXvImagesink structure.
+
+2004-01-16  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst-libs/gst/Makefile.am:
+	  restructure so having local patches works easier.
+
+2004-01-16  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mpeg2enc/Makefile.am:
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	* ext/mpeg2enc/gstmpeg2encpicturereader.cc:
+	  Bugfix with respect to EOS handling.
+
+2004-01-16  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_connect):
+	  Link with right caps (else, it segfaults).
+	* ext/mplex/gstmplexjob.cc:
+	  Fix for slight API change in 1.6.1.93 release of mjpegtools.
+
+2004-01-15  David Schleef  <ds@schleef.org>
+
+	* gst-libs/gst/audio/Makefile.am:
+	Add gstaudiofiltertemplate.c and building of gstaudiofilterexample.c
+	from the template.
+	* gst-libs/gst/audio/gstaudiofilter.c:
+	* gst-libs/gst/audio/gstaudiofilter.h:
+	Add bytes_per_sample and size and n_samples calculation.
+	* gst-libs/gst/audio/gstaudiofilterexample.c:
+	Remove, now autogenerated.
+	* gst-libs/gst/audio/gstaudiofiltertemplate.c:
+	Moved from gstaudiofilterexample, object name changed, code added
+	so that it actually works.
+	* gst-libs/gst/audio/make_filter:
+	Script to build an audiofilter subclass from the template.
+	* gst/colorspace/Makefile.am:
+	* gst/colorspace/yuv2yuv.c:
+	Remove file, since it's GPL, and we don't use it.
+
+2004-01-15  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain): Making both of
+	them use the buffer free function to test how the buffer was allocated.
+
+2004-01-15  David Schleef  <ds@schleef.org>
+
+	* ext/esd/esdsink.c: (gst_esdsink_class_init): Remove property
+	that handles osssink fallback.
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_init),
+	(gst_audio_convert_getcaps):
+	* gst/qtdemux/qtdemux.c: (qtdemux_audio_caps):
+	Add audio/x-qdm2 for QDM2 audio.
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_get):
+	* gst/sine/gstsinesrc.h: Add example of how to implement tags.
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_getcaps):
+	Decrease minimum size to 16x16.
+	* gst/wavparse/gstwavparse.c:
+	Convert disabled pad template caps to new caps.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_chain): Throw element error when display cannot
+	be opened.  Increase minimum framerate to 1.0.  Check the data
+	free function on a buffer to make sure it is the type we expect
+	before manipulating it.
+
+2004-01-15  Julien MOUTTE <julien@moutte.net>
+
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_init),
+	(gst_videobalance_colorbalance_set_value): Implement passthru if
+	settings are in the middle.
+	* tools/gst-launch-ext.in: Stop using xvideosink, use ximagesink.
+
+2004-01-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/videofilter/Makefile.am:
+	* gst/volume/Makefile.am:
+	  Since we use videofilter symbols, link to it.
+
+2004-01-15  Julien MOUTTE <julien@moutte.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_interface_init): Setting
+	mixer interface type to HARDWARE.
+	* gst-libs/gst/mixer/mixer.c: (gst_mixer_class_init): Adding a default
+	type to SOFTWARE.
+	* gst-libs/gst/mixer/mixer.h: Adding mixer interface type and macro.
+	* gst-libs/gst/mixer/mixertrack.h: Adding mixertrack flag SOFTWARE.
+	* gst/volume/gstvolume.c: (gst_volume_interface_supported),
+	(gst_volume_interface_init), (gst_volume_list_tracks),
+	(gst_volume_set_volume), (gst_volume_get_volume),
+	(gst_volume_set_mute), (gst_volume_mixer_init),
+	(gst_volume_dispose), (gst_volume_get_type), (volume_class_init),
+	(volume_init): Implementing mixer interface.
+	* gst/volume/gstvolume.h: Adding tracklist for mixer interface.
+	* sys/oss/gstosselement.c: (gst_osselement_get_type),
+	(gst_osselement_change_state): Removing some trailing commas in
+	structures.
+	* sys/oss/gstossmixer.c: (gst_ossmixer_interface_init): Setting mixer
+	interface type to HARDWARE.
+	* sys/v4l/gstv4lcolorbalance.c:
+	(gst_v4l_color_balance_interface_init): Setting colorbalance interface
+	type to HARDWARE.
+	* sys/v4l2/gstv4l2colorbalance.c:
+	(gst_v4l2_color_balance_interface_init): Setting colorbalance
+	interface type to HARDWARE.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain): use exactly the
+	same code than ximagesink for event handling.
+
+2004-01-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/snapshot/Makefile.am:
+	* ext/snapshot/gstsnapshot.c: (gst_snapshot_sinkconnect),
+	(gst_snapshot_chain):
+	* ext/snapshot/gstsnapshot.h:
+	  This has to be a joke... Snapshot should be connected to a tee,
+	  colorspace element before it and EOS after that, where the other
+	  src of the tee receives normal data.
+	  The current way is *wrong*.
+
+2004-01-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/hermes/gsthermescolorspace.c:
+	  Fix another compile error. Same as below.
+
+2004-01-15  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/colorspace/gstcolorspace.c:
+	* gst/colorspace/yuv2yuv.c: (gst_colorspace_yuy2_to_i420),
+	(gst_colorspace_i420_to_yv12):
+	  Fix compiling... Didn't test if it actually works.
+
+2004-01-15  David Schleef  <ds@schleef.org>
+
+	* configure.ac:
+	* gst/colorspace/Makefile.am:
+	* gst/colorspace/gstcolorspace.c:
+	* gst/colorspace/gstcolorspace.h:
+	* gst/colorspace/yuv2rgb.c:
+	* gst/colorspace/yuv2rgb.h:
+	Duplicate the ext/hermes colorspace plugin, and remove Hermes
+	code and GPL code.  Fix for new caps negotiation.  Rewrite
+	much of the format handling code, and some of the conversion
+	code.  Basically, rewrote almost everything.  This element
+	handles I420, YV12 to RGB conversions.
+	* ext/hermes/Makefile.am:
+	* ext/hermes/gsthermescolorspace.c:
+	Rename colorspace to hermescolorspace.  Fix negotiation issues.
+	Remove non-Hermes related code.  This element handles lots of
+	RGB to RGB conversions, but no YUV.
+	* ext/hermes/gstcolorspace.c:
+	* ext/hermes/gstcolorspace.h:
+	* ext/hermes/rgb2yuv.c:
+	* ext/hermes/yuv2rgb.c:
+	* ext/hermes/yuv2rgb.h:
+	* ext/hermes/yuv2rgb_mmx16.s:
+	* ext/hermes/yuv2yuv.c:
+	* ext/hermes/yuv2yuv.h:
+	Remove old code.
+
+2004-01-14  Colin Walters  <walters@verbum.org>
+
+	* ext/mad/gstid3tag.c (gst_id3_tag_chain): Don't nego caps if
+	they've already been.
+
+2004-01-15  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_do_caps_nego):
+	  assume tag mode when pad is not connected
+
+2004-01-15  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	  Don't update the time of the clock
+	(gst_alsa_sink_loop):
+	  sync to the clock given to alsasink, not the own clock
+	* sys/oss/gstosssink.c: (gst_osssink_chain):
+	  sync to the clock
+	(gst_osssink_change_state):
+	  activate the clock
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain):
+	  remove bogus code that made DISCONT events unhandled
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_video_caps):
+	  explicitly case to double in _set_simple. (fixes 2nd warning in bug
+	  #131502)
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_read_object_header),
+	(gst_asf_demux_handle_sink_event), (gst_asf_demux_audio_caps),
+	(gst_asf_demux_add_audio_stream), (gst_asf_demux_video_caps):
+	  convert g_warning because of wrong asf data to GST_WARNINGs (fixes
+	  2nd warning in bug #131502)
+
+2004-01-14  Julien MOUTTE  <julien@moutte.net>
+
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_init),
+	(gst_videobalance_colorbalance_set_value),
+	(gst_videobalance_colorbalance_get_value): Fixing videobalance ranges
+	for colorbalance interface implementation.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get),
+	(gst_ximagesink_set_property), (gst_ximagesink_get_property),
+	(gst_ximagesink_dispose), (gst_ximagesink_init),
+	(gst_ximagesink_class_init): Adding DISPLAY property.
+	* sys/ximage/ximagesink.h: Adding display_name to store display.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_set_property), (gst_xvimagesink_get_property),
+	(gst_xvimagesink_dispose), (gst_xvimagesink_init),
+	(gst_xvimagesink_class_init): Adding DISPLAY property and colorbalance
+	properties (they still need polishing though for gst-launch use : no
+	xcontext yet, i ll do that tomorrow).
+	* sys/xvimage/xvimagesink.h: Adding display_name to store display.
+
+2004-01-14  Julien MOUTTE  <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_pipeline_setup),
+	(gst_play_set_location), (gst_play_set_visualization): Preparing
+	switch integration, adding videobalance in the pipeline.
+
+2004-01-14  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/colorbalance/colorbalance.c:
+	(gst_color_balance_class_init): Adding a default type.
+	* gst-libs/gst/colorbalance/colorbalance.h: Adding a macro to access
+	the type.
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_get_type),
+	(gst_videobalance_dispose), (gst_videobalance_class_init),
+	(gst_videobalance_init), (gst_videobalance_interface_supported),
+	(gst_videobalance_interface_init),
+	(gst_videobalance_colorbalance_list_channels),
+	(gst_videobalance_colorbalance_set_value),
+	(gst_videobalance_colorbalance_get_value),
+	(gst_videobalance_colorbalance_init): Implementing colorbalance
+	interface.
+	* gst/videofilter/gstvideobalance.h: Adding colorbalance channels
+	list.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_set_xwindow_id): Fixing a
+	bug which was triggering a BadAccess X error when setting an overlay
+	before pad was really negotiated.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_colorbalance_init):
+	Using the colorbalance type macro.
+
+2004-01-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/flac/gstflacenc.c: (gst_flacenc_set_metadata),
+	(gst_flacenc_chain):
+	  handle tags correctly
+	* gst/tags/gstid3tag.c: (gst_tag_list_new_from_id3v1):
+	  extract ID3v1 tags correctly
+
+2004-01-14  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/typefind/gsttypefindfunctions.c: (matroska_type_find),
+	(plugin_init):
+	  Improve matroska typefinding for odd-typed headers...
+
+2004-01-14  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_add_stream):
+	  Fix for using incremental number on padnames.
+
+2004-01-14  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c:
+	* ext/divx/gstdivxenc.c:
+	  Set category to divx4linux instead of divx (too generic).
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_init),
+	(gst_wavparse_parse_fmt), (gst_wavparse_handle_sink_event),
+	(gst_wavparse_loop), (gst_wavparse_change_state):
+	* gst/wavparse/gstwavparse.h:
+	  fix parsing of WAV files with non-standard fmt-tag size and fix
+	  skipping of unrecognized chunks... Someone please fix this thing
+	  to use rifflib so all this is automated.
+	* sys/v4l/Makefile.am:
+	* sys/v4l2/Makefile.am:
+	  Add X_CFLAGS because we depend on X (for overlay).
+
+2004-01-14  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	  Don't issue a timestamp unless we tagged the frame
+	  with a PTS.
+
+2004-01-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_tick_callback):
+	  Query the audio element to get the time, not the clock. We're
+	  interested in the element's time here.
+
+2004-01-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/aalib/gstaasink.c: (gst_aasink_chain):
+	* ext/alsa/gstalsasink.c: (gst_alsa_sink_check_event):
+	* ext/esd/esdsink.c: (gst_esdsink_chain):
+	* ext/libcaca/gstcacasink.c: (gst_cacasink_chain):
+	* ext/mas/massink.c: (gst_massink_chain):
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_chain):
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_parse_index),
+	(gst_matroska_demux_parse_metadata):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_loop),
+	(gst_mpeg_parse_release_locks):
+	* gst/tcp/gsttcpsink.c: (gst_tcpsink_chain):
+	* gst/udp/gstudpsink.c: (gst_udpsink_chain):
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_get):
+	* sys/oss/gstosssink.c: (gst_osssink_init), (gst_osssink_chain),
+	(gst_osssink_change_state):
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_chain):
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain):
+	* sys/xvideo/xvideosink.c: (gst_xvideosink_chain),
+	(gst_xvideosink_release_locks):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain):
+	  use element time.
+	* ext/alsa/gstalsaclock.c: (gst_alsa_clock_start),
+	(gst_alsa_clock_stop):
+	* gst-libs/gst/audio/audioclock.c: (gst_audio_clock_set_active),
+	(gst_audio_clock_get_internal_time):
+	  simplify for use with new clocking code.
+	* testsuite/alsa/Makefile.am:
+	* testsuite/alsa/sinesrc.c: (sinesrc_init), (sinesrc_force_caps):
+	  fix testsuite for new caps system
+
+2004-01-14  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/flac/gstflacdec.c: (gst_flacdec_update_metadata):
+	* ext/flac/gstflacenc.c: (add_one_tag):
+	  length is already host endian, no need to convert. Fixes playback of
+	  tagged files on PPC. (bug #128384)
+
+2004-01-13  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/colorbalance/colorbalance.h: Adding a type to the
+	colorbalance interface stating if it is hardware based or software
+	based.
+	* gst/videofilter/gstvideobalance.c: (gst_videobalance_planar411):
+	Removing a trailing comma.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_colorbalance_init): Integrating a patch from Jon
+	Trowbridge <trow@ximian.com> querying Xv adaptor for min/max value as
+	the documentation seems to be wrong on the -1000 to 1000 interval.
+
+2004-01-12  David Schleef  <ds@schleef.org>
+
+	* gst/debug/efence.c: (gst_efence_init), (gst_efence_chain),
+	(gst_efence_buffer_alloc), (gst_fenced_buffer_new),
+	(gst_fenced_buffer_default_free), (gst_fenced_buffer_default_copy):
+	Fix negotiation.  Add a bufferalloc function for the sink pad,
+	and generally clean up some of the code.
+
+2004-01-12  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/colorbalance/colorbalancechannel.c:
+	(gst_color_balance_channel_dispose): Adding safety check in dispose
+	method.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_xcontext_clear),
+	(gst_xvimagesink_interface_supported),
+	(gst_xvimagesink_colorbalance_list_channels),
+	(gst_xvimagesink_colorbalance_set_value),
+	(gst_xvimagesink_colorbalance_get_value),
+	(gst_xvimagesink_colorbalance_init), (gst_xvimagesink_get_type):
+	Adding colorbalance interface support to set XV parameters such as
+	HUE, BRIGHTNESS, CONTRAST, SATURATION.
+	* sys/xvimage/xvimagesink.h: Adding the channels list for colorbalance
+	interface.
+
+2004-01-12  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_get_type),
+	(gst_audio_convert_class_init), (gst_audioconvert_getcaps),
+	(gst_audio_convert_init), (gst_audio_convert_set_property),
+	(gst_audio_convert_get_property), (gst_audio_convert_chain),
+	(gst_audio_convert_link),
+	(gst_audio_convert_buffer_to_default_format),
+	(gst_audio_convert_buffer_from_default_format), (plugin_init):
+          - implement _getcaps and use it
+          - improve linking
+          - remove float caps since no float conversion is actually done
+          - remove properties and arguments that were to be used for rate
+            conversion
+
+2004-01-12  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst-libs/gst/audio/audio.c: (_gst_audio_structure_set_list),
+	(gst_audio_structure_set_int):
+	* gst-libs/gst/audio/audio.h:
+          add helper functions for _getcaps matching the standard audio
+          templates
+
+2004-01-12  David Schleef  <ds@schleef.org>
+
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_link):
+	Test that pad is negotiated before getting its caps.
+
+2004-01-12  Julien MOUTTE <julien@moutte.net>
+
+	* gst-libs/gst/play/gstplay.c: (gst_play_get_sink_element): When
+	analyzing the pads of an element the bin is mostly in READY state so
+	no caps were negotiated. This helper function needs to work with
+	_get_caps directly then. I was not freeing them though, added that to
+	fix the mem leak.
+
+2004-01-12  Julien MOUTTE <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain): Fixing the
+	direct put buffers detection. I prefer checking GST_BUFFER_PRIVATE
+	than the free_func.
+
+2004-01-12  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* sys/oss/gstossaudio.c: (plugin_init):
+	* sys/oss/gstosselement.c: (gst_osselement_sync_parms):
+	* sys/oss/gstosselement.h:
+          make an oss debugging category
+          make failure more descriptive
+
+2004-01-11  David Schleef  <ds@schleef.org>
+
+	* ext/ffmpeg/gstffmpeg.c:
+	* ext/ffmpeg/gstffmpegcodecmap.c:
+	* ext/ffmpeg/gstffmpegdec.c:
+	* ext/ffmpeg/gstffmpegenc.c:
+	* ext/ffmpeg/gstffmpegprotocol.c:
+	* ext/gdk_pixbuf/gstgdkanimation.c:
+	* ext/jpeg/gstjpeg.c:
+	* ext/libpng/gstpng.c:
+	* ext/mpeg2dec/perftest.c:
+	* ext/speex/gstspeex.c:
+	* gst-libs/gst/resample/dtos.c:
+	* gst/intfloat/gstintfloatconvert.c:
+	* gst/oneton/gstoneton.c:
+	* gst/rtjpeg/RTjpeg.c:
+	* gst/rtp/gstrtp.c:
+	* sys/dxr3/dxr3init.c:
+	* sys/glsink/gstgl_nvimage.c:
+	* sys/glsink/gstgl_pdrimage.c:
+	* sys/glsink/gstglsink.c:
+	* testsuite/gst-lint:
+	Make sure everybody wraps #include "config.h" in #ifdef HAVE_CONFIG_H
+
+2004-01-11  David Schleef  <ds@schleef.org>
+
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_set_caps):
+	* ext/faac/gstfaac.c: (gst_faac_sinkconnect):
+	* ext/gdk_pixbuf/gstgdkanimation.c:
+	(gst_gdk_animation_iter_create_pixbuf):
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_sink_link),
+	(gst_gdk_pixbuf_chain):
+	* ext/gdk_pixbuf/gstgdkpixbuf.h:
+	* ext/jack/gstjack.c: (gst_jack_change_state):
+	* ext/xvid/gstxviddec.c: (gst_xviddec_sink_link):
+	* gst-libs/gst/play/gstplay.c: (gst_play_get_sink_element):
+	* gst-libs/gst/play/play.c: (gst_play_get_sink_element):
+	* gst/videofilter/gstvideofilter.c:
+	(gst_videofilter_set_output_size):
+	Remove all usage of gst_pad_get_caps(), and replace it with
+	gst_pad_get_allowed_caps() or gst_pad_get_negotiated_cap().
+
+2004-01-11  David Schleef  <ds@schleef.org>
+
+	* configure.ac:
+	* ext/Makefile.am: Fixes to make ext/libcaca compile.
+	* ext/divx/gstdivxdec.c:
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_sink_link),
+	(gst_gdk_pixbuf_init), (gst_gdk_pixbuf_chain): Make gdkpixbufdec
+	handle images that span multiple buffers.  Now work with both
+	filesrc ! gdkpixbufdec and qtdemux ! gdkpixbufdec.
+	* ext/gdk_pixbuf/gstgdkpixbuf.h:
+	* ext/libcaca/gstcacasink.h: Fixes needed due to recent
+	video/video.h changes
+	* ext/xvid/gstxvid.c: (gst_xvid_csp_to_caps): same
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_get),
+	(gst_v4lmjpegsrc_buffer_free): Use buffer free function instead
+	of GstData free function.
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_get), (gst_v4lsrc_buffer_free):
+	same.
+
+2004-01-12  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/v4l2/gstv4l2element.c: (gst_v4l2element_class_init),
+	(gst_v4l2element_dispose), (gst_v4l2element_set_property),
+	(gst_v4l2element_get_property):
+	* sys/v4l2/v4l2_calls.c: (gst_v4l2_set_defaults), (gst_v4l2_open):
+	  add norm, channel and frequency properties.
+	* sys/v4l2/gstv4l2tuner.c:
+	  fixes for tuner interface changes
+	* sys/v4l2/gstv4l2element.h:
+	* sys/v4l2/gstv4l2src.c:
+	* sys/v4l2/gstv4l2src.h:
+	* sys/v4l2/v4l2src_calls.c:
+	* sys/v4l2/v4l2src_calls.h:
+	  rework v4l2src to work with saa1734 cards and allow mmaped buffers.
+
+2004-01-12  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/tuner/tuner.c: (gst_tuner_class_init),
+	(gst_tuner_find_norm_by_name), (gst_v4l2_find_channel_by_name),
+	(gst_tuner_channel_changed), (gst_tuner_norm_changed),
+	(gst_tuner_frequency_changed), (gst_tuner_signal_changed):
+	* gst-libs/gst/tuner/tuner.h:
+	  GObjects aren't const.
+	  Add find_by_name functions.
+	  Add checks to _changed functions.
+	* sys/v4l/gstv4ltuner.c: (gst_v4l_tuner_get_channel),
+	(gst_v4l_tuner_get_norm):
+	  Fixes for above.
+
+2004-01-12  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/video/video.h:
+	  Fix caps template names to be understandable.
+	  Prefix everything with GST_VIDEO.
+	* ext/aalib/gstaasink.c:
+	* ext/divx/gstdivxdec.c:
+	* ext/divx/gstdivxenc.c:
+	* ext/gdk_pixbuf/gstgdkpixbuf.c:
+	* ext/hermes/gstcolorspace.c: (gst_colorspace_base_init):
+	* ext/jpeg/gstjpegdec.c: (raw_caps_factory):
+	* ext/jpeg/gstjpegenc.c: (raw_caps_factory):
+	* ext/libcaca/gstcacasink.c:
+	* ext/libpng/gstpngenc.c: (raw_caps_factory):
+	* ext/snapshot/gstsnapshot.c:
+	* ext/swfdec/gstswfdec.c:
+	* ext/xvid/gstxviddec.c:
+	* ext/xvid/gstxvidenc.c:
+	* gst/chart/gstchart.c:
+	* gst/deinterlace/gstdeinterlace.c:
+	* gst/effectv/gsteffectv.c:
+	* gst/flx/gstflxdec.c: (gst_flxdec_loop):
+	* gst/goom/gstgoom.c:
+	* gst/median/gstmedian.c:
+	* gst/monoscope/gstmonoscope.c: (gst_monoscope_init),
+	(gst_monoscope_srcconnect), (gst_monoscope_chain):
+	* gst/overlay/gstoverlay.c:
+	* gst/smooth/gstsmooth.c:
+	* gst/smpte/gstsmpte.c:
+	* gst/synaesthesia/gstsynaesthesia.c:
+	* gst/videocrop/gstvideocrop.c:
+	* gst/videodrop/gstvideodrop.c:
+	* gst/y4m/gsty4mencode.c:
+	* sys/qcam/gstqcamsrc.c:
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_palette_to_caps):
+	  Make them work with new video.h file.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain),
+	(gst_ximagesink_buffer_free), (gst_ximagesink_buffer_alloc):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain),
+	(gst_xvimagesink_buffer_free), (gst_xvimagesink_buffer_alloc):
+	  Make it work with new buffer allocation system.
+
+2004-01-11  Julien MOUTTE  <julien@moutte.net>
+
+	* ext/ffmpeg/gstffmpegcolorspace.c: (gst_ffmpegcsp_chain): Fixing the
+	pad_alloc_buffer implementation to use ->srcpad
+	* ext/hermes/gstcolorspace.c: (gst_colorspace_chain): Fixing the
+        pad_alloc_buffer implementation to use ->srcpad
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_chain):  Fixing the
+        pad_alloc_buffer implementation to use ->srcpad
+	* sys/ximage/ximagesink.c: (gst_ximagesink_ximage_new),
+	(gst_ximagesink_chain), (gst_ximagesink_buffer_free),
+	(gst_ximagesink_buffer_alloc): Now only use GST_BUFFER_PRIVATE to keep
+	a reference to everything we need.
+	* sys/ximage/ximagesink.h: adding a reference to the sink in the image.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xvimage_new),
+	(gst_xvimagesink_chain), (gst_xvimagesink_buffer_free),
+	(gst_xvimagesink_buffer_alloc): Now only use GST_BUFFER_PRIVATE to keep
+        a reference to everything we need.
+	* sys/xvimage/xvimagesink.h: adding a reference to the sink in the image
+
+2004-01-11  David Schleef  <ds@schleef.org>
+
+	* ext/divx/gstdivxenc.c: remove bogus gst_caps_is_fixed() test
+	* gst/debug/efence.c: (gst_efence_chain), (gst_fenced_buffer_new),
+	(gst_fenced_buffer_default_copy): Fix for rename of buffer private
+	structure members.
+	* gst/effectv/gstwarp.c: (gst_warptv_setup): Don't reset the time
+	value during a resize/renegotiation.
+	* gst/videofilter/gstvideofilter.c: (gst_videofilter_chain): use
+	gst_pad_alloc_buffer();
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_get),
+	(gst_v4lmjpegsrc_buffer_free): Fix for rename of buffer private
+	structure members.
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_get), (gst_v4lsrc_buffer_free):
+	Fix for rename of buffer private structure members.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain),
+	(gst_ximagesink_buffer_free), (gst_ximagesink_buffer_alloc):
+	Fix for rename of buffer private structure members.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain),
+	(gst_xvimagesink_buffer_free), (gst_xvimagesink_buffer_alloc):
+	Fix for rename of buffer private structure members.
+
+2004-01-11  Arwed v. Merkatz <v.merkatz@gmx.net>
+
+	reviewed by: David Schleef <ds@schleef.org>
+
+	* gst/videofilter/Makefile.am:
+	* gst/videofilter/gstgamma.c: Gamma correction filter.  Modified
+	from the patch by ds to fit in with recent make_filter changes.
+
+2004-01-11  Julien MOUTTE  <julien@moutte.net>
+
+	* configure.ac: Adding examples/switch/Makefile
+	* examples/Makefile.am: Adding examples/switch
+	* examples/switch/Makefile.am: Adding switcher example.
+	* examples/switch/switcher.c: (got_eos), (idle_iterate),
+	(switch_timer), (main): Adding an example demonstrating switch usage
+	with 2 videotestsrc showing different patterns.
+	* gst/switch/gstswitch.c: (gst_switch_request_new_pad),
+	(gst_switch_init): Fixing switch with the new caps system.
+
+2004-01-11  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/video/video.h:
+	  Fix 32bit caps. Issue remaining: The macro names are chosen poorly.
+	  They should probably be like
+	  GST_VIDEO_PAD_TEMPLATE_CAPS_{RGB,BGR,RGBx,BGRx}.
+
+2004-01-11  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(qtdemux_parse_trak):
+	  fix audio chunk size/timestamp calculation
+
+2004-01-11  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/ffmpeg/gstffmpegcodecmap.c: (gst_ffmpeg_codecid_to_caps):
+	  fix SVQ3 caps
+
+2004-01-11  Steve Baker  <steve@stevebaker.org>
+
+	* gst/effectv/gstaging.c: (gst_agingtv_get_type),
+	(gst_agingtv_base_init), (gst_agingtv_class_init),
+	(gst_agingtv_init), (gst_agingtv_setup), (gst_agingtv_rgb32),
+	(gst_agingtv_set_property), (gst_agingtv_get_property):
+        Port agingTV to videofilter
+
+2004-01-09  Julien MOUTTE <julien@moutte.net>
+
+	* ext/hermes/gstcolorspace.c: (gst_colorspace_chain):
+	Implementing gst_pad_alloc_buffer to use optimized buffer allocation.
+
+2004-01-09  Julien MOUTTE <julien@moutte.net>
+
+	* ext/ffmpeg/gstffmpegcolorspace.c: (gst_ffmpegcsp_chain):
+	Implementing gst_pad_alloc_buffer to use optimized buffer allocation.
+	* gst-libs/gst/xoverlay/xoverlay.c:
+	(gst_x_overlay_got_desired_size): Updating doc for the xid being 0.
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_chain):
+	Implementing gst_pad_alloc_buffer to use optimized buffer allocation.
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_get):
+	Implementing gst_pad_alloc_buffer to use optimized buffer allocation.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_chain),
+	(gst_ximagesink_buffer_free), (gst_ximagesink_buffer_alloc),
+	(gst_ximagesink_set_xwindow_id), (gst_ximagesink_init): Implementing
+	the bufferalloc_function to replace bufferpools, fixing the XOverlay
+	interface implementation to handle xid being 0 and fix some bugs
+	triggered by Benjamin's testcase.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_chain),
+	(gst_xvimagesink_buffer_free), (gst_xvimagesink_buffer_alloc),
+	(gst_xvimagesink_set_xwindow_id), (gst_xvimagesink_init): Implementing
+	the bufferalloc_function to replace bufferpools, fixing the XOverlay
+	interface implementation to handle xid being 0 and fix some bugs
+	triggered by Benjamin's testcase.
+
+2004-01-09  David Schleef  <ds@schleef.org>
+
+	* ext/librfb/gstrfbsrc.c:  Hacking.  Added actual decoding and
+	mouse pointer events.  It works.
+
+2004-01-09  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxenc.c: (gst_divxenc_init):
+	  Use explicit caps - fix capsnego.
+	* ext/xvid/gstxviddec.c:
+	* ext/xvid/gstxvidenc.c:
+	  Remove macro-inside-macro which caused compile errors.
+	* gst-libs/gst/riff/riff-read.c: (gst_riff_read_header):
+	  Error out if it's not a RIFF file. Else we error out without
+	  gst_element_error() which is not good...
+
+2004-01-08  David Schleef  <ds@schleef.org>
+
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_connect):
+	Fix pad_link function to handle formats that ffmpeg returns
+	as multiple caps structures.
+	* gst/videofilter/gstvideofilter.c: (gst_videofilter_chain):
+	Only complain if source buffer is _smaller_ than expected.
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_init),
+	(gst_videoscale_handle_src_event): Resize navigation events
+	when passing them upstream.
+	* gst/videotestsrc/gstvideotestsrc.c:
+	* gst/videotestsrc/gstvideotestsrc.h:
+	* gst/videotestsrc/videotestsrc.c:
+	* gst/videotestsrc/videotestsrc.h:
+	Rewrite many of the buffer painting functions to handle odd
+	sizes (for many formats, size%4!=0 or size%8!=0).  Most have
+	been verified to work with my video card.
+	* testsuite/gst-lint:  Add check for elements calling
+	gst_pad_get_caps() instead of gst_pad_get_allowed_caps().
+
+2004-01-08  David Schleef  <ds@schleef.org>
+
+	* gst/videodrop/gstvideodrop.c: (gst_videodrop_getcaps),
+	(gst_videodrop_link), (gst_videodrop_init): Fix negotiation.
+
+2004-01-08  Julien MOUTTE  <julien@moutte.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xevents): A
+	configure event is not emiting the desired size signal. That fixes
+	aspect ratio issues with gst-player.
+
+2004-01-08  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/median/gstmedian.c: (gst_median_link), (gst_median_init):
+	  Fix capsnego.
+
+2004-01-08  Julien MOUTTE  <julien@moutte.net>
+
+	* ext/sdl/sdlvideosink.c: (gst_sdlvideosink_create): Using XOverlay
+	public method to fire size signal.
+
+2004-01-07  Julien MOUTTE  <julien@moutte.net>
+
+	* examples/gstplay/Makefile.am: Adding the interface library.
+	* gst-libs/gst/play/Makefile.am: Adding the interface library.
+	* gst-libs/gst/play/gstplay.c: (gst_play_set_video_sink): Connecting to 	the XOverlay size signal instead of GstVideoSink.
+	* gst-libs/gst/play/gstplay.h: Including the XOverlay interface to check
+	GST_IS_X_OVERLAY before signal connect.
+	* gst-libs/gst/video/gstvideosink.c: (gst_videosink_class_init):
+	Removing the have_video_size signal.
+	* gst-libs/gst/video/gstvideosink.h: Removing the have_video_size signal
+	and associated public method.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xevents),
+	(gst_ximagesink_sinkconnect): Using XOverlay public method to fire size
+	signal.
+	* sys/xvideo/xvideosink.c: (gst_xvideosink_sinkconnect),
+	(gst_xvideosink_xwindow_new): Using XOverlay public method to fire size
+        signal.
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_sinkconnect):
+	Using XOverlay public method to fire size signal.
+
+2004-01-07  David Schleef  <ds@schleef.org>
+
+	* gst/videofilter/Makefile.am:
+	* gst/videofilter/gstvideotemplate.c:
+	* gst/videofilter/make_filter:
+	Create gstvideoexample.c in a srcdir!=builddir friendly way.
+	Convert make_filter to /bin/sh script.
+
+2004-01-07  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* gst/modplug/gstmodplug.cc: fix element description
+
+2004-01-07  Julien MOUTTE  <julien@moutte.net>
+
+	* examples/gstplay/player.c: (got_time_tick), (got_stream_length),
+	(got_video_size): Adding some new lines in g_print calls.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_new),
+	(gst_ximagesink_xwindow_destroy), (gst_ximagesink_xwindow_resize),
+	(gst_ximagesink_handle_xevents), (gst_ximagesink_fixate),
+	(gst_ximagesink_sinkconnect), (gst_ximagesink_change_state),
+	(gst_ximagesink_chain), (gst_ximagesink_buffer_new),
+	(gst_ximagesink_set_xwindow_id), (gst_ximagesink_get_desired_size):
+	Complete code review, reverting some stuff i disagree with, adding
+	some fixes : time synchronization on invalid timestamps, renegotiation
+	of private window.
+	* sys/ximage/ximagesink.h:
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_xwindow_destroy),
+	(gst_xvimagesink_xwindow_resize), (gst_xvimagesink_handle_xevents),
+	(gst_xvimagesink_get_xv_support), (gst_xvimagesink_xcontext_get),
+	(gst_xvimagesink_fixate), (gst_xvimagesink_sinkconnect),
+	(gst_xvimagesink_change_state), (gst_xvimagesink_chain),
+	(gst_xvimagesink_buffer_new),
+	(gst_xvimagesink_navigation_send_event),
+	(gst_xvimagesink_set_xwindow_id),
+	(gst_xvimagesink_get_desired_size),
+	(gst_xvimagesink_xoverlay_init): Complete code review, reverting some
+	stuff i disagree with, adding some fixes : Renegotiation of private
+	window, implementing get_desired_size.
+
+2004-01-07  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/audiofile/gstafsink.c: (gst_afsink_init), (gst_afsink_chain),
+	(gst_afsink_handle_event):
+	* ext/jpeg/gstjpegenc.c: (gst_jpegenc_init):
+	* gst/avi/gstavimux.c: (gst_avimux_request_new_pad):
+	* sys/dxr3/dxr3audiosink.c: (dxr3audiosink_init):
+	* sys/dxr3/dxr3spusink.c: (dxr3spusink_init):
+	* sys/dxr3/dxr3videosink.c: (dxr3videosink_init):
+	  Fix for instantiate-test (see core). Also remove dead code from
+	  jpegenc (which still needs fixing, but that's lower on my TODO
+	  list...).
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_getcaps):
+	  Never return NULL as caps.
+
+2004-01-07  David Schleef  <ds@schleef.org>
+
+	* configure.ac:
+	* ext/Makefile.am:
+	* ext/librfb/Makefile.am:
+	* ext/librfb/gstrfbsrc.c:
+	New source plugin based on librfb-0.1.  RFB (remote framebuffer)
+	is the protocol used by VNC.
+
+2004-01-07  David Schleef  <ds@schleef.org>
+
+	* gst/videofilter/gstvideotemplate.c:
+	* gst/videofilter/gstvideotemplate.h:
+	* gst/videofilter/make_filter:
+	Merge videotemplate header into source file.
+	* gst/effectv/Makefile.am:
+	* gst/effectv/gsteffectv.c: (plugin_init):
+	* gst/effectv/gstwarp.c:
+	Make warpTV a subclass of videofilter.
+
+2004-01-07  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_mad_id3_to_tag_list):
+	  Add guard against invalid utf-8 conversions in mad. Just in case.
+
+2004-01-07  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/oss/gstosssink.c: (gst_osssink_sink_fixate):
+	  Fix for bug shown by poisoning
+
+2004-01-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_get),
+	(gst_v4lmjpegsrc_buffer_free):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_palette_to_caps),
+	(gst_v4lsrc_srcconnect), (gst_v4lsrc_getcaps), (gst_v4lsrc_get),
+	(gst_v4lsrc_buffer_free):
+	  Fix for removed bufferpools.
+
+2004-01-07  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/dv/gstdvdec.c: (gst_dvdec_loop):
+	Fix caps negotiation.
+
+	* ext/dvdnav/dvdnavsrc.c: (dvdnavsrc_class_init),
+	(dvdnavsrc_update_buttoninfo), (dvdnavsrc_get),
+	(dvdnavsrc_get_event_mask), (dvdnav_handle_navigation_event),
+	(dvdnavsrc_event):
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	* gst-libs/gst/navigation/navigation.c:
+	(gst_navigation_send_key_event), (gst_navigation_send_mouse_event):
+	* gst-libs/gst/navigation/navigation.h:
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_handle_src_event):
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xevents):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_handle_xevents):
+	Super-simple first version of mouse and keyboard events. Clicking
+	on a DVD menu now works, although it may not take you where you
+	expected.
+
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_src_fixate):
+	* gst/videotestsrc/gstvideotestsrc.c:
+	(gst_videotestsrc_src_fixate):
+	These fixate functions were broken - they never actually
+	fixated :)
+
+2004-01-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/shout/gstshout.c: (gst_icecastsend_base_init),
+	(gst_icecastsend_init):
+	  fix for new caps system.
+	* gst-libs/gst/mixer/mixertrack.h:
+	* sys/oss/gstossmixer.c: (gst_ossmixer_build_list):
+	  Add 'master track' flag (for tools like ACME that only want to
+	  change the main volume).
+
+2004-01-07  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* ext/xvid/gstxvid.c: (gst_xvid_structure_to_csp),
+	(gst_xvid_csp_to_caps):
+	* ext/xvid/gstxviddec.c: (gst_xviddec_src_getcaps):
+	* ext/xvid/gstxvidenc.c:
+	ifdef out ARGB type when it isn't available
+	in xvidcore 1.0.0beta2
+
+2004-01-06  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_loop):
+	  When we have received a new SCR right in the first buffer after
+	  a seek (so in the same cycle that handles the discont), we should
+	  handle the buffer instead of unreffing it, else we lose data.
+
+2004-01-06  Iain <iain@prettypeople.org>
+
+	* gst/intfloat/gstint2float.c (gst_int2float_link): Set the
+	  buffer-frames caps too.
+
+	* gst/oneton/gstoneton.c (gst_oneton_sink_connect): Only create the new
+	  caps that we need, don't destroy them all and rebuild them. And when
+	  creating src pads, use the src pad template rather than the sink...
+
+2004-01-05  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead):
+	  Add pad to element *after* setting functions such as event handler.
+	  Without this, the scheduler (opt) will link pads, set the event
+	  handler from the default event function (dispatcher in gstpad.c)
+	  and *after* that, we will set our own event function, which will
+	  thus never be used (and thus mpegdemux doesn't handle events).
+
+2004-01-04  David Schleef  <ds@schleef.org>
+
+	Fix the fixate functions to handle new prototype:
+	* gst/sine/gstsinesrc.c: (gst_sinesrc_src_fixate):
+	* gst/videotestsrc/gstvideotestsrc.c:
+	(gst_videotestsrc_src_fixate):
+	* sys/oss/gstosssink.c: (gst_osssink_sink_fixate):
+	* sys/ximage/ximagesink.c: (gst_ximagesink_fixate):
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_fixate):
+
+2004-01-04  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/ximage/ximagesink.h:
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xwindow_new),
+	(gst_ximagesink_xwindow_destroy), (gst_ximagesink_sinkconnect),
+	(gst_ximagesink_change_state), (gst_ximagesink_set_xwindow_id),
+	(gst_ximagesink_xoverlay_init):
+	  assorted fixes to make (re)embedding work
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sinkconnect),
+	(gst_ximagesink_get_desired_size):
+	  implement desired size additions to XOverlay
+
+2004-01-04  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst-libs/gst/xoverlay/xoverlay.c: (gst_x_overlay_base_init),
+	(gst_x_overlay_got_xwindow_id), (gst_x_overlay_get_desired_size),
+	(gst_x_overlay_got_desired_size):
+	* gst-libs/gst/xoverlay/xoverlay.h:
+	  Add optional "desired size" signal and querying.
+
+2004-01-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_blockgroup):
+	  Fix EBML-laced block parsing. Diffs are relative to previous
+	  lace, not the first lace. Thanks to Mosu from the Matroska
+	  team for detecting this.
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_init),
+	(gst_wavparse_parse_fmt), (gst_wavparse_getcaps),
+	(gst_wavparse_handle_sink_event), (gst_wavparse_loop),
+	(gst_wavparse_change_state):
+	* gst/wavparse/gstwavparse.h:
+	  Quickfix for capsnego.
+
+2004-01-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/wavenc/gstwavenc.c: (set_property), (gst_wavenc_init):
+	  Fix indenting, fix pad creation.
+
+2004-01-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/xvid/gstxviddec.c: (gst_xviddec_init),
+	(gst_xviddec_src_getcaps), (gst_xviddec_src_link),
+	(gst_xviddec_sink_link):
+	  Implement src_getcaps() so proper size caps is negotiated.
+
+2004-01-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/flac/gstflacdec.c: (gst_flacdec_loop):
+	  Finish flac decoder on EOS. See #116178.
+
+2004-01-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_src_getcaps),
+	(gst_matroska_demux_add_stream):
+	* gst/matroska/matroska-ids.h:
+	  Add getcaps() function to fix capsnego...
+
+2004-01-04  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead),
+	(gst_mpeg_demux_parse_packet), (gst_mpeg_demux_parse_pes):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_parse_packhead):
+	  Fix more integer overflows. Again, see #126967.
+
+2004-01-03  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mpeg2dec/gstmpeg2dec.c:
+	  Add support for mpeg2dec-0.4.0 (released two weeks ago). See
+	  #130416.
+
+2004-01-03  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	* ext/xvid/gstxvid.c: (gst_xvid_init), (gst_xvid_error),
+	(gst_xvid_structure_to_csp), (gst_xvid_csp_to_caps):
+	* ext/xvid/gstxvid.h:
+	* ext/xvid/gstxviddec.c: (gst_xviddec_class_init),
+	(gst_xviddec_init), (gst_xviddec_setup), (gst_xviddec_chain),
+	(gst_xviddec_src_link), (gst_xviddec_sink_link),
+	(gst_xviddec_change_state):
+	* ext/xvid/gstxviddec.h:
+	* ext/xvid/gstxvidenc.c: (gst_xvidenc_profile_get_type),
+	(gst_xvidenc_base_init), (gst_xvidenc_class_init),
+	(gst_xvidenc_init), (gst_xvidenc_setup), (gst_xvidenc_chain),
+	(gst_xvidenc_link), (gst_xvidenc_set_property),
+	(gst_xvidenc_get_property), (gst_xvidenc_change_state):
+	* ext/xvid/gstxvidenc.h:
+	  Update xvid plugin to latest xvid (1.0.0-beta3) API.
+
+2004-01-03  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/rtp/rtp-packet.c:
+	  Add sys/types.h include, since OS X doesn't define in_addr_t
+	  in netinet/in.h, like it does on Linux (see #129600).
+
+2004-01-03  Thomas Canty <tommydal@optushome.com.au>
+
+	reviewed by: Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/alsa/gstalsamixer.c: (gst_alsa_mixer_dispose):
+	  Correct logic of dispose function (see #129306).
+
+2004-01-03  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_pes):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_class_init),
+	(gst_mpeg_parse_init):
+	* gst/mpegstream/gstmpegparse.h:
+	  Remove clock (which was never provided, i.e. dead code), and
+	  also fix integer overflows at high PTS values (see #126967).
+
+2004-01-03  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/flac/gstflacdec.c:
+	* ext/libpng/gstpngenc.h:
+	* ext/mikmod/gstmikmod.h:
+	  OS X fixes (see #126628).
+
+2004-01-02  David Schleef  <ds@schleef.org>
+
+	* ext/alsa/gstalsasrc.c: (gst_alsa_src_pad_factory),
+	(gst_alsa_src_base_init): Remove bogus "src" request pad.
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_base_init),
+	(gst_mpeg_parse_class_init): Move pad template registration
+	to class_init, since the derived class (mpegdemux) doesn't
+	want them.
+
+2004-01-03  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/ximage/Makefile.am:
+	* sys/xvideo/Makefile.am:
+	* sys/xvimage/Makefile.am:
+	  Move interface libs from LDFLAGS to LIBADD, fix relocation errors
+	  after installation (see #127664).
+
+2004-01-02  David Schleef  <ds@schleef.org>
+
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_init),
+	(gst_ffmpegenc_connect):  Negotiation fixes.
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_negotiate_format):
+	Remove inappropriate gst_caps_free().
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sinkconnect):
+	Reenable Ronald's internal resize code, since the core handles
+	it correctly now.
+
+2004-01-02  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/v4l/gstv4lmjpegsink.c: (gst_v4lmjpegsink_init):
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_init):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_base_init), (gst_v4lsrc_init):
+	  Fix pad template stuff.
+
+2004-01-02  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* gst/matroska/ebml-read.c: (gst_ebml_read_sint):
+	* gst/matroska/ebml-write.c: (gst_ebml_write_sint):
+	  fix signed integer reading/writing.
+
+2004-01-02  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/README:
+	  Remove outdated document
+
+2004-01-03  Jan Schmidt  <thaytan@mad.scientist.com>
+
+	* gst/cutter/gstcutter.c: (gst_cutter_init):
+	  src pad was being created twice - oops.
+
+2004-01-02  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sinkconnect):
+	  Comment out internal resize. It doesn't handle the resulting
+	  XEvent internally, does another try_set_caps() which leads to
+	  a really nice loop.
+	  Real fix will come when Julien and Dave are awake. ;).
+
+2004-01-02  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	  fix const/nonconst compile issue.
+
+2004-01-02  David Schleef  <ds@schleef.org>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_fixate),
+	(gst_xvimagesink_sinkconnect), (gst_xvimagesink_init):
+	Add fixate function and a check for bad formats.
+
+2004-01-01  David Schleef  <ds@schleef.org>
+
+	Negotiation fixes:
+	* gst-libs/gst/audio/gstaudiofilter.c: (gst_audiofilter_link),
+	(gst_audiofilter_init):
+	* gst/debug/efence.c: (gst_efence_init):
+	* gst/deinterlace/gstdeinterlace.c: (gst_deinterlace_link),
+	(gst_deinterlace_init):
+	* gst/volume/gstvolume.c: (volume_connect):
+
+2004-01-01  David Schleef  <ds@schleef.org>
+
+	Convert elements to use gst_pad_use_explicit_caps() where
+	appropriate:
+	* ext/a52dec/gsta52dec.c: (gst_a52dec_init), (gst_a52dec_reneg):
+	* ext/audiofile/gstafparse.c: (gst_afparse_init),
+	(gst_afparse_open_file):
+	* ext/audiofile/gstafsrc.c: (gst_afsrc_init),
+	(gst_afsrc_open_file):
+	* ext/esd/esdmon.c: (gst_esdmon_init), (gst_esdmon_get):
+	* ext/ffmpeg/gstffmpegdec.c: (gst_ffmpegdec_init),
+	(gst_ffmpegdec_chain):
+	* ext/ffmpeg/gstffmpegdemux.c: (gst_ffmpegdemux_loop):
+	* ext/flac/gstflacdec.c: (gst_flacdec_init), (gst_flacdec_write):
+	* ext/gdk_pixbuf/gstgdkpixbuf.c: (gst_gdk_pixbuf_init),
+	(gst_gdk_pixbuf_chain):
+	* ext/jpeg/gstjpegdec.c: (gst_jpegdec_init), (gst_jpegdec_link),
+	(gst_jpegdec_chain):
+	* ext/mad/gstmad.c: (gst_mad_init), (gst_mad_chain):
+	* ext/mikmod/gstmikmod.c: (gst_mikmod_init),
+	(gst_mikmod_negotiate):
+	* ext/mpeg2dec/gstmpeg2dec.c: (gst_mpeg2dec_init),
+	(gst_mpeg2dec_negotiate_format):
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	* ext/ogg/gstoggdemux.c: (gst_ogg_pad_push):
+	* ext/speex/gstspeexdec.c: (gst_speexdec_init),
+	(gst_speexdec_sinkconnect):
+	* ext/swfdec/gstswfdec.c: (gst_swfdec_loop), (gst_swfdec_init):
+	* ext/vorbis/vorbisfile.c: (gst_vorbisfile_init),
+	(gst_vorbisfile_new_link):
+	* gst/ac3parse/gstac3parse.c: (gst_ac3parse_init),
+	(gst_ac3parse_chain):
+	* gst/asfdemux/gstasfdemux.c: (gst_asf_demux_add_audio_stream),
+	(gst_asf_demux_setup_pad):
+	* gst/auparse/gstauparse.c: (gst_auparse_init),
+	(gst_auparse_chain):
+	* gst/id3/gstid3types.c: (gst_id3types_loop):
+	* gst/matroska/matroska-demux.c: (gst_matroska_demux_add_stream):
+	* gst/mpeg1videoparse/gstmp1videoparse.c: (gst_mp1videoparse_init),
+	(mp1videoparse_parse_seq):
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (gst_mp3parse_init),
+	(bpf_from_header):
+	* gst/mpegstream/gstmpegdemux.c: (gst_mpeg_demux_parse_syshead),
+	(gst_mpeg_demux_parse_pes), (gst_mpeg_demux_lpcm_set_caps):
+	* gst/mpegstream/gstmpegparse.c: (gst_mpeg_parse_init),
+	(gst_mpeg_parse_send_data):
+	* gst/qtdemux/qtdemux.c: (gst_qtdemux_loop_header),
+	(gst_qtdemux_add_stream):
+	* gst/realmedia/rmdemux.c: (gst_rmdemux_add_stream):
+	* gst/wavparse/gstwavparse.c: (gst_wavparse_init),
+	(gst_wavparse_parse_fmt):
+
+2004-01-01  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	  Fix configure check for mpeg2enc. We need 1.6.1.93 instead of
+	  1.6.1.92, since the pkg-config file of 1.6.1.92 is borked and
+	  it therefore uses the wrong include paths. Too bad... Note
+	  that 1.6.1.93 is not release yet. ;).
+	  Also add a check for mplex, which is now using the lib'ified
+	  mplex from mjpegtools, too.
+	* ext/ffmpeg/gstffmpegcodecmap.c:
+	  Add codec_tag for 3ivx/xvid. For xvid, this should fix playback
+	  issues. I don't think ffmpeg handles 3ivx correctly, so this
+	  probably won't work. But it won't hurt either.
+	* ext/ffmpeg/gstffmpegdec.c: (gst_ffmpegdec_connect),
+	(gst_ffmpegdec_chain):
+	* ext/ffmpeg/gstffmpegenc.c: (gst_ffmpegenc_connect),
+	(gst_ffmpegenc_chain_audio):
+	  Fix memleak in audio encoding. Close codec if open fails, this
+	  calls the cleanup routines so we can re-use the context.
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	  Fix pad template names/types, fix memory issue with getcaps().
+	* ext/mpeg2enc/gstmpeg2encoder.cc:
+	* ext/mpeg2enc/gstmpeg2encoder.hh:
+	  Fix compile issue with new caps system (const thingy).
+	* ext/mpeg2enc/gstmpeg2encpicturereader.cc:
+	* ext/mpeg2enc/gstmpeg2encpicturereader.hh:
+	  We read a first frame right on initing, so that we have a caps
+	  when we init the output. This caps is cached in padprivate and
+	  read as first frame.
+	* ext/mplex/Makefile.am:
+	* ext/mplex/gstmplex.cc:
+	* ext/mplex/gstmplex.h:
+	* ext/mplex/gstmplex.hh:
+	* ext/mplex/gstmplexibitstream.cc:
+	* ext/mplex/gstmplexibitstream.hh:
+	* ext/mplex/gstmplexjob.cc:
+	* ext/mplex/gstmplexjob.hh:
+	* ext/mplex/gstmplexoutputstream.cc:
+	* ext/mplex/gstmplexoutputstream.hh:
+	  We wrap mjpegtools mplex. So I rewrote the plugin. The old plugin
+	  had issues, didn't do capsnego, supported only a subset of the
+	  mplex features and required a mplex fork in our local CVS. Plus
+	  that it worked agaist a very old mplex version. Rewriting was
+	  faster than updating it.
+	* gst-libs/ext/Makefile.am:
+	* gst-libs/ext/mplex/INSTRUCT:
+	* gst-libs/ext/mplex/Makefile.am:
+	* gst-libs/ext/mplex/README:
+	* gst-libs/ext/mplex/TODO:
+	* gst-libs/ext/mplex/ac3strm_in.cc:
+	* gst-libs/ext/mplex/audiostrm.hh:
+	* gst-libs/ext/mplex/audiostrm_out.cc:
+	* gst-libs/ext/mplex/aunit.hh:
+	* gst-libs/ext/mplex/bits.cc:
+	* gst-libs/ext/mplex/bits.hh:
+	* gst-libs/ext/mplex/buffer.cc:
+	* gst-libs/ext/mplex/buffer.hh:
+	* gst-libs/ext/mplex/fastintfns.h:
+	* gst-libs/ext/mplex/format_codes.h:
+	* gst-libs/ext/mplex/inputstrm.cc:
+	* gst-libs/ext/mplex/inputstrm.hh:
+	* gst-libs/ext/mplex/lpcmstrm_in.cc:
+	* gst-libs/ext/mplex/mjpeg_logging.cc:
+	* gst-libs/ext/mplex/mjpeg_logging.h:
+	* gst-libs/ext/mplex/mjpeg_types.h:
+	* gst-libs/ext/mplex/mpastrm_in.cc:
+	* gst-libs/ext/mplex/mpegconsts.cc:
+	* gst-libs/ext/mplex/mpegconsts.h:
+	* gst-libs/ext/mplex/mplexconsts.hh:
+	* gst-libs/ext/mplex/multplex.cc:
+	* gst-libs/ext/mplex/outputstream.hh:
+	* gst-libs/ext/mplex/padstrm.cc:
+	* gst-libs/ext/mplex/padstrm.hh:
+	* gst-libs/ext/mplex/stillsstream.cc:
+	* gst-libs/ext/mplex/stillsstream.hh:
+	* gst-libs/ext/mplex/systems.cc:
+	* gst-libs/ext/mplex/systems.hh:
+	* gst-libs/ext/mplex/vector.cc:
+	* gst-libs/ext/mplex/vector.hh:
+	* gst-libs/ext/mplex/videostrm.hh:
+	* gst-libs/ext/mplex/videostrm_in.cc:
+	* gst-libs/ext/mplex/videostrm_out.cc:
+	* gst-libs/ext/mplex/yuv4mpeg.cc:
+	* gst-libs/ext/mplex/yuv4mpeg.h:
+	* gst-libs/ext/mplex/yuv4mpeg_intern.h:
+	* gst-libs/ext/mplex/yuv4mpeg_ratio.cc:
+	  We don't fork mjpegtools' mplex in our CVS anymore.
+	* gst/avi/gstavidemux.c: (gst_avi_demux_src_getcaps),
+	(gst_avi_demux_add_stream):
+	* gst/avi/gstavidemux.h:
+	  Add getcaps() function for proper caps nego. This makes some
+	  parts of AVI playback/reading work.
+	* sys/ximage/ximagesink.c: (gst_ximagesink_sinkconnect):
+	  Resize window on new capsnego. This is probably wrong, but
+	  I'm still committing it because with current capsnego, the
+	  first successfull capsnego is auto-fixated, therefore rounded
+	  down to the lowest values in the caps. this results in a 16x16
+	  XWindow that is not reized when real capsnego finishes.
+	  Dave, I see more cases of this, do you know a proper solution?
+	* tools/gst-launch-ext.in:
+	  Fix MPEG-4 AAC (Apple iPod/iTunes) file commandline.
+
+2003-12-31  David Schleef  <ds@schleef.org>
+
+	* gst/tcp/gsttcpsrc.c: (gst_tcpsrc_get):
+	* gst/udp/gstudpsrc.c: (gst_udpsrc_get):
+	  Change gst_pad_proxy_link() to gst_pad_try_set_caps()
+
+2003-12-30  David Schleef  <ds@schleef.org>
+
+	* ext/ffmpeg/gstffmpegcolorspace.c:
+	(gst_ffmpegcsp_caps_remove_format_info), (gst_ffmpegcsp_getcaps),
+	(gst_ffmpegcsp_pad_link), (gst_ffmpegcsp_init),
+	(gst_ffmpegcsp_chain): Negotiation fixes
+	* ext/mad/gstmad.c: (gst_mad_chain): Negotiation fixes
+	* gst/audioconvert/gstaudioconvert.c: (gst_audio_convert_chain),
+	(gst_audio_convert_link), (gst_audio_convert_channels):
+	* gst/audioscale/gstaudioscale.c: (gst_audioscale_getcaps),
+	(gst_audioscale_link), (gst_audioscale_get_buffer),
+	(gst_audioscale_chain): Negotiation fixes
+	* gst/audioscale/gstaudioscale.h:
+	* gst/videofilter/gstvideofilter.c:
+	(gst_videofilter_format_get_structure), (gst_videofilter_getcaps),
+	(gst_videofilter_link), (gst_videofilter_init),
+	(gst_videofilter_set_output_size), (gst_videofilter_setup),
+	(gst_videofilter_find_format_by_structure):
+	* gst/videofilter/gstvideofilter.h: Negotiation fixes
+	* gst/videoscale/gstvideoscale.c: (gst_videoscale_getcaps),
+	(gst_videoscale_link):
+	* gst/videoscale/videoscale.c: (videoscale_get_structure),
+	(videoscale_find_by_structure), (gst_videoscale_setup):
+	* gst/videoscale/videoscale.h: Negotiation fixes
+	* sys/ximage/ximagesink.c: (gst_ximagesink_handle_xevents),
+	(gst_ximagesink_fixate), (gst_ximagesink_init): Add a fixate
+	function, restrict resizing to a multiple of 4 (hack until
+	everyone supports odd sizes correctly).
+
+2003-12-29  Colin Walters  <walters@verbum.org>
+
+	* ext/esd/esdsink.c (gst_esdsink_link): Fix typo; get depth instead of
+	signed.
+
+2003-12-30  Jan Schmidt <thaytan@mad.scientist.com>
+
+	* ext/sndfile/gstsf.c: (gst_sf_loop):
+	  Fix warning about discarding const qualifier
+
+2003-12-27  Jeremy Simon   <jesimon@libertysurf.fr>
+
+	* gst/cutter/gstcutter.c:
+	* gst/videoscale/gstvideoscale.c:
+	* gst/volenv/gstvolenv.c:
+	* gst-libs/gst/audio/audio.c:
+	* gst-libs/gst/video/video.c:
+	  Fix warnings
+
+2003-12-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_open_audio):
+	  Don't send ALSA debugging to stderr.
+	* ext/alsa/gstalsa.h:
+	  Use GST_WARNING instead of g_warning when ALSA functions fail.
+
+2003-12-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* sys/xvimage/xvimagesink.c: (gst_xvimagesink_get_xv_support):
+	  Free XVAdapterInfo correctly.
+
+2003-12-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/mad/gstid3tag.c: (gst_id3_tag_add_src_pad),
+	(gst_id3_tag_do_caps_nego), (gst_id3_tag_src_link):
+	  Make id3tag use correct caps nego.
+
+2003-12-27  Amaury Jacquot <sxpert@esitcom.org>
+
+	* ext/ivorbis/vorbis.c:
+	* ext/ivorbis/vorbisenc.h:
+	* ext/ivorbis/vorbisfile.c:
+	  Modify so that it uses the new caps things
+
+2003-12-27  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* testsuite/spider/spider1.c: (main):
+	* testsuite/spider/spider2.c: (main):
+	* testsuite/spider/spider3.c: (main):
+	  Make tests compile again. They probably don't work.
+
+2003-12-24  Colin Walters  <walters@verbum.org>
+
+	* sys/oss/gstosssink.c (gst_osssink_sink_fixate): Return NULL if
+	we can't fixate the caps anymore.
+
+2003-12-23  David Schleef  <ds@schleef.org>
+
+	* gst/volume/gstvolume.c: (volume_init): Proxy getcaps.
+	* sys/oss/gstosssink.c: (gst_osssink_init),
+	(gst_osssink_sink_fixate): Add fixate function.
+
+2003-12-24  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/ffmpeg/gstffmpegcodecmap.c:
+	* ext/ffmpeg/gstffmpegcolorspace.c: (gst_ffmpegcsp_getcaps),
+	(gst_ffmpegcsp_srcconnect_func), (gst_ffmpegcsp_sinkconnect),
+	(gst_ffmpegcsp_srcconnect), (gst_ffmpegcsp_get_type),
+	(gst_ffmpegcsp_base_init), (gst_ffmpegcsp_class_init),
+	(gst_ffmpegcsp_init), (gst_ffmpegcsp_chain),
+	(gst_ffmpegcsp_change_state), (gst_ffmpegcsp_set_property),
+	(gst_ffmpegcsp_get_property), (gst_ffmpegcsp_register):
+	  fix typo in RGB masks, and move back to "old" colorspace
+	  capsnego code until whoever wrote this new crap has actually
+	  tested it so that it works.
+	  And yes, this works, keep it that way please.
+
+2003-12-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* ext/divx/gstdivxdec.c: (gst_divxdec_base_init),
+	(gst_divxdec_init), (gst_divxdec_negotiate):
+	* ext/divx/gstdivxdec.h:
+	* ext/divx/gstdivxenc.c: (gst_divxenc_base_init),
+	(gst_divxenc_init):
+	* ext/faac/gstfaac.c: (gst_faac_base_init), (gst_faac_init),
+	(gst_faac_sinkconnect), (gst_faac_srcconnect):
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	* ext/mpeg2enc/gstmpeg2encoder.cc:
+	* ext/mpeg2enc/gstmpeg2encpicturereader.cc:
+	* sys/dxr3/dxr3audiosink.c: (dxr3audiosink_base_init),
+	(dxr3audiosink_init), (dxr3audiosink_pcm_sinklink):
+	* sys/dxr3/dxr3spusink.c: (dxr3spusink_base_init),
+	(dxr3spusink_init):
+	* sys/dxr3/dxr3videosink.c: (dxr3videosink_base_init),
+	(dxr3videosink_init):
+	  Fix caps breakage after Dave's caps branch merge.
+
+2003-12-23  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* sys/ximage/ximagesink.c: (gst_ximagesink_xcontext_get):
+	  Fix for 24bpp display.
+
+2003-12-23  Colin Walters  <walters@verbum.org>
+
+	* ext/gnomevfs/gstgnomevfssink.c: Add ARG_HANDLE property that takes
+	a GnomeVFSHandle directly.
+
+2003-12-22  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/volume/Makefile.am:
+	* gst/volume/gstvolume.c: (volume_connect), (volume_parse_caps),
+	(volume_base_init), (volume_init):
+	  Reenable volume element and fix to work with new caps stuff.
+	  Rhythmbox needs this.
+
+2003-12-22  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* gst/qtdemux/qtdemux.c: (plugin_init):
+	  qtdemux requires bytestream
+
+2003-12-22  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/alsa/gstalsa.c: (gst_alsa_get_caps), (gst_alsa_link):
+	  Fix remaining caps handling errors due to CAPS merge.
+
+2003-12-22  Benjamin Otte  <in7y118@public.uni-hamburg.de>
+
+	* ext/faad/gstfaad.c: (gst_faad_base_init), (gst_faad_init),
+	(gst_faad_sinkconnect), (gst_faad_srcgetcaps),
+	(gst_faad_srcconnect):
+	  Port to new caps system.
+
+2003-12-21  Julien MOUTTE  <julien@moutte.net>
+
+	* examples/gstplay/player.c: (got_time_tick), (got_stream_length),
+	(got_video_size), (main): using g_print instead of g_message.
+	* gst-libs/gst/play/gstplay.c: (gst_play_pipeline_setup): Fixing EOS
+	signal which was not emitted because of "switch" element added to the
+	bin but not connected. (Removing from the bin temporarily)
+
+2003-12-21  Julien MOUTTE  <julien@moutte.net>
+
+	* configure.ac: X_DISPLAY_MISSING is set to 1 if AC_PATH_XTRA fails to
+	find X development files. I don't understand the previous tests and
+	they fail on my debian/ppc unstable. This one works.
+	* examples/gstplay/player.c: (main): Set the pipeline to READY before
+	exiting.
+	* gst-libs/gst/play/gstplay.c: (gst_play_get_length_callback),
+	(gst_play_set_video_sink), (gst_play_set_audio_sink),
+	(gst_play_set_visualization): Add some safety checks in set_ methods
+	and state_change. This was throwing some ugly CRITICAL messages when
+	pipeline was getting disposed and casts were failing.
+
+2003-12-21  Ronald Bultje  <rbultje@ronald.bitfreak.net>
+
+	* configure.ac:
+	  Improve mpeg2enc detection. This is for distributions that do
+	  ship mjpegtools, but without mpeg2enc. Also does object check
+	  for might there ever be ABI incompatibility.
+	* ext/mpeg2enc/gstmpeg2enc.cc:
+	  Add Andrew as second maintainer (he's helping me), and also add
+	  an error if no caps was set. This happens if I pull before capsnego
+	  and that's something I should solve sometime else.
+	* gst/matroska/matroska-demux.c:
+	(gst_matroska_demux_parse_blockgroup):
+	  Fix time parsing.
+	* gst/matroska/matroska-mux.c: (gst_matroska_mux_audio_pad_link),
+	(gst_matroska_mux_track_header):
+	  Add caps to templates.
+	* gst/mpegaudioparse/gstmpegaudioparse.c: (mp3_sink_factory):
+	  Add mpegversion=1 to prevent confusion with MPEG/AAC.
+	* gst/mpegstream/gstmpegdemux.c:
+	  Remove layer since it causes warnings about unfixed caps.
+	* gst/videotestsrc/gstvideotestsrc.c: (gst_videotestsrc_get):
+	  Fix obvious typo (we error out if caps were set, we should of
+	  course error out if *no* caps were set).
+	* sys/oss/gstosselement.c: (gst_osselement_convert):
+	  Fix format conversion, we confused bits/bytes.
+	* sys/oss/gstosselement.h:
+	  Improve documentation for 'bps'.
+	* sys/v4l/TODO:
+	  Remove stuff about plugins that need removing - this was done
+	  ages ago.
+	* sys/v4l/gstv4lmjpegsrc.c: (gst_v4lmjpegsrc_init),
+	(gst_v4lmjpegsrc_src_convert), (gst_v4lmjpegsrc_src_query):
+	* sys/v4l/gstv4lsrc.c: (gst_v4lsrc_init), (gst_v4lsrc_src_convert),
+	(gst_v4lsrc_src_query):
+	* sys/v4l2/gstv4l2src.c: (gst_v4l2src_init),
+	(gst_v4l2src_src_convert), (gst_v4l2src_src_query):
+	  Add get_query_types(), get_formats() and query() functions.
+
+2003-12-21  Thomas Vander Stichele  <thomas at apestaart dot org>
+
+	* ChangeLog: moved to gstreamer/docs/random/old/ChangeLog.gst-plugins
+        * moved CVS to freedesktop.org
+
diff -Naur docs/random/LICENSE docs/random/LICENSE
--- docs/random/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ docs/random/LICENSE	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,18 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
diff -Naur ext/libvisual/visual.c ext/libvisual/visual.c
--- ext/libvisual/visual.c	2009-01-21 11:36:13.000000000 +0100
+++ ext/libvisual/visual.c	2009-05-19 18:44:45.000000000 +0200
@@ -47,7 +47,6 @@
   /* pads */
   GstPad *sinkpad;
   GstPad *srcpad;
-  GstClockTime next_ts;
   GstSegment segment;
 
   /* libvisual stuff */
@@ -256,7 +255,6 @@
 static void
 gst_visual_reset (GstVisual * visual)
 {
-  visual->next_ts = -1;
   gst_adapter_clear (visual->adapter);
   gst_segment_init (&visual->segment, GST_FORMAT_UNDEFINED);
 
@@ -576,13 +574,8 @@
   /* resync on DISCONT */
   if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT)) {
     gst_adapter_clear (visual->adapter);
-    visual->next_ts = -1;
   }
 
-  /* Match timestamps from the incoming audio */
-  if (GST_BUFFER_TIMESTAMP (buffer) != GST_CLOCK_TIME_NONE)
-    visual->next_ts = GST_BUFFER_TIMESTAMP (buffer);
-
   GST_DEBUG_OBJECT (visual,
       "Input buffer has %d samples, time=%" G_GUINT64_FORMAT,
       GST_BUFFER_SIZE (buffer) / visual->bps, GST_BUFFER_TIMESTAMP (buffer));
@@ -592,6 +585,7 @@
   while (TRUE) {
     gboolean need_skip;
     const guint16 *data;
+    guint64 dist, timestamp;
 
     GST_DEBUG_OBJECT (visual, "processing buffer");
 
@@ -606,12 +600,20 @@
     if (avail < visual->spf * visual->bps)
       break;
 
-    if (visual->next_ts != -1) {
+    /* get timestamp of the current adapter byte */
+    timestamp = gst_adapter_prev_timestamp (visual->adapter, &dist);
+    if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
+      /* convert bytes to time */
+      dist /= visual->bps;
+      timestamp += gst_util_uint64_scale_int (dist, GST_SECOND, visual->rate);
+    }
+
+    if (timestamp != -1) {
       gint64 qostime;
 
       /* QoS is done on running time */
       qostime = gst_segment_to_running_time (&visual->segment, GST_FORMAT_TIME,
-          visual->next_ts);
+          timestamp);
 
       GST_OBJECT_LOCK (visual);
       /* check for QoS, don't compute buffers that are known to be late */
@@ -722,17 +724,13 @@
     visual_video_set_buffer (visual->video, NULL);
     GST_DEBUG_OBJECT (visual, "rendered one frame");
 
-    GST_BUFFER_TIMESTAMP (outbuf) = visual->next_ts;
+    GST_BUFFER_TIMESTAMP (outbuf) = timestamp;
     GST_BUFFER_DURATION (outbuf) = visual->duration;
 
     ret = gst_pad_push (visual->srcpad, outbuf);
     outbuf = NULL;
 
   skip:
-    /* interpollate next timestamp */
-    if (visual->next_ts != -1)
-      visual->next_ts += visual->duration;
-
     GST_DEBUG_OBJECT (visual, "finished frame, flushing %u samples from input",
         visual->spf);
 
diff -Naur ext/Makefile.am ext/Makefile.am
--- ext/Makefile.am	2009-01-21 11:36:13.000000000 +0100
+++ ext/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -52,6 +52,12 @@
 THEORA_DIR=
 endif
 
+if USE_SCHRO
+SCHRO_DIR=schroedinger
+else
+SCHRO_DIR=
+endif
+
 SUBDIRS = \
   $(ALSA_DIR) \
   $(CDPARANOIA_DIR) \
@@ -60,6 +66,7 @@
   $(LIBVISUAL_DIR) \
   $(OGG_DIR) \
   $(PANGO_DIR) \
+  $(SCHRO_DIR) \
   $(THEORA_DIR) \
   $(VORBIS_DIR)
 
@@ -71,5 +78,6 @@
   libvisual \
   ogg \
   pango \
+  schroedinger \
   theora \
   vorbis
diff -Naur ext/ogg/gstoggdemux.c ext/ogg/gstoggdemux.c
--- ext/ogg/gstoggdemux.c	2009-04-01 13:49:10.000000000 +0200
+++ ext/ogg/gstoggdemux.c	2009-05-19 18:44:45.000000000 +0200
@@ -1542,6 +1542,7 @@
   GST_LOG_OBJECT (ogg, "seeking to %" G_GINT64_FORMAT, offset);
 
   ogg->offset = offset;
+  ogg->read_offset = offset;
   ogg_sync_reset (&ogg->sync);
 }
 
@@ -1549,25 +1550,37 @@
  * the ogg sync layer.
  */
 static GstFlowReturn
-gst_ogg_demux_get_data (GstOggDemux * ogg)
+gst_ogg_demux_get_data (GstOggDemux * ogg, gint64 end_offset)
 {
   GstFlowReturn ret;
   GstBuffer *buffer;
 
-  GST_LOG_OBJECT (ogg, "get data %" G_GINT64_FORMAT " %" G_GINT64_FORMAT,
-      ogg->offset, ogg->length);
-  if (ogg->offset == ogg->length)
+  GST_LOG_OBJECT (ogg,
+      "get data %" G_GINT64_FORMAT " %" G_GINT64_FORMAT " %" G_GINT64_FORMAT,
+      ogg->read_offset, ogg->length, end_offset);
+
+  if (end_offset > 0 && ogg->read_offset >= end_offset)
+    goto boundary_reached;
+
+  if (ogg->read_offset == ogg->length)
     goto eos;
 
-  ret = gst_pad_pull_range (ogg->sinkpad, ogg->offset, CHUNKSIZE, &buffer);
+  ret = gst_pad_pull_range (ogg->sinkpad, ogg->read_offset, CHUNKSIZE, &buffer);
   if (ret != GST_FLOW_OK)
     goto error;
 
+  ogg->read_offset += GST_BUFFER_SIZE (buffer);
+
   ret = gst_ogg_demux_submit_buffer (ogg, buffer);
 
   return ret;
 
   /* ERROR */
+boundary_reached:
+  {
+    GST_LOG_OBJECT (ogg, "reached boundary");
+    return GST_FLOW_LIMIT;
+  }
 eos:
   {
     GST_LOG_OBJECT (ogg, "reached EOS");
@@ -1600,7 +1613,7 @@
 gst_ogg_demux_get_next_page (GstOggDemux * ogg, ogg_page * og, gint64 boundary,
     gint64 * offset)
 {
-  gint64 end_offset = 0;
+  gint64 end_offset = -1;
   GstFlowReturn ret;
 
   GST_LOG_OBJECT (ogg,
@@ -1613,7 +1626,7 @@
   while (TRUE) {
     glong more;
 
-    if (boundary > 0 && ogg->offset >= end_offset)
+    if (end_offset > 0 && ogg->offset >= end_offset)
       goto boundary_reached;
 
     more = ogg_sync_pageseek (&ogg->sync, og);
@@ -1622,15 +1635,16 @@
 
     if (more < 0) {
       /* skipped n bytes */
-      GST_LOG_OBJECT (ogg, "skipped %ld bytes", more);
       ogg->offset -= more;
+      GST_LOG_OBJECT (ogg, "skipped %ld bytes, offset %" G_GINT64_FORMAT, more,
+          ogg->offset);
     } else if (more == 0) {
       /* we need more data */
       if (boundary == 0)
         goto boundary_reached;
 
       GST_LOG_OBJECT (ogg, "need more data");
-      ret = gst_ogg_demux_get_data (ogg);
+      ret = gst_ogg_demux_get_data (ogg, end_offset);
       if (ret != GST_FLOW_OK)
         break;
     } else {
@@ -1643,9 +1657,6 @@
       ret = GST_FLOW_OK;
 
       ogg->offset += more;
-      /* need to reset as we do not keep track of the bytes we
-       * sent to the sync layer */
-      ogg_sync_reset (&ogg->sync);
 
       GST_LOG_OBJECT (ogg,
           "got page at %" G_GINT64_FORMAT ", serial %08x, end at %"
@@ -1679,6 +1690,8 @@
   gint64 end = begin;
   gint64 cur_offset = -1;
 
+  GST_LOG_OBJECT (ogg, "getting page before %" G_GINT64_FORMAT, begin);
+
   while (cur_offset == -1) {
     begin -= CHUNKSIZE;
     if (begin < 0)
@@ -1696,25 +1709,37 @@
       ret =
           gst_ogg_demux_get_next_page (ogg, og, end - ogg->offset, &new_offset);
       /* we hit the upper limit, offset contains the last page start */
-      if (ret == GST_FLOW_LIMIT)
+      if (ret == GST_FLOW_LIMIT) {
+        GST_LOG_OBJECT (ogg, "hit limit");
         break;
+      }
       /* something went wrong */
-      if (ret == GST_FLOW_UNEXPECTED)
+      if (ret == GST_FLOW_UNEXPECTED) {
         new_offset = 0;
-      else if (ret != GST_FLOW_OK)
+        GST_LOG_OBJECT (ogg, "got unexpected");
+      } else if (ret != GST_FLOW_OK) {
+        GST_LOG_OBJECT (ogg, "got error %d", ret);
         return ret;
+      }
+
+      GST_LOG_OBJECT (ogg, "found page at %" G_GINT64_FORMAT, new_offset);
 
       /* offset is next page start */
       cur_offset = new_offset;
     }
   }
 
+  GST_LOG_OBJECT (ogg, "found previous page at %" G_GINT64_FORMAT, cur_offset);
+
   /* we have the offset.  Actually snork and hold the page now */
   gst_ogg_demux_seek (ogg, cur_offset);
   ret = gst_ogg_demux_get_next_page (ogg, og, -1, NULL);
-  if (ret != GST_FLOW_OK)
+  if (ret != GST_FLOW_OK) {
+    GST_WARNING_OBJECT (ogg, "can't get last page at %" G_GINT64_FORMAT,
+        cur_offset);
     /* this shouldn't be possible */
     return ret;
+  }
 
   if (offset)
     *offset = cur_offset;
@@ -2004,7 +2029,8 @@
     }
   }
 
-  ogg->offset = best;
+  GST_DEBUG_OBJECT (ogg, "seeking to %" G_GINT64_FORMAT, best);
+  gst_ogg_demux_seek (ogg, best);
   *rchain = chain;
 
   return TRUE;
@@ -2385,6 +2411,10 @@
     }
     if (!ogg_page_bos (&op)) {
       GST_WARNING_OBJECT (ogg, "page is not BOS page");
+      /* if we did not find a chain yet, assume this is a bogus stream and
+       * ignore it */
+      if (!chain)
+        ret = GST_FLOW_UNEXPECTED;
       break;
     }
 
@@ -2857,9 +2887,11 @@
   if (pad) {
     result = gst_ogg_pad_submit_page (pad, page);
   } else {
-    /* no pad, this is pretty fatal. This means an ogg page without bos
-     * has been seen for this serialno. could just ignore it too... */
-    goto unknown_pad;
+    /* no pad. This means an ogg page without bos has been seen for this
+     * serialno. we just ignore it but post a warning... */
+    GST_ELEMENT_WARNING (ogg, STREAM, DECODE,
+        (NULL), ("unknown ogg pad for serial %08x detected", serialno));
+    return GST_FLOW_OK;
   }
   return result;
 
@@ -2870,12 +2902,6 @@
         (NULL), ("unknown ogg chain for serial %08x detected", serialno));
     return GST_FLOW_ERROR;
   }
-unknown_pad:
-  {
-    GST_ELEMENT_ERROR (ogg, STREAM, DECODE,
-        (NULL), ("unknown ogg pad for serial %08x detected", serialno));
-    return GST_FLOW_ERROR;
-  }
 }
 
 /* streaming mode, receive a buffer, parse it, create pads for
diff -Naur ext/ogg/gstoggdemux.h ext/ogg/gstoggdemux.h
--- ext/ogg/gstoggdemux.h	2009-01-21 11:36:13.000000000 +0100
+++ ext/ogg/gstoggdemux.h	2009-05-19 18:44:45.000000000 +0200
@@ -139,6 +139,7 @@
   GstPad *sinkpad;
 
   gint64 length;
+  gint64 read_offset;
   gint64 offset;
 
   gboolean seekable;
diff -Naur ext/ogg/gstoggmux.c ext/ogg/gstoggmux.c
--- ext/ogg/gstoggmux.c	2009-01-21 11:36:13.000000000 +0100
+++ ext/ogg/gstoggmux.c	2009-05-19 18:44:45.000000000 +0200
@@ -149,10 +149,17 @@
       0,
       (GInstanceInitFunc) gst_ogg_mux_init,
     };
+    static const GInterfaceInfo preset_info = {
+      NULL,
+      NULL,
+      NULL
+    };
 
     ogg_mux_type =
         g_type_register_static (GST_TYPE_ELEMENT, "GstOggMux", &ogg_mux_info,
         0);
+
+    g_type_add_interface_static (ogg_mux_type, GST_TYPE_PRESET, &preset_info);
   }
   return ogg_mux_type;
 }
@@ -1293,6 +1300,7 @@
     }
 
     if (GST_BUFFER_IS_DISCONT (buf)) {
+      GST_LOG_OBJECT (pad->collect.pad, "got discont");
       packet.packetno++;
       /* No public API for this; hack things in */
       pad->stream.pageno++;
@@ -1675,6 +1683,6 @@
 {
   GST_DEBUG_CATEGORY_INIT (gst_ogg_mux_debug, "oggmux", 0, "ogg muxer");
 
-  return gst_element_register (plugin, "oggmux", GST_RANK_NONE,
+  return gst_element_register (plugin, "oggmux", GST_RANK_PRIMARY,
       GST_TYPE_OGG_MUX);
 }
diff -Naur ext/pango/gsttextrender.c ext/pango/gsttextrender.c
--- ext/pango/gsttextrender.c	2009-01-21 11:36:13.000000000 +0100
+++ ext/pango/gsttextrender.c	2009-05-19 18:44:45.000000000 +0200
@@ -57,18 +57,32 @@
     "David Schleef <ds@schleef.org>, "
     "Ronald S. Bultje <rbultje@ronald.bitfreak.net>");
 
+#define DEFAULT_PROP_VALIGNMENT GST_TEXT_RENDER_VALIGN_BASELINE
+#define DEFAULT_PROP_HALIGNMENT GST_TEXT_RENDER_HALIGN_CENTER
+#define DEFAULT_PROP_LINE_ALIGNMENT GST_TEXT_RENDER_LINE_ALIGN_CENTER
+#define DEFAULT_PROP_XPAD       25
+#define DEFAULT_PROP_YPAD       25
+
+#define DEFAULT_RENDER_WIDTH 720
+#define DEFAULT_RENDER_HEIGHT 576
+
 enum
 {
   ARG_0,
+  PROP_HALIGNMENT,
+  PROP_VALIGNMENT,
+  PROP_LINE_ALIGNMENT,
+  PROP_XPAD,
+  PROP_YPAD,
   ARG_FONT_DESC
 };
 
 
 static GstStaticPadTemplate src_template_factory =
-GST_STATIC_PAD_TEMPLATE ("src",
+    GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("AYUV"))
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("AYUV") ";" GST_VIDEO_CAPS_ARGB)
     );
 
 static GstStaticPadTemplate sink_template_factory =
@@ -78,13 +92,74 @@
     GST_STATIC_CAPS ("text/x-pango-markup; text/plain")
     );
 
-GST_BOILERPLATE (GstTextRender, gst_text_render, GstElement, GST_TYPE_ELEMENT)
+#define GST_TYPE_TEXT_RENDER_VALIGN (gst_text_render_valign_get_type())
+static GType
+gst_text_render_valign_get_type (void)
+{
+  static GType text_render_valign_type = 0;
+  static const GEnumValue text_render_valign[] = {
+    {GST_TEXT_RENDER_VALIGN_BASELINE, "baseline", "baseline"},
+    {GST_TEXT_RENDER_VALIGN_BOTTOM, "bottom", "bottom"},
+    {GST_TEXT_RENDER_VALIGN_TOP, "top", "top"},
+    {0, NULL, NULL},
+  };
+
+  if (!text_render_valign_type) {
+    text_render_valign_type =
+        g_enum_register_static ("GstTextRenderVAlign", text_render_valign);
+  }
+  return text_render_valign_type;
+}
+
+#define GST_TYPE_TEXT_RENDER_HALIGN (gst_text_render_halign_get_type())
+static GType
+gst_text_render_halign_get_type (void)
+{
+  static GType text_render_halign_type = 0;
+  static const GEnumValue text_render_halign[] = {
+    {GST_TEXT_RENDER_HALIGN_LEFT, "left", "left"},
+    {GST_TEXT_RENDER_HALIGN_CENTER, "center", "center"},
+    {GST_TEXT_RENDER_HALIGN_RIGHT, "right", "right"},
+    {0, NULL, NULL},
+  };
+
+  if (!text_render_halign_type) {
+    text_render_halign_type =
+        g_enum_register_static ("GstTextRenderHAlign", text_render_halign);
+  }
+  return text_render_halign_type;
+}
+
+#define GST_TYPE_TEXT_RENDER_LINE_ALIGN (gst_text_render_line_align_get_type())
+static GType
+gst_text_render_line_align_get_type (void)
+{
+  static GType text_render_line_align_type = 0;
+  static const GEnumValue text_render_line_align[] = {
+    {GST_TEXT_RENDER_LINE_ALIGN_LEFT, "left", "left"},
+    {GST_TEXT_RENDER_LINE_ALIGN_CENTER, "center", "center"},
+    {GST_TEXT_RENDER_LINE_ALIGN_RIGHT, "right", "right"},
+    {0, NULL, NULL}
+  };
+
+  if (!text_render_line_align_type) {
+    text_render_line_align_type =
+        g_enum_register_static ("GstTextRenderLineAlign",
+        text_render_line_align);
+  }
+  return text_render_line_align_type;
+}
+
+GST_BOILERPLATE (GstTextRender, gst_text_render, GstElement, GST_TYPE_ELEMENT);
 
-     static void gst_text_render_finalize (GObject * object);
-     static void gst_text_render_set_property (GObject * object,
+static void gst_text_render_finalize (GObject * object);
+static void gst_text_render_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_text_render_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
 
-     static void gst_text_render_base_init (gpointer g_class)
+static void
+gst_text_render_base_init (gpointer g_class)
 {
   GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
 
@@ -109,6 +184,7 @@
 
   gobject_class->finalize = gst_text_render_finalize;
   gobject_class->set_property = gst_text_render_set_property;
+  gobject_class->get_property = gst_text_render_get_property;
 
   klass->pango_context = pango_ft2_get_context (72, 72);
   g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_FONT_DESC,
@@ -118,6 +194,27 @@
           "See documentation of "
           "pango_font_description_from_string"
           " for syntax.", "", G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_VALIGNMENT,
+      g_param_spec_enum ("valignment", "vertical alignment",
+          "Vertical alignment of the text", GST_TYPE_TEXT_RENDER_VALIGN,
+          DEFAULT_PROP_VALIGNMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_HALIGNMENT,
+      g_param_spec_enum ("halignment", "horizontal alignment",
+          "Horizontal alignment of the text", GST_TYPE_TEXT_RENDER_HALIGN,
+          DEFAULT_PROP_HALIGNMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_XPAD,
+      g_param_spec_int ("xpad", "horizontal paddding",
+          "Horizontal paddding when using left/right alignment", 0, G_MAXINT,
+          DEFAULT_PROP_XPAD, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_YPAD,
+      g_param_spec_int ("ypad", "vertical padding",
+          "Vertical padding when using top/bottom alignment", 0, G_MAXINT,
+          DEFAULT_PROP_YPAD, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), PROP_LINE_ALIGNMENT,
+      g_param_spec_enum ("line-alignment", "line alignment",
+          "Alignment of text lines relative to each other.",
+          GST_TYPE_TEXT_RENDER_LINE_ALIGN, DEFAULT_PROP_LINE_ALIGNMENT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 }
 
 
@@ -163,6 +260,38 @@
   render->baseline_y = ink_rect.y;
 }
 
+static void
+gst_text_render_check_argb (GstTextRender * render)
+{
+  GstCaps *peer_caps;
+  peer_caps = gst_pad_get_allowed_caps (render->srcpad);
+  if (G_LIKELY (peer_caps)) {
+    guint i = 0, n = 0;
+
+    n = gst_caps_get_size (peer_caps);
+    GST_DEBUG_OBJECT (render, "peer allowed caps (%u structure(s)) are %"
+        GST_PTR_FORMAT, n, peer_caps);
+
+    /* Check if AYUV or ARGB is first */
+    for (i = 0; i < n; i++) {
+      GstStructure *s = gst_caps_get_structure (peer_caps, i);
+      if (gst_structure_has_name (s, "video/x-raw-rgb") &&
+          gst_structure_has_field (s, "alpha_mask")) {
+        render->use_ARGB = TRUE;
+        break;
+      } else if (gst_structure_has_name (s, "video/x-raw-yuv")) {
+        guint fourcc;
+        if (gst_structure_get_fourcc (s, "format", &fourcc) &&
+            fourcc == GST_MAKE_FOURCC ('A', 'Y', 'U', 'V')) {
+          render->use_ARGB = FALSE;
+          break;
+        }
+      }
+    }
+    gst_caps_unref (peer_caps);
+  }
+}
+
 static gboolean
 gst_text_render_setcaps (GstPad * pad, GstCaps * caps)
 {
@@ -183,6 +312,8 @@
     ret = TRUE;
   }
 
+  gst_text_render_check_argb (render);
+
   gst_object_unref (render);
   return ret;
 }
@@ -194,8 +325,8 @@
   GstStructure *s = gst_caps_get_structure (caps, 0);
 
   GST_DEBUG ("Fixating caps %" GST_PTR_FORMAT, caps);
-  gst_structure_fixate_field_nearest_int (s, "width", render->bitmap.width);
-  gst_structure_fixate_field_nearest_int (s, "height", render->bitmap.rows);
+  gst_structure_fixate_field_nearest_int (s, "width", render->width);
+  gst_structure_fixate_field_nearest_int (s, "height", render->height);
   GST_DEBUG ("Fixated to    %" GST_PTR_FORMAT, caps);
 
   gst_object_unref (render);
@@ -203,23 +334,30 @@
 
 static void
 gst_text_renderer_bitmap_to_ayuv (GstTextRender * render, FT_Bitmap * bitmap,
-    guchar * pixbuf)
+    guchar * pixbuf, gint x0, gint x1, gint y0, gint y1)
 {
   int y;                        /* text bitmap coordinates */
   int rowinc, bit_rowinc;
   guchar *p, *bitp;
   guchar v;
 
+  x0 = CLAMP (x0, 0, render->width);
+  x1 = CLAMP (x1, 0, render->width);
+
+  y0 = CLAMP (y0, 0, render->height);
+  y1 = CLAMP (y1, 0, render->height);
+
+
   rowinc = render->width - bitmap->width;
   bit_rowinc = bitmap->pitch - bitmap->width;
 
   bitp = bitmap->buffer;
-  p = pixbuf;
+  p = pixbuf + ((x0 + (render->width * y0)) * 4);
 
-  for (y = 0; y < bitmap->rows; y++) {
+  for (y = y0; y < y1; y++) {
     int n;
 
-    for (n = bitmap->width; n > 0; --n) {
+    for (n = x0; n < x1; n++) {
       v = *bitp;
       if (v) {
         p[0] = v;
@@ -235,6 +373,46 @@
   }
 }
 
+static void
+gst_text_renderer_bitmap_to_argb (GstTextRender * render, FT_Bitmap * bitmap,
+    guchar * pixbuf, gint x0, gint x1, gint y0, gint y1)
+{
+  int y;                        /* text bitmap coordinates */
+  int rowinc, bit_rowinc;
+  guchar *p, *bitp;
+  guchar v;
+
+  x0 = CLAMP (x0, 0, render->width);
+  x1 = CLAMP (x1, 0, render->width);
+
+  y0 = CLAMP (y0, 0, render->height);
+  y1 = CLAMP (y1, 0, render->height);
+
+
+  rowinc = render->width - bitmap->width;
+  bit_rowinc = bitmap->pitch - bitmap->width;
+
+  bitp = bitmap->buffer;
+  p = pixbuf + ((x0 + (render->width * y0)) * 4);
+
+  for (y = y0; y < y1; y++) {
+    int n;
+
+    for (n = x0; n < x1; n++) {
+      v = *bitp;
+      if (v) {
+        p[0] = v;
+        p[1] = 255;
+        p[2] = 255;
+        p[3] = 255;
+      }
+      p += 4;
+      bitp++;
+    }
+    p += rowinc * 4;
+    bitp += bit_rowinc;
+  }
+}
 
 static GstFlowReturn
 gst_text_render_chain (GstPad * pad, GstBuffer * inbuf)
@@ -246,6 +424,7 @@
   guint8 *data = GST_BUFFER_DATA (inbuf);
   guint size = GST_BUFFER_SIZE (inbuf);
   gint n;
+  gint xpos, ypos;
 
   render = GST_TEXT_RENDER (gst_pad_get_parent (pad));
 
@@ -261,10 +440,17 @@
   pango_layout_set_markup (render->layout, (gchar *) data, size);
   gst_text_render_render_text (render);
 
-  caps = gst_caps_new_simple ("video/x-raw-yuv", "format", GST_TYPE_FOURCC,
-      GST_MAKE_FOURCC ('A', 'Y', 'U', 'V'), "width", G_TYPE_INT,
-      render->bitmap.width, "height", G_TYPE_INT, render->bitmap.rows,
-      "framerate", GST_TYPE_FRACTION, 1, 1, NULL);
+  gst_text_render_check_argb (render);
+
+  if (!render->use_ARGB) {
+    caps =
+        gst_video_format_new_caps (GST_VIDEO_FORMAT_AYUV, render->width,
+        render->height, 1, 1, 1, 1);
+  } else {
+    caps =
+        gst_video_format_new_caps (GST_VIDEO_FORMAT_ARGB, render->width,
+        render->height, 1, 1, 1, 1);
+  }
 
   if (!gst_pad_set_caps (render->srcpad, caps)) {
     gst_caps_unref (caps);
@@ -273,8 +459,7 @@
     goto done;
   }
 
-  GST_DEBUG ("Allocating AYUV buffer WxH = %dx%d", render->width,
-      render->height);
+  GST_DEBUG ("Allocating buffer WxH = %dx%d", render->width, render->height);
   ret =
       gst_pad_alloc_buffer_and_set_caps (render->srcpad, GST_BUFFER_OFFSET_NONE,
       render->width * render->height * 4, caps, &outbuf);
@@ -285,14 +470,55 @@
   gst_buffer_copy_metadata (outbuf, inbuf, GST_BUFFER_COPY_TIMESTAMPS);
   data = GST_BUFFER_DATA (outbuf);
 
-  for (n = 0; n < render->width * render->height; n++) {
-    data[n * 4] = 0;
-    data[n * 4 + 1] = 0;
-    data[n * 4 + 2] = data[n * 4 + 3] = 128;
+  if (render->use_ARGB) {
+    for (n = 0; n < render->width * render->height; n++) {
+      data[n * 4] = 0;
+      data[n * 4 + 1] = data[n * 4 + 2] = data[n * 4 + 3] = 0;
+    }
+  } else {
+    for (n = 0; n < render->width * render->height; n++) {
+      data[n * 4] = data[n * 4 + 1] = 0;
+      data[n * 4 + 2] = data[n * 4 + 3] = 128;
+    }
+  }
+
+  switch (render->halign) {
+    case GST_TEXT_RENDER_HALIGN_LEFT:
+      xpos = render->xpad;
+      break;
+    case GST_TEXT_RENDER_HALIGN_CENTER:
+      xpos = (render->width - render->bitmap.width) / 2;
+      break;
+    case GST_TEXT_RENDER_HALIGN_RIGHT:
+      xpos = render->width - render->bitmap.width - render->xpad;
+      break;
+    default:
+      xpos = 0;
+  }
+
+  switch (render->valign) {
+    case GST_TEXT_RENDER_VALIGN_BOTTOM:
+      ypos = render->height - render->bitmap.rows - render->ypad;
+      break;
+    case GST_TEXT_RENDER_VALIGN_BASELINE:
+      ypos = render->height - (render->bitmap.rows + render->ypad);
+      break;
+    case GST_TEXT_RENDER_VALIGN_TOP:
+      ypos = render->ypad;
+      break;
+    default:
+      ypos = render->ypad;
+      break;
   }
 
   if (render->bitmap.buffer) {
-    gst_text_renderer_bitmap_to_ayuv (render, &render->bitmap, data);
+    if (render->use_ARGB) {
+      gst_text_renderer_bitmap_to_argb (render, &render->bitmap, data, xpos,
+          xpos + render->bitmap.width, ypos, ypos + render->bitmap.rows);
+    } else {
+      gst_text_renderer_bitmap_to_ayuv (render, &render->bitmap, data, xpos,
+          xpos + render->bitmap.width, ypos, ypos + render->bitmap.rows);
+    }
   }
 
   ret = gst_pad_push (render->srcpad, outbuf);
@@ -339,11 +565,25 @@
       GST_DEBUG_FUNCPTR (gst_text_render_fixate_caps));
   gst_pad_set_setcaps_function (render->srcpad,
       GST_DEBUG_FUNCPTR (gst_text_render_setcaps));
+
   gst_element_add_pad (GST_ELEMENT (render), render->srcpad);
 
+  render->line_align = DEFAULT_PROP_LINE_ALIGNMENT;
   render->layout =
       pango_layout_new (GST_TEXT_RENDER_GET_CLASS (render)->pango_context);
+  pango_layout_set_alignment (render->layout,
+      (PangoAlignment) render->line_align);
   memset (&render->bitmap, 0, sizeof (render->bitmap));
+
+  render->halign = DEFAULT_PROP_HALIGNMENT;
+  render->valign = DEFAULT_PROP_VALIGNMENT;
+  render->xpad = DEFAULT_PROP_XPAD;
+  render->ypad = DEFAULT_PROP_YPAD;
+
+  render->width = DEFAULT_RENDER_WIDTH;
+  render->height = DEFAULT_RENDER_HEIGHT;
+
+  render->use_ARGB = FALSE;
 }
 
 static void
@@ -353,6 +593,23 @@
   GstTextRender *render = GST_TEXT_RENDER (object);
 
   switch (prop_id) {
+    case PROP_VALIGNMENT:
+      render->valign = g_value_get_enum (value);
+      break;
+    case PROP_HALIGNMENT:
+      render->halign = g_value_get_enum (value);
+      break;
+    case PROP_LINE_ALIGNMENT:
+      render->line_align = g_value_get_enum (value);
+      pango_layout_set_alignment (render->layout,
+          (PangoAlignment) render->line_align);
+      break;
+    case PROP_XPAD:
+      render->xpad = g_value_get_int (value);
+      break;
+    case PROP_YPAD:
+      render->ypad = g_value_get_int (value);
+      break;
     case ARG_FONT_DESC:
     {
       PangoFontDescription *desc;
@@ -376,3 +633,31 @@
       break;
   }
 }
+
+static void
+gst_text_render_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstTextRender *render = GST_TEXT_RENDER (object);
+
+  switch (prop_id) {
+    case PROP_VALIGNMENT:
+      g_value_set_enum (value, render->valign);
+      break;
+    case PROP_HALIGNMENT:
+      g_value_set_enum (value, render->halign);
+      break;
+    case PROP_LINE_ALIGNMENT:
+      g_value_set_enum (value, render->line_align);
+      break;
+    case PROP_XPAD:
+      g_value_set_int (value, render->xpad);
+      break;
+    case PROP_YPAD:
+      g_value_set_int (value, render->ypad);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
diff -Naur ext/pango/gsttextrender.h ext/pango/gsttextrender.h
--- ext/pango/gsttextrender.h	2009-01-21 11:36:13.000000000 +0100
+++ ext/pango/gsttextrender.h	2009-05-19 18:44:45.000000000 +0200
@@ -22,6 +22,48 @@
 typedef struct _GstTextRenderClass GstTextRenderClass;
 
 /**
+ * GstTextRenderVAlign:
+ * @GST_TEXT_RENDER_VALIGN_BASELINE: draw text on the baseline
+ * @GST_TEXT_RENDER_VALIGN_BOTTOM: draw text on the bottom
+ * @GST_TEXT_RENDER_VALIGN_TOP: draw test on top
+ *
+ * Vertical alignment of the text.
+ */
+typedef enum {
+    GST_TEXT_RENDER_VALIGN_BASELINE,
+    GST_TEXT_RENDER_VALIGN_BOTTOM,
+    GST_TEXT_RENDER_VALIGN_TOP
+} GstTextRenderVAlign;
+
+/**
+ * GstTextRenderHAlign:
+ * @GST_TEXT_RENDER_HALIGN_LEFT: align text left
+ * @GST_TEXT_RENDER_HALIGN_CENTER: align text center
+ * @GST_TEXT_RENDER_HALIGN_RIGHT: align text right
+ *
+ * Horizontal alignment of the text.
+ */
+typedef enum {
+    GST_TEXT_RENDER_HALIGN_LEFT,
+    GST_TEXT_RENDER_HALIGN_CENTER,
+    GST_TEXT_RENDER_HALIGN_RIGHT
+} GstTextRenderHAlign;
+
+/**
+ * GstTextRenderLineAlign:
+ * @GST_TEXT_RENDER_LINE_ALIGN_LEFT: lines are left-aligned
+ * @GST_TEXT_RENDER_LINE_ALIGN_CENTER: lines are center-aligned
+ * @GST_TEXT_RENDER_LINE_ALIGN_RIGHT: lines are right-aligned
+ *
+ * Alignment of text lines relative to each other
+ */
+typedef enum {
+    GST_TEXT_RENDER_LINE_ALIGN_LEFT = PANGO_ALIGN_LEFT,
+    GST_TEXT_RENDER_LINE_ALIGN_CENTER = PANGO_ALIGN_CENTER,
+    GST_TEXT_RENDER_LINE_ALIGN_RIGHT = PANGO_ALIGN_RIGHT
+} GstTextRenderLineAlign;
+
+/**
  * GstTextRender:
  *
  * Opaque textrender data structure.
@@ -36,6 +78,14 @@
     FT_Bitmap             bitmap;
     gint                  bitmap_buffer_size;
     gint                  baseline_y;
+    gboolean              use_ARGB;
+
+    GstTextRenderVAlign     valign;
+    GstTextRenderHAlign     halign;
+    GstTextRenderLineAlign  line_align;
+
+    gint xpad;
+    gint ypad;
 };
 
 struct _GstTextRenderClass {
diff -Naur ext/schroedinger/gstschro.c ext/schroedinger/gstschro.c
--- ext/schroedinger/gstschro.c	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/gstschro.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,54 @@
+/* GStreamer
+ * Copyright (C) 2005 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <schroedinger/schro.h>
+
+GType gst_schro_enc_get_type (void);
+GType gst_schro_dec_get_type (void);
+GType gst_schro_parse_get_type (void);
+
+GST_DEBUG_CATEGORY (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  schro_init ();
+
+  GST_DEBUG_CATEGORY_INIT (schro_debug, "schro", 0, "Schroedinger");
+  gst_element_register (plugin, "schrodec", GST_RANK_PRIMARY,
+      gst_schro_dec_get_type ());
+  gst_element_register (plugin, "schroparse", GST_RANK_NONE,
+      gst_schro_parse_get_type ());
+  gst_element_register (plugin, "schroenc", GST_RANK_PRIMARY,
+      gst_schro_enc_get_type ());
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "schro",
+    "Schro plugins",
+    plugin_init, VERSION, "LGPL", "schroedinger", GST_PACKAGE_ORIGIN)
diff -Naur ext/schroedinger/gstschrodec.c ext/schroedinger/gstschrodec.c
--- ext/schroedinger/gstschrodec.c	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/gstschrodec.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,722 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <gst/video/video.h>
+#include <gst/video/gstbasevideodecoder.h>
+#include <string.h>
+#include <schroedinger/schro.h>
+#include <math.h>
+#include "gstschroutils.h"
+
+#include <schroedinger/schroparse.h>
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+#define GST_TYPE_SCHRO_DEC \
+  (gst_schro_dec_get_type())
+#define GST_SCHRO_DEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCHRO_DEC,GstSchroDec))
+#define GST_SCHRO_DEC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCHRO_DEC,GstSchroDecClass))
+#define GST_IS_SCHRO_DEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCHRO_DEC))
+#define GST_IS_SCHRO_DEC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCHRO_DEC))
+
+typedef struct _GstSchroDec GstSchroDec;
+typedef struct _GstSchroDecClass GstSchroDecClass;
+
+struct _GstSchroDec
+{
+  GstBaseVideoDecoder base_video_decoder;
+
+  SchroDecoder *decoder;
+
+  GstBuffer *seq_header_buffer;
+};
+
+struct _GstSchroDecClass
+{
+  GstBaseVideoDecoder base_video_decoder_class;
+};
+
+
+/* GstSchroDec signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_schro_dec_finalize (GObject * object);
+static void gst_schro_dec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_schro_dec_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static gboolean gst_schro_dec_sink_query (GstPad * pad, GstQuery * query);
+
+static gboolean gst_schro_dec_start (GstBaseVideoDecoder * dec);
+static gboolean gst_schro_dec_stop (GstBaseVideoDecoder * dec);
+static gboolean gst_schro_dec_reset (GstBaseVideoDecoder * dec);
+static GstFlowReturn gst_schro_dec_parse_data (GstBaseVideoDecoder *
+    base_video_decoder, gboolean at_eos);
+static int gst_schro_dec_scan_for_sync (GstBaseVideoDecoder *
+    base_video_decoder, gboolean at_eos, int offset, int n);
+static GstFlowReturn gst_schro_dec_handle_frame (GstBaseVideoDecoder * decoder,
+    GstVideoFrame * frame);
+static GstFlowReturn gst_schro_dec_finish (GstBaseVideoDecoder *
+    base_video_decoder, GstVideoFrame * frame);
+static void gst_schrodec_send_tags (GstSchroDec * schro_dec);
+
+static GstStaticPadTemplate gst_schro_dec_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-dirac")
+    );
+
+static GstStaticPadTemplate gst_schro_dec_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ I420, YUY2, AYUV }"))
+    );
+
+GST_BOILERPLATE (GstSchroDec, gst_schro_dec, GstBaseVideoDecoder,
+    GST_TYPE_BASE_VIDEO_DECODER);
+
+static void
+gst_schro_dec_base_init (gpointer g_class)
+{
+  static GstElementDetails compress_details =
+      GST_ELEMENT_DETAILS ("Dirac Decoder",
+      "Codec/Decoder/Video",
+      "Decode Dirac streams",
+      "David Schleef <ds@schleef.org>");
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_dec_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_dec_sink_template));
+
+  gst_element_class_set_details (element_class, &compress_details);
+}
+
+static void
+gst_schro_dec_class_init (GstSchroDecClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+  base_video_decoder_class = GST_BASE_VIDEO_DECODER_CLASS (klass);
+
+  gobject_class->set_property = gst_schro_dec_set_property;
+  gobject_class->get_property = gst_schro_dec_get_property;
+  gobject_class->finalize = gst_schro_dec_finalize;
+
+  base_video_decoder_class->start = GST_DEBUG_FUNCPTR (gst_schro_dec_start);
+  base_video_decoder_class->stop = GST_DEBUG_FUNCPTR (gst_schro_dec_stop);
+  base_video_decoder_class->reset = GST_DEBUG_FUNCPTR (gst_schro_dec_reset);
+  base_video_decoder_class->parse_data =
+      GST_DEBUG_FUNCPTR (gst_schro_dec_parse_data);
+  base_video_decoder_class->scan_for_sync =
+      GST_DEBUG_FUNCPTR (gst_schro_dec_scan_for_sync);
+  base_video_decoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_schro_dec_handle_frame);
+  base_video_decoder_class->finish = GST_DEBUG_FUNCPTR (gst_schro_dec_finish);
+}
+
+static void
+gst_schro_dec_init (GstSchroDec * schro_dec, GstSchroDecClass * klass)
+{
+  GST_DEBUG ("gst_schro_dec_init");
+
+  gst_pad_set_query_function (GST_BASE_VIDEO_CODEC_SINK_PAD (schro_dec),
+      gst_schro_dec_sink_query);
+
+  schro_dec->decoder = schro_decoder_new ();
+}
+
+#define OGG_DIRAC_GRANULE_SHIFT 22
+#define OGG_DIRAC_GRANULE_LOW_MASK ((1ULL<<OGG_DIRAC_GRANULE_SHIFT)-1)
+
+static gint64
+granulepos_to_frame (gint64 granulepos)
+{
+  guint64 pt;
+  int dist_h;
+  int dist_l;
+  int dist;
+  int delay;
+  guint64 dt;
+
+  if (granulepos == -1)
+    return -1;
+
+  pt = ((granulepos >> 22) + (granulepos & OGG_DIRAC_GRANULE_LOW_MASK)) >> 9;
+  dist_h = (granulepos >> 22) & 0xff;
+  dist_l = granulepos & 0xff;
+  dist = (dist_h << 8) | dist_l;
+  delay = (granulepos >> 9) & 0x1fff;
+  dt = pt - delay;
+
+  return pt >> 1;
+}
+
+static gboolean
+gst_schro_dec_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstSchroDec *dec;
+  GstVideoState *state;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_SCHRO_DEC (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  state = gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER (dec));
+
+  res = FALSE;
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (state->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          state->fps_d * GST_SECOND, state->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+
+static gboolean
+gst_schro_dec_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstSchroDec *dec;
+  gboolean res = FALSE;
+
+  dec = GST_SCHRO_DEC (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_schro_dec_sink_convert (pad, src_fmt, src_val, &dest_fmt,
+          &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (dec);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (dec, "query failed");
+  goto done;
+}
+
+static gboolean
+gst_schro_dec_start (GstBaseVideoDecoder * dec)
+{
+  if (dec->codec_data) {
+    GST_DEBUG_OBJECT (dec, "codec data!");
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_dec_stop (GstBaseVideoDecoder * dec)
+{
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_dec_reset (GstBaseVideoDecoder * dec)
+{
+  GstSchroDec *schro_dec;
+
+  schro_dec = GST_SCHRO_DEC (dec);
+
+  GST_DEBUG ("reset");
+
+  if (schro_dec->decoder) {
+    schro_decoder_reset (schro_dec->decoder);
+  }
+
+  return TRUE;
+}
+
+static void
+gst_schro_dec_finalize (GObject * object)
+{
+  GstSchroDec *schro_dec;
+
+  g_return_if_fail (GST_IS_SCHRO_DEC (object));
+  schro_dec = GST_SCHRO_DEC (object);
+
+  if (schro_dec->decoder) {
+    schro_decoder_free (schro_dec->decoder);
+    schro_dec->decoder = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_schro_dec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSchroDec *src;
+
+  g_return_if_fail (GST_IS_SCHRO_DEC (object));
+  src = GST_SCHRO_DEC (object);
+
+  GST_DEBUG ("gst_schro_dec_set_property");
+  switch (prop_id) {
+    default:
+      break;
+  }
+}
+
+static void
+gst_schro_dec_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstSchroDec *src;
+
+  g_return_if_fail (GST_IS_SCHRO_DEC (object));
+  src = GST_SCHRO_DEC (object);
+
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+parse_sequence_header (GstSchroDec * schro_dec, guint8 * data, int size)
+{
+  SchroVideoFormat video_format;
+  int ret;
+  GstVideoState *state;
+
+  GST_DEBUG_OBJECT (schro_dec, "parse_sequence_header size=%d", size);
+
+  state = gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER (schro_dec));
+
+  schro_dec->seq_header_buffer = gst_buffer_new_and_alloc (size);
+  memcpy (GST_BUFFER_DATA (schro_dec->seq_header_buffer), data, size);
+
+  ret = schro_parse_decode_sequence_header (data + 13, size - 13,
+      &video_format);
+  if (ret) {
+    if (video_format.chroma_format == SCHRO_CHROMA_444) {
+      state->format = GST_VIDEO_FORMAT_AYUV;
+    } else if (video_format.chroma_format == SCHRO_CHROMA_422) {
+      state->format = GST_VIDEO_FORMAT_YUY2;
+    } else if (video_format.chroma_format == SCHRO_CHROMA_420) {
+      state->format = GST_VIDEO_FORMAT_I420;
+    }
+    state->fps_n = video_format.frame_rate_numerator;
+    state->fps_d = video_format.frame_rate_denominator;
+    GST_DEBUG_OBJECT (schro_dec, "Frame rate is %d/%d", state->fps_n,
+        state->fps_d);
+
+    state->width = video_format.width;
+    state->height = video_format.height;
+    GST_DEBUG ("Frame dimensions are %d x %d\n", state->width, state->height);
+
+    state->clean_width = video_format.clean_width;
+    state->clean_height = video_format.clean_height;
+    state->clean_offset_left = video_format.left_offset;
+    state->clean_offset_top = video_format.top_offset;
+
+    state->par_n = video_format.aspect_ratio_numerator;
+    state->par_d = video_format.aspect_ratio_denominator;
+    GST_DEBUG ("Pixel aspect ratio is %d/%d", state->par_n, state->par_d);
+
+    /* FIXME state points to what is actually in the decoder */
+    //gst_base_video_decoder_set_state (GST_BASE_VIDEO_DECODER (schro_dec),
+    //    state);
+  } else {
+    GST_WARNING ("Failed to get frame rate from sequence header");
+  }
+
+  gst_schrodec_send_tags (schro_dec);
+}
+
+
+static GstFlowReturn
+gst_schro_dec_parse_data (GstBaseVideoDecoder * base_video_decoder,
+    gboolean at_eos)
+{
+  GstSchroDec *schro_decoder;
+  unsigned char header[SCHRO_PARSE_HEADER_SIZE];
+  int next;
+  int prev;
+  int parse_code;
+
+  GST_DEBUG_OBJECT (base_video_decoder, "parse_data");
+
+  schro_decoder = GST_SCHRO_DEC (base_video_decoder);
+
+  if (gst_adapter_available (base_video_decoder->input_adapter) <
+      SCHRO_PARSE_HEADER_SIZE) {
+    return GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA;
+  }
+
+  GST_DEBUG ("available %d",
+      gst_adapter_available (base_video_decoder->input_adapter));
+
+  gst_adapter_copy (base_video_decoder->input_adapter, header, 0,
+      SCHRO_PARSE_HEADER_SIZE);
+
+  parse_code = header[4];
+  next = GST_READ_UINT32_BE (header + 5);
+  prev = GST_READ_UINT32_BE (header + 9);
+
+  GST_DEBUG ("%08x %02x %08x %08x",
+      GST_READ_UINT32_BE (header), parse_code, next, prev);
+
+  if (memcmp (header, "BBCD", 4) != 0 ||
+      (next & 0xf0000000) || (prev & 0xf0000000)) {
+    gst_base_video_decoder_lost_sync (base_video_decoder);
+    return GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE (parse_code)) {
+    GstVideoFrame *frame;
+
+    if (next != 0 && next != SCHRO_PARSE_HEADER_SIZE) {
+      GST_WARNING ("next is not 0 or 13 in EOS packet (%d)", next);
+    }
+
+    gst_base_video_decoder_add_to_frame (base_video_decoder,
+        SCHRO_PARSE_HEADER_SIZE);
+
+    frame = base_video_decoder->current_frame;
+    frame->is_eos = TRUE;
+
+    SCHRO_DEBUG ("eos");
+
+    return gst_base_video_decoder_have_frame (base_video_decoder);
+  }
+
+  if (gst_adapter_available (base_video_decoder->input_adapter) < next) {
+    return GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_SEQ_HEADER (parse_code)) {
+    guint8 *data;
+
+    data = g_malloc (next);
+
+    gst_adapter_copy (base_video_decoder->input_adapter, data, 0, next);
+    parse_sequence_header (schro_decoder, data, next);
+
+    gst_base_video_decoder_set_sync_point (base_video_decoder);
+
+    if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->last_sink_timestamp)) {
+      base_video_decoder->current_frame->presentation_timestamp =
+          base_video_decoder->last_sink_timestamp;
+      GST_DEBUG ("got timestamp %lld", base_video_decoder->last_sink_timestamp);
+    } else if (base_video_decoder->last_sink_offset_end != -1) {
+      GstVideoState *state;
+
+#if 0
+      /* FIXME perhaps should use this to determine if the granulepos
+       * is valid */
+      {
+        guint64 pt;
+        int dist_h;
+        int dist_l;
+        int dist;
+        int delay;
+        guint64 dt;
+        gint64 granulepos = base_video_decoder->last_sink_offset_end;
+
+        pt = ((granulepos >> 22) +
+            (granulepos & OGG_DIRAC_GRANULE_LOW_MASK)) >> 9;
+        dist_h = (granulepos >> 22) & 0xff;
+        dist_l = granulepos & 0xff;
+        dist = (dist_h << 8) | dist_l;
+        delay = (granulepos >> 9) & 0x1fff;
+        dt = pt - delay;
+        GST_DEBUG ("gp pt %lld dist %d delay %d dt %lld", pt, dist, delay, dt);
+      }
+#endif
+      state =
+          gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER
+          (schro_decoder));
+      base_video_decoder->current_frame->presentation_timestamp =
+          gst_util_uint64_scale (granulepos_to_frame
+          (base_video_decoder->last_sink_offset_end), state->fps_d * GST_SECOND,
+          state->fps_n);
+    } else {
+      base_video_decoder->current_frame->presentation_timestamp = -1;
+    }
+
+    g_free (data);
+  }
+
+  if (schro_decoder->seq_header_buffer == NULL) {
+    gst_adapter_flush (base_video_decoder->input_adapter, next);
+    return GST_FLOW_OK;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_PICTURE (parse_code)) {
+    GstVideoFrame *frame;
+    guint8 tmp[4];
+
+    frame = base_video_decoder->current_frame;
+
+    gst_adapter_copy (base_video_decoder->input_adapter, tmp,
+        SCHRO_PARSE_HEADER_SIZE, 4);
+
+    frame->presentation_frame_number = GST_READ_UINT32_BE (tmp);
+
+    gst_base_video_decoder_add_to_frame (base_video_decoder, next);
+
+    return gst_base_video_decoder_have_frame (base_video_decoder);
+  } else {
+    gst_base_video_decoder_add_to_frame (base_video_decoder, next);
+  }
+
+  return GST_FLOW_OK;
+}
+
+static int
+gst_schro_dec_scan_for_sync (GstBaseVideoDecoder * base_video_decoder,
+    gboolean at_eos, int offset, int n)
+{
+  GstAdapter *adapter = base_video_decoder->input_adapter;
+  int n_available;
+
+  n_available = gst_adapter_available (adapter) - offset;
+
+  if (n_available < 4) {
+    if (at_eos) {
+      return n_available;
+    } else {
+      return 0;
+    }
+  }
+
+  n_available -= 3;
+
+  return gst_adapter_masked_scan_uint32 (adapter, 0x42424344, 0xffffffff,
+      offset, MIN (n, n_available - 3));
+}
+
+
+static void
+gst_schrodec_send_tags (GstSchroDec * schro_dec)
+{
+  GstTagList *list;
+
+  list = gst_tag_list_new ();
+  gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
+      GST_TAG_VIDEO_CODEC, "Dirac", NULL);
+
+  gst_element_found_tags_for_pad (GST_ELEMENT_CAST (schro_dec),
+      GST_BASE_VIDEO_CODEC_SRC_PAD (schro_dec), list);
+}
+
+static GstFlowReturn
+gst_schro_dec_process (GstSchroDec * schro_dec, gboolean eos)
+{
+  gboolean go;
+  GstFlowReturn ret;
+
+  ret = GST_FLOW_OK;
+  go = TRUE;
+  while (go) {
+    int it;
+
+    it = schro_decoder_autoparse_wait (schro_dec->decoder);
+
+    switch (it) {
+      case SCHRO_DECODER_FIRST_ACCESS_UNIT:
+        break;
+      case SCHRO_DECODER_NEED_BITS:
+        GST_DEBUG ("need bits");
+        go = 0;
+        break;
+      case SCHRO_DECODER_NEED_FRAME:
+      {
+        GstBuffer *outbuf;
+        GstVideoState *state;
+        SchroFrame *schro_frame;
+        GstFlowReturn flow_ret;
+        int size;
+
+        GST_DEBUG ("need frame");
+
+        state =
+            gst_base_video_decoder_get_state (GST_BASE_VIDEO_DECODER
+            (schro_dec));
+        size =
+            gst_video_format_get_size (state->format, state->width,
+            state->height);
+        flow_ret =
+            gst_pad_alloc_buffer_and_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+            (schro_dec), GST_BUFFER_OFFSET_NONE, size,
+            GST_PAD_CAPS (GST_BASE_VIDEO_CODEC_SRC_PAD (schro_dec)), &outbuf);
+        if (flow_ret != GST_FLOW_OK) {
+          go = FALSE;
+          ret = flow_ret;
+          break;
+        }
+        schro_frame = gst_schro_buffer_wrap (outbuf,
+            state->format, state->width, state->height);
+        schro_decoder_add_output_picture (schro_dec->decoder, schro_frame);
+        break;
+      }
+      case SCHRO_DECODER_OK:
+      {
+        SchroFrame *schro_frame;
+        SchroTag *tag;
+        GstVideoFrame *frame;
+
+        GST_DEBUG ("got frame");
+
+        tag = schro_decoder_get_picture_tag (schro_dec->decoder);
+        schro_frame = schro_decoder_pull (schro_dec->decoder);
+        frame = tag->value;
+
+        if (schro_frame) {
+          if (schro_frame->priv) {
+            GstFlowReturn flow_ret;
+
+            frame->src_buffer = gst_buffer_ref (GST_BUFFER (schro_frame->priv));
+
+            flow_ret =
+                gst_base_video_decoder_finish_frame (GST_BASE_VIDEO_DECODER
+                (schro_dec), frame);
+            if (flow_ret != GST_FLOW_OK) {
+              GST_DEBUG ("finish frame returned %d", flow_ret);
+              return flow_ret;
+            }
+          } else {
+            GST_DEBUG ("skipped frame");
+          }
+
+          schro_frame_unref (schro_frame);
+        }
+        if (!eos) {
+          go = FALSE;
+        }
+      }
+
+        break;
+      case SCHRO_DECODER_EOS:
+        GST_DEBUG ("eos");
+        go = FALSE;
+        break;
+      case SCHRO_DECODER_ERROR:
+        go = FALSE;
+        GST_DEBUG ("codec error");
+        ret = GST_FLOW_ERROR;
+        break;
+    }
+  }
+  return ret;
+}
+
+GstFlowReturn
+gst_schro_dec_handle_frame (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoFrame * frame)
+{
+  GstSchroDec *schro_dec;
+  int schro_ret;
+  SchroBuffer *input_buffer;
+  GstVideoState *state;
+
+  schro_dec = GST_SCHRO_DEC (base_video_decoder);
+
+  GST_DEBUG ("handle frame");
+
+  state = gst_base_video_decoder_get_state (base_video_decoder);
+
+  gst_base_video_decoder_set_src_caps (base_video_decoder);
+
+  input_buffer = gst_schro_wrap_gst_buffer (frame->sink_buffer);
+  frame->sink_buffer = NULL;
+
+  input_buffer->tag = schro_tag_new (frame, NULL);
+
+  schro_ret = schro_decoder_autoparse_push (schro_dec->decoder, input_buffer);
+
+  return gst_schro_dec_process (schro_dec, FALSE);
+}
+
+GstFlowReturn
+gst_schro_dec_finish (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoFrame * frame)
+{
+  GstSchroDec *schro_dec;
+
+  schro_dec = GST_SCHRO_DEC (base_video_decoder);
+
+  GST_DEBUG ("finish");
+
+  gst_base_video_decoder_set_src_caps (base_video_decoder);
+
+  schro_decoder_autoparse_push_end_of_sequence (schro_dec->decoder);
+
+  return gst_schro_dec_process (schro_dec, TRUE);
+}
diff -Naur ext/schroedinger/gstschroenc.c ext/schroedinger/gstschroenc.c
--- ext/schroedinger/gstschroenc.c	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/gstschroenc.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,736 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/video/gstbasevideoencoder.h>
+#include <string.h>
+
+#include <schroedinger/schro.h>
+#include <schroedinger/schrobitstream.h>
+#include <schroedinger/schrovirtframe.h>
+#include <math.h>
+#include "gstschroutils.h"
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+#define GST_TYPE_SCHRO_ENC \
+  (gst_schro_enc_get_type())
+#define GST_SCHRO_ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCHRO_ENC,GstSchroEnc))
+#define GST_SCHRO_ENC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCHRO_ENC,GstSchroEncClass))
+#define GST_IS_SCHRO_ENC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCHRO_ENC))
+#define GST_IS_SCHRO_ENC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCHRO_ENC))
+
+typedef struct _GstSchroEnc GstSchroEnc;
+typedef struct _GstSchroEncClass GstSchroEncClass;
+
+typedef enum
+{
+  GST_SCHRO_ENC_OUTPUT_OGG,
+  GST_SCHRO_ENC_OUTPUT_QUICKTIME,
+  GST_SCHRO_ENC_OUTPUT_AVI,
+  GST_SCHRO_ENC_OUTPUT_MPEG_TS,
+  GST_SCHRO_ENC_OUTPUT_MP4
+} GstSchroEncOutputType;
+
+struct _GstSchroEnc
+{
+  GstBaseVideoEncoder base_encoder;
+
+  GstPad *sinkpad;
+  GstPad *srcpad;
+
+  /* video properties */
+  GstSchroEncOutputType output_format;
+
+  /* state */
+  SchroEncoder *encoder;
+  SchroVideoFormat *video_format;
+  GstVideoFrame *eos_frame;
+  GstBuffer *seq_header_buffer;
+
+  guint64 last_granulepos;
+};
+
+struct _GstSchroEncClass
+{
+  GstBaseVideoEncoderClass parent_class;
+};
+
+
+
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_schro_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_schro_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+static GstFlowReturn gst_schro_enc_process (GstSchroEnc * schro_enc);
+
+static gboolean gst_schro_enc_set_format (GstBaseVideoEncoder *
+    base_video_encoder, GstVideoState * state);
+static gboolean gst_schro_enc_start (GstBaseVideoEncoder * base_video_encoder);
+static gboolean gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder);
+static gboolean gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame);
+static gboolean gst_schro_enc_handle_frame (GstBaseVideoEncoder *
+    base_video_encoder, GstVideoFrame * frame);
+static GstFlowReturn gst_schro_enc_shape_output (GstBaseVideoEncoder *
+    base_video_encoder, GstVideoFrame * frame);
+static GstCaps *gst_schro_enc_get_caps (GstBaseVideoEncoder *
+    base_video_encoder);
+
+static GstStaticPadTemplate gst_schro_enc_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (GST_VIDEO_CAPS_YUV ("{ I420, YV12, YUY2, UYVY, AYUV }"))
+    );
+
+static GstStaticPadTemplate gst_schro_enc_src_template =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-dirac;video/x-qt-part;video/x-mp4-part")
+    );
+
+GST_BOILERPLATE (GstSchroEnc, gst_schro_enc, GstBaseVideoEncoder,
+    GST_TYPE_BASE_VIDEO_ENCODER);
+
+static void
+gst_schro_enc_base_init (gpointer g_class)
+{
+  static GstElementDetails schro_enc_details =
+      GST_ELEMENT_DETAILS ("Dirac Encoder",
+      "Codec/Encoder/Video",
+      "Encode raw video into Dirac stream",
+      "David Schleef <ds@schleef.org>");
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_enc_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_enc_sink_template));
+
+  gst_element_class_set_details (element_class, &schro_enc_details);
+}
+
+static void
+gst_schro_enc_class_init (GstSchroEncClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseVideoEncoderClass *basevideocoder_class;
+  int i;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+  basevideocoder_class = GST_BASE_VIDEO_ENCODER_CLASS (klass);
+
+  gobject_class->set_property = gst_schro_enc_set_property;
+  gobject_class->get_property = gst_schro_enc_get_property;
+
+  for (i = 0; i < schro_encoder_get_n_settings (); i++) {
+    const SchroEncoderSetting *setting;
+
+    setting = schro_encoder_get_setting_info (i);
+
+    switch (setting->type) {
+      case SCHRO_ENCODER_SETTING_TYPE_BOOLEAN:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_boolean (setting->name, setting->name, setting->name,
+                setting->default_value, G_PARAM_READWRITE));
+        break;
+      case SCHRO_ENCODER_SETTING_TYPE_INT:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_int (setting->name, setting->name, setting->name,
+                setting->min, setting->max, setting->default_value,
+                G_PARAM_READWRITE));
+        break;
+      case SCHRO_ENCODER_SETTING_TYPE_ENUM:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_int (setting->name, setting->name, setting->name,
+                setting->min, setting->max, setting->default_value,
+                G_PARAM_READWRITE));
+        break;
+      case SCHRO_ENCODER_SETTING_TYPE_DOUBLE:
+        g_object_class_install_property (gobject_class, i + 1,
+            g_param_spec_double (setting->name, setting->name, setting->name,
+                setting->min, setting->max, setting->default_value,
+                G_PARAM_READWRITE));
+        break;
+      default:
+        break;
+    }
+  }
+
+  basevideocoder_class->set_format =
+      GST_DEBUG_FUNCPTR (gst_schro_enc_set_format);
+  basevideocoder_class->start = GST_DEBUG_FUNCPTR (gst_schro_enc_start);
+  basevideocoder_class->stop = GST_DEBUG_FUNCPTR (gst_schro_enc_stop);
+  basevideocoder_class->finish = GST_DEBUG_FUNCPTR (gst_schro_enc_finish);
+  basevideocoder_class->handle_frame =
+      GST_DEBUG_FUNCPTR (gst_schro_enc_handle_frame);
+  basevideocoder_class->shape_output =
+      GST_DEBUG_FUNCPTR (gst_schro_enc_shape_output);
+  basevideocoder_class->get_caps = GST_DEBUG_FUNCPTR (gst_schro_enc_get_caps);
+}
+
+static void
+gst_schro_enc_init (GstSchroEnc * schro_enc, GstSchroEncClass * klass)
+{
+  GST_DEBUG ("gst_schro_enc_init");
+
+  /* Normally, we'd create the encoder in ->start(), but we use the
+   * encoder to store object properties.  So it needs to be created
+   * here. */
+  schro_enc->encoder = schro_encoder_new ();
+  schro_encoder_set_packet_assembly (schro_enc->encoder, TRUE);
+  schro_enc->video_format = schro_encoder_get_video_format (schro_enc->encoder);
+}
+
+
+
+static gboolean
+gst_schro_enc_set_format (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoState * state)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  schro_video_format_set_std_video_format (schro_enc->video_format,
+      SCHRO_VIDEO_FORMAT_CUSTOM);
+
+  switch (state->format) {
+    case GST_VIDEO_FORMAT_I420:
+    case GST_VIDEO_FORMAT_YV12:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_420;
+      break;
+    case GST_VIDEO_FORMAT_YUY2:
+    case GST_VIDEO_FORMAT_UYVY:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_422;
+      break;
+    case GST_VIDEO_FORMAT_AYUV:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_444;
+      break;
+    case GST_VIDEO_FORMAT_ARGB:
+      schro_enc->video_format->chroma_format = SCHRO_CHROMA_420;
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  schro_enc->video_format->frame_rate_numerator = state->fps_n;
+  schro_enc->video_format->frame_rate_denominator = state->fps_d;
+
+  schro_enc->video_format->width = state->width;
+  schro_enc->video_format->height = state->height;
+  schro_enc->video_format->clean_width = state->clean_width;
+  schro_enc->video_format->clean_height = state->clean_height;
+  schro_enc->video_format->left_offset = state->clean_offset_left;
+  schro_enc->video_format->top_offset = state->clean_offset_top;
+
+  schro_enc->video_format->aspect_ratio_numerator = state->par_n;
+  schro_enc->video_format->aspect_ratio_denominator = state->par_d;
+
+  schro_video_format_set_std_signal_range (schro_enc->video_format,
+      SCHRO_SIGNAL_RANGE_8BIT_VIDEO);
+  schro_video_format_set_std_colour_spec (schro_enc->video_format,
+      SCHRO_COLOUR_SPEC_HDTV);
+
+  schro_encoder_set_video_format (schro_enc->encoder, schro_enc->video_format);
+  schro_encoder_start (schro_enc->encoder);
+
+  schro_enc->seq_header_buffer =
+      gst_schro_wrap_schro_buffer (schro_encoder_encode_sequence_header
+      (schro_enc->encoder));
+
+  return TRUE;
+}
+
+static void
+gst_schro_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstSchroEnc *src;
+
+  g_return_if_fail (GST_IS_SCHRO_ENC (object));
+  src = GST_SCHRO_ENC (object);
+
+  GST_DEBUG ("gst_schro_enc_set_property");
+
+  if (prop_id >= 1) {
+    const SchroEncoderSetting *setting;
+    setting = schro_encoder_get_setting_info (prop_id - 1);
+    switch (G_VALUE_TYPE (value)) {
+      case G_TYPE_DOUBLE:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_double (value));
+        break;
+      case G_TYPE_INT:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_int (value));
+        break;
+      case G_TYPE_BOOLEAN:
+        schro_encoder_setting_set_double (src->encoder, setting->name,
+            g_value_get_boolean (value));
+        break;
+    }
+  }
+}
+
+static void
+gst_schro_enc_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstSchroEnc *src;
+
+  g_return_if_fail (GST_IS_SCHRO_ENC (object));
+  src = GST_SCHRO_ENC (object);
+
+  if (prop_id >= 1) {
+    const SchroEncoderSetting *setting;
+    setting = schro_encoder_get_setting_info (prop_id - 1);
+    switch (G_VALUE_TYPE (value)) {
+      case G_TYPE_DOUBLE:
+        g_value_set_double (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+      case G_TYPE_INT:
+        g_value_set_int (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+      case G_TYPE_BOOLEAN:
+        g_value_set_boolean (value,
+            schro_encoder_setting_get_double (src->encoder, setting->name));
+        break;
+    }
+  }
+}
+
+/*
+ * start is called once the input format is known.  This function
+ * must decide on an output format and negotiate it.
+ */
+static gboolean
+gst_schro_enc_start (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+  GstCaps *caps;
+  GstStructure *structure;
+
+  GST_DEBUG ("set_output_caps");
+  caps =
+      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+      (base_video_encoder));
+
+  if (gst_caps_is_empty (caps)) {
+    gst_caps_unref (caps);
+    return FALSE;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  if (gst_structure_has_name (structure, "video/x-dirac")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_OGG;
+  } else if (gst_structure_has_name (structure, "video/x-qt-part")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_QUICKTIME;
+  } else if (gst_structure_has_name (structure, "video/x-avi-part")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_AVI;
+  } else if (gst_structure_has_name (structure, "video/x-mp4-part")) {
+    schro_enc->output_format = GST_SCHRO_ENC_OUTPUT_MP4;
+  } else {
+    return FALSE;
+  }
+
+  gst_base_video_encoder_set_latency_fields (base_video_encoder,
+      2 * (int) schro_encoder_setting_get_double (schro_enc->encoder,
+          "queue_depth"));
+
+  gst_caps_unref (caps);
+  return TRUE;
+}
+
+static gboolean
+gst_schro_enc_stop (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  if (schro_enc->encoder) {
+    schro_encoder_free (schro_enc->encoder);
+    schro_enc->encoder = NULL;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_enc_finish (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  GST_DEBUG ("finish");
+
+  schro_enc->eos_frame = frame;
+
+  schro_encoder_end_of_stream (schro_enc->encoder);
+  gst_schro_enc_process (schro_enc);
+
+  return TRUE;
+}
+
+static gboolean
+gst_schro_enc_handle_frame (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc = GST_SCHRO_ENC (base_video_encoder);
+  SchroFrame *schro_frame;
+  GstFlowReturn ret;
+  const GstVideoState *state;
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  schro_frame = gst_schro_buffer_wrap (frame->sink_buffer,
+      state->format, state->width, state->height);
+
+  GST_DEBUG ("pushing frame %p", frame);
+  schro_encoder_push_frame_full (schro_enc->encoder, schro_frame, frame);
+
+  ret = gst_schro_enc_process (schro_enc);
+
+  return ret;
+}
+
+#if 0
+static void
+gst_caps_add_streamheader (GstCaps * caps, GList * list)
+{
+  GValue array = { 0 };
+  GValue value = { 0 };
+  GstBuffer *buf;
+  GList *g;
+
+  g_value_init (&array, GST_TYPE_ARRAY);
+
+  for (g = g_list_first (list); g; g = g_list_next (list)) {
+    g_value_init (&value, GST_TYPE_BUFFER);
+    buf = gst_buffer_copy (GST_BUFFER (g->data));
+    gst_value_set_buffer (&value, buf);
+    gst_buffer_unref (buf);
+    gst_value_array_append_value (&array, &value);
+    g_value_unset (&value);
+  }
+  gst_structure_set_value (gst_caps_get_structure (caps, 0),
+      "streamheader", &array);
+  g_value_unset (&array);
+}
+#endif
+
+static GstCaps *
+gst_schro_enc_get_caps (GstBaseVideoEncoder * base_video_encoder)
+{
+  GstCaps *caps;
+  const GstVideoState *state;
+  GstSchroEnc *schro_enc;
+
+  schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_OGG) {
+    caps = gst_caps_new_simple ("video/x-dirac",
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+
+    GST_BUFFER_FLAG_SET (schro_enc->seq_header_buffer, GST_BUFFER_FLAG_IN_CAPS);
+
+    {
+      GValue array = { 0 };
+      GValue value = { 0 };
+      GstBuffer *buf;
+      int size;
+
+      g_value_init (&array, GST_TYPE_ARRAY);
+      g_value_init (&value, GST_TYPE_BUFFER);
+      size = GST_BUFFER_SIZE (schro_enc->seq_header_buffer);
+      buf = gst_buffer_new_and_alloc (size + SCHRO_PARSE_HEADER_SIZE);
+      memcpy (GST_BUFFER_DATA (buf),
+          GST_BUFFER_DATA (schro_enc->seq_header_buffer), size);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 0, 0x42424344);
+      GST_WRITE_UINT8 (GST_BUFFER_DATA (buf) + size + 4,
+          SCHRO_PARSE_CODE_END_OF_SEQUENCE);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 5, 0);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 9, size);
+      gst_value_set_buffer (&value, buf);
+      gst_buffer_unref (buf);
+      gst_value_array_append_value (&array, &value);
+      gst_structure_set_value (gst_caps_get_structure (caps, 0),
+          "streamheader", &array);
+      g_value_unset (&value);
+      g_value_unset (&array);
+    }
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_QUICKTIME) {
+    caps = gst_caps_new_simple ("video/x-qt-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_AVI) {
+    caps = gst_caps_new_simple ("video/x-avi-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_MPEG_TS) {
+    caps = gst_caps_new_simple ("video/x-mpegts-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_enc->output_format == GST_SCHRO_ENC_OUTPUT_MP4) {
+    caps = gst_caps_new_simple ("video/x-mp4-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else {
+    g_assert_not_reached ();
+  }
+
+  return caps;
+}
+
+
+
+
+static GstFlowReturn
+gst_schro_enc_shape_output_ogg (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc;
+  int dpn;
+  int delay;
+  int dist;
+  int pt;
+  int dt;
+  guint64 granulepos_hi;
+  guint64 granulepos_low;
+  GstBuffer *buf = frame->src_buffer;
+
+  schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  dpn = frame->decode_frame_number;
+
+  pt = frame->presentation_frame_number * 2;
+  dt = frame->decode_frame_number * 2;
+  delay = pt - dt;
+  dist = frame->distance_from_sync;
+
+  GST_DEBUG ("sys %d dpn %d pt %d dt %d delay %d dist %d",
+      (int) frame->system_frame_number,
+      (int) frame->decode_frame_number, pt, dt, delay, dist);
+
+  granulepos_hi = (((uint64_t) pt - delay) << 9) | ((dist >> 8));
+  granulepos_low = (delay << 9) | (dist & 0xff);
+  GST_DEBUG ("granulepos %lld:%lld", granulepos_hi, granulepos_low);
+
+  if (frame->is_eos) {
+    GST_BUFFER_OFFSET_END (buf) = schro_enc->last_granulepos;
+  } else {
+    schro_enc->last_granulepos = (granulepos_hi << 22) | (granulepos_low);
+    GST_BUFFER_OFFSET_END (buf) = schro_enc->last_granulepos;
+  }
+
+  gst_buffer_set_caps (buf, base_video_encoder->caps);
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
+}
+
+static GstFlowReturn
+gst_schro_enc_shape_output_quicktime (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number);
+  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->system_frame_number);
+  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
+
+  if (frame->is_sync_point &&
+      frame->presentation_frame_number == frame->system_frame_number) {
+    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  gst_buffer_set_caps (buf, base_video_encoder->caps);
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
+}
+
+static GstFlowReturn
+gst_schro_enc_shape_output_mp4 (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_encoder_get_state (base_video_encoder);
+
+  GST_BUFFER_TIMESTAMP (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number);
+  GST_BUFFER_DURATION (buf) = gst_video_state_get_timestamp (state,
+      frame->presentation_frame_number + 1) - GST_BUFFER_TIMESTAMP (buf);
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->decode_frame_number);
+  GST_BUFFER_OFFSET (buf) = GST_CLOCK_TIME_NONE;
+
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->system_frame_number);
+
+  if (frame->is_sync_point &&
+      frame->presentation_frame_number == frame->system_frame_number) {
+    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  gst_buffer_set_caps (buf, base_video_encoder->caps);
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), buf);
+}
+
+static GstFlowReturn
+gst_schro_enc_shape_output (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstSchroEnc *schro_enc;
+
+  schro_enc = GST_SCHRO_ENC (base_video_encoder);
+
+  switch (schro_enc->output_format) {
+    case GST_SCHRO_ENC_OUTPUT_OGG:
+      return gst_schro_enc_shape_output_ogg (base_video_encoder, frame);
+    case GST_SCHRO_ENC_OUTPUT_QUICKTIME:
+      return gst_schro_enc_shape_output_quicktime (base_video_encoder, frame);
+    case GST_SCHRO_ENC_OUTPUT_MP4:
+      return gst_schro_enc_shape_output_mp4 (base_video_encoder, frame);
+    default:
+      g_assert_not_reached ();
+      break;
+  }
+
+  return GST_FLOW_ERROR;
+}
+
+static GstFlowReturn
+gst_schro_enc_process (GstSchroEnc * schro_enc)
+{
+  SchroBuffer *encoded_buffer;
+  GstVideoFrame *frame;
+  GstFlowReturn ret;
+  int presentation_frame;
+  void *voidptr;
+  GstBaseVideoEncoder *base_video_encoder = GST_BASE_VIDEO_ENCODER (schro_enc);
+
+  GST_DEBUG ("process");
+
+  while (1) {
+    switch (schro_encoder_wait (schro_enc->encoder)) {
+      case SCHRO_STATE_NEED_FRAME:
+        return GST_FLOW_OK;
+      case SCHRO_STATE_END_OF_STREAM:
+        GST_DEBUG ("EOS");
+        return GST_FLOW_OK;
+      case SCHRO_STATE_HAVE_BUFFER:
+        voidptr = NULL;
+        encoded_buffer = schro_encoder_pull_full (schro_enc->encoder,
+            &presentation_frame, &voidptr);
+        frame = voidptr;
+        if (encoded_buffer == NULL) {
+          GST_DEBUG ("encoder_pull returned NULL");
+          /* FIXME This shouldn't happen */
+          return GST_FLOW_ERROR;
+        }
+
+        if (voidptr == NULL) {
+          GST_DEBUG ("got eos");
+          frame = schro_enc->eos_frame;
+        }
+
+        if (SCHRO_PARSE_CODE_IS_SEQ_HEADER (encoded_buffer->data[4])) {
+          frame->is_sync_point = TRUE;
+        }
+
+        frame->src_buffer = gst_schro_wrap_schro_buffer (encoded_buffer);
+
+        ret = gst_base_video_encoder_finish_frame (base_video_encoder, frame);
+
+        if (ret != GST_FLOW_OK) {
+          GST_DEBUG ("pad_push returned %d", ret);
+          return ret;
+        }
+        break;
+      case SCHRO_STATE_AGAIN:
+        break;
+    }
+  }
+  return GST_FLOW_OK;
+}
diff -Naur ext/schroedinger/gstschroparse.c ext/schroedinger/gstschroparse.c
--- ext/schroedinger/gstschroparse.c	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/gstschroparse.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,610 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <gst/video/video.h>
+#include <gst/video/gstbasevideoparse.h>
+#include <string.h>
+#include <schroedinger/schro.h>
+#include <liboil/liboil.h>
+#include <math.h>
+
+#include <schroedinger/schroparse.h>
+
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+#define GST_TYPE_SCHRO_PARSE \
+  (gst_schro_parse_get_type())
+#define GST_SCHRO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCHRO_PARSE,GstSchroParse))
+#define GST_SCHRO_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCHRO_PARSE,GstSchroParseClass))
+#define GST_IS_SCHRO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCHRO_PARSE))
+#define GST_IS_SCHRO_PARSE_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCHRO_PARSE))
+
+typedef struct _GstSchroParse GstSchroParse;
+typedef struct _GstSchroParseClass GstSchroParseClass;
+
+typedef enum
+{
+  GST_SCHRO_PARSE_OUTPUT_OGG,
+  GST_SCHRO_PARSE_OUTPUT_QUICKTIME,
+  GST_SCHRO_PARSE_OUTPUT_AVI,
+  GST_SCHRO_PARSE_OUTPUT_MPEG_TS,
+  GST_SCHRO_PARSE_OUTPUT_MP4
+} GstSchroParseOutputType;
+
+struct _GstSchroParse
+{
+  GstBaseVideoParse base_video_parse;
+
+  GstPad *sinkpad, *srcpad;
+
+  GstSchroParseOutputType output_format;
+
+  GstBuffer *seq_header_buffer;
+
+  /* state */
+
+
+  gboolean have_picture;
+  int buf_picture_number;
+  int seq_hdr_picture_number;
+  int picture_number;
+
+  guint64 last_granulepos;
+
+  int bytes_per_picture;
+};
+
+struct _GstSchroParseClass
+{
+  GstBaseVideoParseClass base_video_parse_class;
+};
+
+/* GstSchroParse signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_schro_parse_finalize (GObject * object);
+
+static gboolean gst_schro_parse_start (GstBaseVideoParse * base_video_parse);
+static gboolean gst_schro_parse_stop (GstBaseVideoParse * base_video_parse);
+static gboolean gst_schro_parse_reset (GstBaseVideoParse * base_video_parse);
+static int gst_schro_parse_scan_for_sync (GstAdapter * adapter,
+    gboolean at_eos, int offset, int n);
+static gboolean gst_schro_parse_parse_data (GstBaseVideoParse *
+    base_video_parse, gboolean at_eos);
+static gboolean gst_schro_parse_shape_output (GstBaseVideoParse *
+    base_video_parse, GstVideoFrame * frame);
+static GstCaps *gst_schro_parse_get_caps (GstBaseVideoParse * base_video_parse);
+
+
+
+static GstStaticPadTemplate gst_schro_parse_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-dirac")
+    );
+
+static GstStaticPadTemplate gst_schro_parse_src_template =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS
+    ("video/x-dirac;video/x-qt-part;video/x-avi-part;video/x-mp4-part")
+    );
+
+GST_BOILERPLATE (GstSchroParse, gst_schro_parse, GstBaseVideoParse,
+    GST_TYPE_BASE_VIDEO_PARSE);
+
+static void
+gst_schro_parse_base_init (gpointer g_class)
+{
+  static GstElementDetails compress_details =
+      GST_ELEMENT_DETAILS ("Dirac Parser",
+      "Codec/Parser/Video",
+      "Parse Dirac streams",
+      "David Schleef <ds@schleef.org>");
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_parse_src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&gst_schro_parse_sink_template));
+
+  gst_element_class_set_details (element_class, &compress_details);
+}
+
+static void
+gst_schro_parse_class_init (GstSchroParseClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+  GstBaseVideoParseClass *base_video_parse_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+  base_video_parse_class = GST_BASE_VIDEO_PARSE_CLASS (klass);
+
+  gobject_class->finalize = gst_schro_parse_finalize;
+
+  base_video_parse_class->start = GST_DEBUG_FUNCPTR (gst_schro_parse_start);
+  base_video_parse_class->stop = GST_DEBUG_FUNCPTR (gst_schro_parse_stop);
+  base_video_parse_class->reset = GST_DEBUG_FUNCPTR (gst_schro_parse_reset);
+  base_video_parse_class->parse_data =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_parse_data);
+  base_video_parse_class->shape_output =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_shape_output);
+  base_video_parse_class->scan_for_sync =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_scan_for_sync);
+  base_video_parse_class->get_caps =
+      GST_DEBUG_FUNCPTR (gst_schro_parse_get_caps);
+
+}
+
+static void
+gst_schro_parse_init (GstSchroParse * schro_parse, GstSchroParseClass * klass)
+{
+  GstBaseVideoParse *base_video_parse = GST_BASE_VIDEO_PARSE (schro_parse);
+
+  GST_DEBUG ("gst_schro_parse_init");
+
+  schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_OGG;
+
+  base_video_parse->reorder_depth = 2;
+}
+
+static gboolean
+gst_schro_parse_reset (GstBaseVideoParse * base_video_parse)
+{
+  GstSchroParse *schro_parse;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  GST_DEBUG ("reset");
+
+  return TRUE;
+}
+
+static void
+gst_schro_parse_finalize (GObject * object)
+{
+  GstSchroParse *schro_parse;
+
+  g_return_if_fail (GST_IS_SCHRO_PARSE (object));
+  schro_parse = GST_SCHRO_PARSE (object);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_schro_parse_start (GstBaseVideoParse * base_video_parse)
+{
+  GstSchroParse *schro_parse = GST_SCHRO_PARSE (base_video_parse);
+  GstCaps *caps;
+  GstStructure *structure;
+
+  GST_DEBUG ("start");
+  caps =
+      gst_pad_get_allowed_caps (GST_BASE_VIDEO_CODEC_SRC_PAD
+      (base_video_parse));
+
+  if (gst_caps_is_empty (caps)) {
+    gst_caps_unref (caps);
+    return FALSE;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  if (gst_structure_has_name (structure, "video/x-dirac")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_OGG;
+  } else if (gst_structure_has_name (structure, "video/x-qt-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_QUICKTIME;
+  } else if (gst_structure_has_name (structure, "video/x-avi-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_AVI;
+  } else if (gst_structure_has_name (structure, "video/x-mpegts-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_MPEG_TS;
+  } else if (gst_structure_has_name (structure, "video/x-mp4-part")) {
+    schro_parse->output_format = GST_SCHRO_PARSE_OUTPUT_MP4;
+  } else {
+    return FALSE;
+  }
+
+  gst_caps_unref (caps);
+  return TRUE;
+}
+
+static gboolean
+gst_schro_parse_stop (GstBaseVideoParse * base_video_parse)
+{
+  return TRUE;
+}
+
+static void
+parse_sequence_header (GstSchroParse * schro_parse, guint8 * data, int size)
+{
+  SchroVideoFormat video_format;
+  int ret;
+  GstVideoState *state;
+
+  GST_DEBUG ("parse_sequence_header size=%d", size);
+
+  state = gst_base_video_parse_get_state (GST_BASE_VIDEO_PARSE (schro_parse));
+
+  schro_parse->seq_header_buffer = gst_buffer_new_and_alloc (size);
+  memcpy (GST_BUFFER_DATA (schro_parse->seq_header_buffer), data, size);
+
+  ret = schro_parse_decode_sequence_header (data + 13, size - 13,
+      &video_format);
+  if (ret) {
+    state->fps_n = video_format.frame_rate_numerator;
+    state->fps_d = video_format.frame_rate_denominator;
+    GST_DEBUG ("Frame rate is %d/%d", state->fps_n, state->fps_d);
+
+    state->width = video_format.width;
+    state->height = video_format.height;
+    GST_DEBUG ("Frame dimensions are %d x %d\n", state->width, state->height);
+
+    state->clean_width = video_format.clean_width;
+    state->clean_height = video_format.clean_height;
+    state->clean_offset_left = video_format.left_offset;
+    state->clean_offset_top = video_format.top_offset;
+
+    state->par_n = video_format.aspect_ratio_numerator;
+    state->par_d = video_format.aspect_ratio_denominator;
+    GST_DEBUG ("Pixel aspect ratio is %d/%d", state->par_n, state->par_d);
+
+    gst_base_video_parse_set_state (GST_BASE_VIDEO_PARSE (schro_parse), state);
+  } else {
+    GST_WARNING ("Failed to get frame rate from sequence header");
+  }
+
+}
+
+static int
+gst_schro_parse_scan_for_sync (GstAdapter * adapter, gboolean at_eos,
+    int offset, int n)
+{
+  int n_available = gst_adapter_available (adapter) - offset;
+
+  if (n_available < 4) {
+    if (at_eos) {
+      return n_available;
+    } else {
+      return 0;
+    }
+  }
+
+  n_available -= 3;
+
+  return gst_adapter_masked_scan_uint32 (adapter, 0x42424344, 0xffffffff,
+      offset, MIN (n, n_available - 3));
+}
+
+static GstFlowReturn
+gst_schro_parse_parse_data (GstBaseVideoParse * base_video_parse,
+    gboolean at_eos)
+{
+  GstSchroParse *schro_parse;
+  unsigned char header[SCHRO_PARSE_HEADER_SIZE];
+  int next;
+  int prev;
+  int parse_code;
+
+  GST_DEBUG ("parse_data");
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  if (gst_adapter_available (base_video_parse->input_adapter) <
+      SCHRO_PARSE_HEADER_SIZE) {
+    return GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA;
+  }
+
+  GST_DEBUG ("available %d",
+      gst_adapter_available (base_video_parse->input_adapter));
+
+  gst_adapter_copy (base_video_parse->input_adapter, header, 0,
+      SCHRO_PARSE_HEADER_SIZE);
+
+  parse_code = header[4];
+  next = GST_READ_UINT32_BE (header + 5);
+  prev = GST_READ_UINT32_BE (header + 9);
+
+  GST_DEBUG ("%08x %02x %08x %08x",
+      GST_READ_UINT32_BE (header), parse_code, next, prev);
+
+  if (memcmp (header, "BBCD", 4) != 0 ||
+      (next & 0xf0000000) || (prev & 0xf0000000)) {
+    gst_base_video_parse_lost_sync (base_video_parse);
+    return GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE (parse_code)) {
+    GstVideoFrame *frame;
+
+    if (next != 0 && next != SCHRO_PARSE_HEADER_SIZE) {
+      GST_WARNING ("next is not 0 or 13 in EOS packet (%d)", next);
+    }
+
+    gst_base_video_parse_add_to_frame (base_video_parse,
+        SCHRO_PARSE_HEADER_SIZE);
+
+    frame = gst_base_video_parse_get_frame (base_video_parse);
+    frame->is_eos = TRUE;
+
+    SCHRO_DEBUG ("eos");
+
+    return gst_base_video_parse_finish_frame (base_video_parse);
+  }
+
+  if (gst_adapter_available (base_video_parse->input_adapter) < next) {
+    return GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_SEQ_HEADER (parse_code)) {
+    guint8 *data;
+
+    data = g_malloc (next);
+
+    gst_adapter_copy (base_video_parse->input_adapter, data, 0, next);
+    parse_sequence_header (schro_parse, data, next);
+
+    base_video_parse->current_frame->is_sync_point = TRUE;
+
+    g_free (data);
+  }
+
+  if (schro_parse->seq_header_buffer == NULL) {
+    gst_adapter_flush (base_video_parse->input_adapter, next);
+    return GST_FLOW_OK;
+  }
+
+  if (SCHRO_PARSE_CODE_IS_PICTURE (parse_code)) {
+    GstVideoFrame *frame;
+    guint8 tmp[4];
+
+    frame = gst_base_video_parse_get_frame (base_video_parse);
+
+#if 0
+    if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_TIMESTAMP (buf))) {
+      frame->presentation_timestamp = GST_BUFFER_TIMESTAMP (buf);
+    }
+#endif
+
+    gst_adapter_copy (base_video_parse->input_adapter, tmp,
+        SCHRO_PARSE_HEADER_SIZE, 4);
+
+    frame->presentation_frame_number = GST_READ_UINT32_BE (tmp);
+
+    gst_base_video_parse_add_to_frame (base_video_parse, next);
+
+    return gst_base_video_parse_finish_frame (base_video_parse);
+  } else {
+    gst_base_video_parse_add_to_frame (base_video_parse, next);
+  }
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output_ogg (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstSchroParse *schro_parse;
+  int dpn;
+  int delay;
+  int dist;
+  int pt;
+  int dt;
+  guint64 granulepos_hi;
+  guint64 granulepos_low;
+  GstBuffer *buf = frame->src_buffer;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  dpn = frame->decode_frame_number;
+
+  pt = frame->presentation_frame_number * 2;
+  dt = frame->decode_frame_number * 2;
+  delay = pt - dt;
+  dist = frame->distance_from_sync;
+
+  GST_DEBUG ("sys %d dpn %d pt %d dt %d delay %d dist %d",
+      (int) frame->system_frame_number,
+      (int) frame->decode_frame_number, pt, dt, delay, dist);
+
+  granulepos_hi = (((guint64) pt - delay) << 9) | ((dist >> 8));
+  granulepos_low = (delay << 9) | (dist & 0xff);
+  GST_DEBUG ("granulepos %lld:%lld", granulepos_hi, granulepos_low);
+
+  if (frame->is_eos) {
+    GST_BUFFER_OFFSET_END (buf) = schro_parse->last_granulepos;
+  } else {
+    schro_parse->last_granulepos = (granulepos_hi << 22) | (granulepos_low);
+    GST_BUFFER_OFFSET_END (buf) = schro_parse->last_granulepos;
+  }
+
+  return gst_base_video_parse_push (base_video_parse, buf);
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output_quicktime (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_parse_get_state (base_video_parse);
+
+  GST_BUFFER_OFFSET_END (buf) = gst_video_state_get_timestamp (state,
+      frame->system_frame_number);
+
+  if (frame->is_sync_point &&
+      frame->presentation_frame_number == frame->system_frame_number) {
+    GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+    GST_DEBUG ("sync point");
+  } else {
+    GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  return gst_base_video_parse_push (base_video_parse, buf);
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output_mpeg_ts (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstBuffer *buf = frame->src_buffer;
+  const GstVideoState *state;
+
+  state = gst_base_video_parse_get_state (base_video_parse);
+
+  return gst_base_video_parse_push (base_video_parse, buf);
+}
+
+static GstFlowReturn
+gst_schro_parse_shape_output (GstBaseVideoParse * base_video_parse,
+    GstVideoFrame * frame)
+{
+  GstSchroParse *schro_parse;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  switch (schro_parse->output_format) {
+    case GST_SCHRO_PARSE_OUTPUT_OGG:
+      return gst_schro_parse_shape_output_ogg (base_video_parse, frame);
+    case GST_SCHRO_PARSE_OUTPUT_QUICKTIME:
+      return gst_schro_parse_shape_output_quicktime (base_video_parse, frame);
+    case GST_SCHRO_PARSE_OUTPUT_MPEG_TS:
+      return gst_schro_parse_shape_output_mpeg_ts (base_video_parse, frame);
+    default:
+      break;
+  }
+
+  return GST_FLOW_ERROR;
+}
+
+static GstCaps *
+gst_schro_parse_get_caps (GstBaseVideoParse * base_video_parse)
+{
+  GstCaps *caps;
+  GstVideoState *state;
+  GstSchroParse *schro_parse;
+
+  schro_parse = GST_SCHRO_PARSE (base_video_parse);
+
+  state = gst_base_video_parse_get_state (base_video_parse);
+
+  if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_OGG) {
+    caps = gst_caps_new_simple ("video/x-dirac",
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+
+    GST_BUFFER_FLAG_SET (schro_parse->seq_header_buffer,
+        GST_BUFFER_FLAG_IN_CAPS);
+
+    {
+      GValue array = { 0 };
+      GValue value = { 0 };
+      GstBuffer *buf;
+      int size;
+
+      g_value_init (&array, GST_TYPE_ARRAY);
+      g_value_init (&value, GST_TYPE_BUFFER);
+      size = GST_BUFFER_SIZE (schro_parse->seq_header_buffer);
+      buf = gst_buffer_new_and_alloc (size + SCHRO_PARSE_HEADER_SIZE);
+      memcpy (GST_BUFFER_DATA (buf),
+          GST_BUFFER_DATA (schro_parse->seq_header_buffer), size);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 0, 0x42424344);
+      GST_WRITE_UINT8 (GST_BUFFER_DATA (buf) + size + 4,
+          SCHRO_PARSE_CODE_END_OF_SEQUENCE);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 5, 0);
+      GST_WRITE_UINT32_BE (GST_BUFFER_DATA (buf) + size + 9, size);
+      gst_value_set_buffer (&value, buf);
+      gst_buffer_unref (buf);
+      gst_value_array_append_value (&array, &value);
+      gst_structure_set_value (gst_caps_get_structure (caps, 0),
+          "streamheader", &array);
+      g_value_unset (&value);
+      g_value_unset (&array);
+    }
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_QUICKTIME) {
+    caps = gst_caps_new_simple ("video/x-qt-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_AVI) {
+    caps = gst_caps_new_simple ("video/x-avi-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_MPEG_TS) {
+    caps = gst_caps_new_simple ("video/x-mpegts-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else if (schro_parse->output_format == GST_SCHRO_PARSE_OUTPUT_MP4) {
+    caps = gst_caps_new_simple ("video/x-mp4-part",
+        "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('d', 'r', 'a', 'c'),
+        "width", G_TYPE_INT, state->width,
+        "height", G_TYPE_INT, state->height,
+        "framerate", GST_TYPE_FRACTION, state->fps_n,
+        state->fps_d,
+        "pixel-aspect-ratio", GST_TYPE_FRACTION, state->par_n,
+        state->par_d, NULL);
+  } else {
+    g_assert_not_reached ();
+  }
+
+  return caps;
+}
diff -Naur ext/schroedinger/gstschroutils.c ext/schroedinger/gstschroutils.c
--- ext/schroedinger/gstschroutils.c	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/gstschroutils.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,149 @@
+/* Schrodinger
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+//#define SCHRO_ENABLE_UNSTABLE_API
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <schroedinger/schro.h>
+#include <schroedinger/schrobitstream.h>
+#include <schroedinger/schrovirtframe.h>
+#include <math.h>
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (schro_debug);
+#define GST_CAT_DEFAULT schro_debug
+
+
+
+
+static void
+gst_schro_frame_free (SchroFrame * frame, void *priv)
+{
+  gst_buffer_unref (GST_BUFFER (priv));
+}
+
+SchroFrame *
+gst_schro_buffer_wrap (GstBuffer * buf, GstVideoFormat format, int width,
+    int height)
+{
+  SchroFrame *frame;
+
+  switch (format) {
+    case GST_VIDEO_FORMAT_I420:
+      frame =
+          schro_frame_new_from_data_I420 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_YV12:
+      frame =
+          schro_frame_new_from_data_YV12 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_YUY2:
+      frame =
+          schro_frame_new_from_data_YUY2 (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_UYVY:
+      frame =
+          schro_frame_new_from_data_UYVY (GST_BUFFER_DATA (buf), width, height);
+      break;
+    case GST_VIDEO_FORMAT_AYUV:
+      frame =
+          schro_frame_new_from_data_AYUV (GST_BUFFER_DATA (buf), width, height);
+      break;
+#if 0
+    case GST_VIDEO_FORMAT_ARGB:
+    {
+      SchroFrame *rgbframe =
+          schro_frame_new_from_data_AYUV (GST_BUFFER_DATA (buf), width, height);
+      SchroFrame *vframe1;
+      SchroFrame *vframe2;
+      SchroFrame *vframe3;
+
+      vframe1 = schro_virt_frame_new_unpack (rgbframe);
+      vframe2 = schro_virt_frame_new_color_matrix (vframe1);
+      vframe3 =
+          schro_virt_frame_new_subsample (vframe2, SCHRO_FRAME_FORMAT_U8_420);
+
+      frame = schro_frame_new_and_alloc (NULL, SCHRO_FRAME_FORMAT_U8_420,
+          width, height);
+      schro_virt_frame_render (vframe3, frame);
+      schro_frame_unref (vframe3);
+    }
+      break;
+#endif
+    default:
+      g_assert_not_reached ();
+  }
+  schro_frame_set_free_callback (frame, gst_schro_frame_free, buf);
+
+  return frame;
+}
+
+#ifdef GST_BUFFER_FREE_FUNC
+static void
+schro_buf_free_func (gpointer priv)
+{
+  SchroBuffer *buffer = (SchroBuffer *) priv;
+
+  schro_buffer_unref (buffer);
+}
+#endif
+
+/* takes the reference */
+GstBuffer *
+gst_schro_wrap_schro_buffer (SchroBuffer * buffer)
+{
+  GstBuffer *gstbuf;
+
+#ifdef GST_BUFFER_FREE_FUNC
+  gstbuf = gst_buffer_new ();
+  GST_BUFFER_DATA (gstbuf) = buffer->data;
+  GST_BUFFER_SIZE (gstbuf) = buffer->length;
+  GST_BUFFER_MALLOCDATA (gstbuf) = (void *) buffer;
+  GST_BUFFER_FREE_FUNC (gstbuf) = schro_buf_free_func;
+#else
+  gstbuf = gst_buffer_new_and_alloc (buffer->length);
+  memcpy (GST_BUFFER_DATA (gstbuf), buffer->data, buffer->length);
+#endif
+
+  return gstbuf;
+}
+
+static void
+gst_schro_buffer_free (SchroBuffer * buffer, void *priv)
+{
+  gst_buffer_unref (GST_BUFFER (priv));
+}
+
+SchroBuffer *
+gst_schro_wrap_gst_buffer (GstBuffer * buffer)
+{
+  SchroBuffer *schrobuf;
+
+  schrobuf = schro_buffer_new_with_data (GST_BUFFER_DATA (buffer),
+      GST_BUFFER_SIZE (buffer));
+  schrobuf->free = gst_schro_buffer_free;
+  schrobuf->priv = buffer;
+
+  return schrobuf;
+}
diff -Naur ext/schroedinger/gstschroutils.h ext/schroedinger/gstschroutils.h
--- ext/schroedinger/gstschroutils.h	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/gstschroutils.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,34 @@
+/* Schrodinger
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_SCHRO_UTILS_H_
+#define _GST_SCHRO_UTILS_H_
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <schroedinger/schro.h>
+
+SchroFrame *
+gst_schro_buffer_wrap (GstBuffer *buf, GstVideoFormat format, int width,
+    int height);
+GstBuffer * gst_schro_wrap_schro_buffer (SchroBuffer *buffer);
+SchroBuffer * gst_schro_wrap_gst_buffer (GstBuffer *buffer);
+
+#endif
+
diff -Naur ext/schroedinger/Makefile.am ext/schroedinger/Makefile.am
--- ext/schroedinger/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ ext/schroedinger/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,24 @@
+
+plugin_LTLIBRARIES = libgstschro.la
+
+noinst_HEADERS = \
+	gstschroutils.h
+
+libgstschro_la_SOURCES = \
+	gstschro.c \
+	gstschrodec.c \
+	gstschroenc.c \
+	gstschroparse.c \
+	gstschroutils.c
+libgstschro_la_CFLAGS = \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_CFLAGS) \
+	$(SCHRO_CFLAGS)
+libgstschro_la_LIBADD = \
+	$(top_builddir)/gst-libs/gst/video/libgstvideo-$(GST_MAJORMINOR).la \
+	$(GST_LIBS) \
+	$(SCHRO_LIBS)
+libgstschro_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstschro_la_LIBTOOLFLAGS = --tag=disable-static
+
+
diff -Naur ext/theora/gsttheoradec.h ext/theora/gsttheoradec.h
--- ext/theora/gsttheoradec.h	2009-01-21 11:36:13.000000000 +0100
+++ ext/theora/gsttheoradec.h	2009-05-19 18:44:45.000000000 +0200
@@ -72,6 +72,7 @@
   gboolean need_keyframe;
   gint width, height;
   gint offset_x, offset_y;
+  gint output_bpp;
 
   gboolean crop;
 
diff -Naur ext/theora/theora.c ext/theora/theora.c
--- ext/theora/theora.c	2009-01-21 11:36:13.000000000 +0100
+++ ext/theora/theora.c	2009-05-19 18:44:45.000000000 +0200
@@ -34,7 +34,7 @@
           gst_theora_dec_get_type ()))
     return FALSE;
 
-  if (!gst_element_register (plugin, "theoraenc", GST_RANK_NONE,
+  if (!gst_element_register (plugin, "theoraenc", GST_RANK_PRIMARY,
           gst_theora_enc_get_type ()))
     return FALSE;
 
diff -Naur ext/theora/theoradec.c ext/theora/theoradec.c
--- ext/theora/theoradec.c	2009-04-15 21:18:27.000000000 +0200
+++ ext/theora/theoradec.c	2009-05-19 18:44:45.000000000 +0200
@@ -66,7 +66,7 @@
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("video/x-raw-yuv, "
-        "format = (fourcc) I420, "
+        "format = (fourcc) { I420, Y42B, Y444 }, "
         "framerate = (fraction) [0/1, MAX], "
         "width = (int) [ 1, MAX ], " "height = (int) [ 1, MAX ]")
     );
@@ -346,8 +346,8 @@
     case GST_FORMAT_BYTES:
       switch (*dest_format) {
         case GST_FORMAT_DEFAULT:
-          *dest_value = gst_util_uint64_scale_int (src_value, 2,
-              dec->info.height * dec->info.width * 3);
+          *dest_value = gst_util_uint64_scale_int (src_value, 8,
+              dec->info.height * dec->info.width * dec->output_bpp);
           break;
         case GST_FORMAT_TIME:
           /* seems like a rather silly conversion, implement me if you like */
@@ -358,7 +358,7 @@
     case GST_FORMAT_TIME:
       switch (*dest_format) {
         case GST_FORMAT_BYTES:
-          scale = 3 * (dec->info.width * dec->info.height) / 2;
+          scale = dec->output_bpp * (dec->info.width * dec->info.height) / 8;
         case GST_FORMAT_DEFAULT:
           *dest_value = scale * gst_util_uint64_scale (src_value,
               dec->info.fps_numerator, dec->info.fps_denominator * GST_SECOND);
@@ -375,7 +375,7 @@
           break;
         case GST_FORMAT_BYTES:
           *dest_value = gst_util_uint64_scale_int (src_value,
-              3 * dec->info.width * dec->info.height, 2);
+              dec->output_bpp * dec->info.width * dec->info.height, 8);
           break;
         default:
           res = FALSE;
@@ -853,6 +853,7 @@
   GstFlowReturn ret = GST_FLOW_OK;
   guint32 bitstream_version;
   GList *walk;
+  guint32 fourcc;
 
   GST_DEBUG_OBJECT (dec, "fps %d/%d, PAR %d/%d",
       dec->info.fps_numerator, dec->info.fps_denominator,
@@ -888,10 +889,18 @@
   GST_DEBUG_OBJECT (dec, "frame dimension %dx%d, offset %d:%d",
       dec->info.frame_width, dec->info.frame_height,
       dec->info.offset_x, dec->info.offset_y);
-  if (dec->info.pixelformat != OC_PF_420) {
-    GST_ELEMENT_ERROR (GST_ELEMENT (dec), STREAM, DECODE,
-        (NULL), ("pixel formats other than 4:2:0 not yet supported"));
 
+  if (dec->info.pixelformat == OC_PF_420) {
+    dec->output_bpp = 12;       /* Average bits per pixel. */
+    fourcc = GST_MAKE_FOURCC ('I', '4', '2', '0');
+  } else if (dec->info.pixelformat == OC_PF_422) {
+    dec->output_bpp = 16;
+    fourcc = GST_MAKE_FOURCC ('Y', '4', '2', 'B');
+  } else if (dec->info.pixelformat == OC_PF_444) {
+    dec->output_bpp = 24;
+    fourcc = GST_MAKE_FOURCC ('Y', '4', '4', '4');
+  } else {
+    GST_ERROR_OBJECT (dec, "Invalid pixel format %d", dec->info.pixelformat);
     return GST_FLOW_ERROR;
   }
 
@@ -931,7 +940,7 @@
   theora_decode_init (&dec->state, &dec->info);
 
   caps = gst_caps_new_simple ("video/x-raw-yuv",
-      "format", GST_TYPE_FOURCC, GST_MAKE_FOURCC ('I', '4', '2', '0'),
+      "format", GST_TYPE_FOURCC, fourcc,
       "framerate", GST_TYPE_FRACTION,
       dec->info.fps_numerator, dec->info.fps_denominator,
       "pixel-aspect-ratio", GST_TYPE_FRACTION, par_num, par_den,
@@ -1106,73 +1115,123 @@
   return result;
 }
 
+/* Allocate buffer and copy image data into Y444 format */
 static GstFlowReturn
-theora_handle_data_packet (GstTheoraDec * dec, ogg_packet * packet,
-    GstClockTime outtime)
+theora_handle_444_image (GstTheoraDec * dec, yuv_buffer * yuv, GstBuffer ** out)
 {
-  /* normal data packet */
-  yuv_buffer yuv;
-  GstBuffer *out;
-  guint i;
-  gboolean keyframe;
+  gint width = dec->width;
+  gint height = dec->height;
   gint out_size;
-  gint stride_y, stride_uv;
-  gint width, height;
-  gint cwidth, cheight;
+  gint stride;
   GstFlowReturn result;
+  int i, plane;
 
-  if (G_UNLIKELY (!dec->have_header))
-    goto not_initialized;
+  stride = GST_ROUND_UP_4 (width);
+  out_size = stride * height * 3;
 
-  /* the second most significant bit of the first data byte is cleared 
-   * for keyframes. We can only check it if it's not a zero-length packet. */
-  keyframe = packet->bytes && ((packet->packet[0] & 0x40) == 0);
-  if (G_UNLIKELY (keyframe)) {
-    GST_DEBUG_OBJECT (dec, "we have a keyframe");
-    dec->need_keyframe = FALSE;
-  } else if (G_UNLIKELY (dec->need_keyframe)) {
-    goto dropping;
-  }
+  /* now copy over the area contained in offset_x,offset_y,
+   * frame_width, frame_height */
+  result =
+      gst_pad_alloc_buffer_and_set_caps (dec->srcpad, GST_BUFFER_OFFSET_NONE,
+      out_size, GST_PAD_CAPS (dec->srcpad), out);
+  if (G_UNLIKELY (result != GST_FLOW_OK))
+    goto no_buffer;
 
-  GST_DEBUG_OBJECT (dec, "parsing data packet");
+  {
+    guchar *dest, *src;
 
-  /* this does the decoding */
-  if (G_UNLIKELY (theora_decode_packetin (&dec->state, packet)))
-    goto decode_error;
+    for (plane = 0; plane < 3; plane++) {
+      dest = GST_BUFFER_DATA (*out) + plane * stride * height;
 
-  if (outtime != -1) {
-    gboolean need_skip;
-    GstClockTime qostime;
+      src = (plane == 0 ? yuv->y : (plane == 1 ? yuv->u : yuv->v)) +
+          dec->offset_x + dec->offset_y * yuv->y_stride;
 
-    /* qos needs to be done on running time */
-    qostime = gst_segment_to_running_time (&dec->segment, GST_FORMAT_TIME,
-        outtime);
+      for (i = 0; i < height; i++) {
+        memcpy (dest, src, width);
 
-    GST_OBJECT_LOCK (dec);
-    /* check for QoS, don't perform the last steps of getting and
-     * pushing the buffers that are known to be late. */
-    /* FIXME, we can also entirely skip decoding if the next valid buffer is 
-     * known to be after a keyframe (using the granule_shift) */
-    need_skip = dec->earliest_time != -1 && qostime <= dec->earliest_time;
-    GST_OBJECT_UNLOCK (dec);
+        dest += stride;
+        src += yuv->y_stride;
+      }
+    }
+  }
 
-    if (need_skip)
-      goto dropping_qos;
+no_buffer:
+  {
+    GST_DEBUG_OBJECT (dec, "could not get buffer, reason: %s",
+        gst_flow_get_name (result));
+    return result;
   }
+}
 
-  /* this does postprocessing and set up the decoded frame
-   * pointers in our yuv variable */
-  if (G_UNLIKELY (theora_decode_YUVout (&dec->state, &yuv) < 0))
-    goto no_yuv;
 
-  if (G_UNLIKELY ((yuv.y_width != dec->info.width)
-          || (yuv.y_height != dec->info.height)))
-    goto wrong_dimensions;
+/* Allocate buffer and copy image data into Y42B format */
+static GstFlowReturn
+theora_handle_422_image (GstTheoraDec * dec, yuv_buffer * yuv, GstBuffer ** out)
+{
+  gint width = dec->width;
+  gint uvwidth = dec->width / 2;
+  gint height = dec->height;
+  gint out_size;
+  gint ystride, uvstride;
+  GstFlowReturn result;
+  int i;
+  guint8 *dst, *src;
+
+  ystride = GST_ROUND_UP_4 (width);
+  uvstride = GST_ROUND_UP_8 (width) / 2;
+  out_size = ystride * height + uvstride * height * 2;
+
+  /* now copy over the area contained in offset_x,offset_y,
+   * frame_width, frame_height */
+  result =
+      gst_pad_alloc_buffer_and_set_caps (dec->srcpad, GST_BUFFER_OFFSET_NONE,
+      out_size, GST_PAD_CAPS (dec->srcpad), out);
+  if (G_UNLIKELY (result != GST_FLOW_OK))
+    goto no_buffer;
+
+  dst = GST_BUFFER_DATA (*out);
+
+  src = yuv->y;
+  for (i = 0; i < height; i++) {
+    memcpy (dst, src, width);
+    src += yuv->y_stride;
+    dst += ystride;
+  }
+
+  src = yuv->u;
+  for (i = 0; i < height; i++) {
+    memcpy (dst, src, uvwidth);
+    src += yuv->uv_stride;
+    dst += uvstride;
+  }
+
+  src = yuv->v;
+  for (i = 0; i < height; i++) {
+    memcpy (dst, src, uvwidth);
+    src += yuv->uv_stride;
+    dst += uvstride;
+  }
+
+no_buffer:
+  {
+    GST_DEBUG_OBJECT (dec, "could not get buffer, reason: %s",
+        gst_flow_get_name (result));
+    return result;
+  }
+}
 
-  width = dec->width;
-  height = dec->height;
-  cwidth = width / 2;
-  cheight = height / 2;
+/* Allocate buffer and copy image data into I420 format */
+static GstFlowReturn
+theora_handle_420_image (GstTheoraDec * dec, yuv_buffer * yuv, GstBuffer ** out)
+{
+  gint width = dec->width;
+  gint height = dec->height;
+  gint cwidth = width / 2;
+  gint cheight = height / 2;
+  gint out_size;
+  gint stride_y, stride_uv;
+  GstFlowReturn result;
+  int i;
 
   /* should get the stride from the caps, for now we round up to the nearest
    * multiple of 4 because some element needs it. chroma needs special 
@@ -1187,7 +1246,7 @@
    * frame_width, frame_height */
   result =
       gst_pad_alloc_buffer_and_set_caps (dec->srcpad, GST_BUFFER_OFFSET_NONE,
-      out_size, GST_PAD_CAPS (dec->srcpad), &out);
+      out_size, GST_PAD_CAPS (dec->srcpad), out);
   if (G_UNLIKELY (result != GST_FLOW_OK))
     goto no_buffer;
 
@@ -1204,7 +1263,7 @@
     guchar *dest_v, *src_v;
     gint offset;
 
-    dest_y = GST_BUFFER_DATA (out);
+    dest_y = GST_BUFFER_DATA (*out);
     dest_u = dest_y + stride_y * GST_ROUND_UP_2 (height);
     dest_v = dest_u + stride_uv * GST_ROUND_UP_2 (height) / 2;
 
@@ -1212,30 +1271,108 @@
     GST_LOG_OBJECT (dec, "plane 1, offset %d", dest_u - dest_y);
     GST_LOG_OBJECT (dec, "plane 2, offset %d", dest_v - dest_y);
 
-    src_y = yuv.y + dec->offset_x + dec->offset_y * yuv.y_stride;
+    src_y = yuv->y + dec->offset_x + dec->offset_y * yuv->y_stride;
 
     for (i = 0; i < height; i++) {
       memcpy (dest_y, src_y, width);
 
       dest_y += stride_y;
-      src_y += yuv.y_stride;
+      src_y += yuv->y_stride;
     }
 
-    offset = dec->offset_x / 2 + dec->offset_y / 2 * yuv.uv_stride;
+    offset = dec->offset_x / 2 + dec->offset_y / 2 * yuv->uv_stride;
 
-    src_u = yuv.u + offset;
-    src_v = yuv.v + offset;
+    src_u = yuv->u + offset;
+    src_v = yuv->v + offset;
 
     for (i = 0; i < cheight; i++) {
       memcpy (dest_u, src_u, cwidth);
       memcpy (dest_v, src_v, cwidth);
 
       dest_u += stride_uv;
-      src_u += yuv.uv_stride;
+      src_u += yuv->uv_stride;
       dest_v += stride_uv;
-      src_v += yuv.uv_stride;
+      src_v += yuv->uv_stride;
     }
   }
+no_buffer:
+  {
+    GST_DEBUG_OBJECT (dec, "could not get buffer, reason: %s",
+        gst_flow_get_name (result));
+    return result;
+  }
+}
+
+static GstFlowReturn
+theora_handle_data_packet (GstTheoraDec * dec, ogg_packet * packet,
+    GstClockTime outtime)
+{
+  /* normal data packet */
+  yuv_buffer yuv;
+  GstBuffer *out;
+  gboolean keyframe;
+  GstFlowReturn result;
+
+  if (G_UNLIKELY (!dec->have_header))
+    goto not_initialized;
+
+  /* the second most significant bit of the first data byte is cleared 
+   * for keyframes. We can only check it if it's not a zero-length packet. */
+  keyframe = packet->bytes && ((packet->packet[0] & 0x40) == 0);
+  if (G_UNLIKELY (keyframe)) {
+    GST_DEBUG_OBJECT (dec, "we have a keyframe");
+    dec->need_keyframe = FALSE;
+  } else if (G_UNLIKELY (dec->need_keyframe)) {
+    goto dropping;
+  }
+
+  GST_DEBUG_OBJECT (dec, "parsing data packet");
+
+  /* this does the decoding */
+  if (G_UNLIKELY (theora_decode_packetin (&dec->state, packet)))
+    goto decode_error;
+
+  if (outtime != -1) {
+    gboolean need_skip;
+    GstClockTime qostime;
+
+    /* qos needs to be done on running time */
+    qostime = gst_segment_to_running_time (&dec->segment, GST_FORMAT_TIME,
+        outtime);
+
+    GST_OBJECT_LOCK (dec);
+    /* check for QoS, don't perform the last steps of getting and
+     * pushing the buffers that are known to be late. */
+    /* FIXME, we can also entirely skip decoding if the next valid buffer is 
+     * known to be after a keyframe (using the granule_shift) */
+    need_skip = dec->earliest_time != -1 && qostime <= dec->earliest_time;
+    GST_OBJECT_UNLOCK (dec);
+
+    if (need_skip)
+      goto dropping_qos;
+  }
+
+  /* this does postprocessing and set up the decoded frame
+   * pointers in our yuv variable */
+  if (G_UNLIKELY (theora_decode_YUVout (&dec->state, &yuv) < 0))
+    goto no_yuv;
+
+  if (G_UNLIKELY ((yuv.y_width != dec->info.width)
+          || (yuv.y_height != dec->info.height)))
+    goto wrong_dimensions;
+
+  if (dec->info.pixelformat == OC_PF_420) {
+    result = theora_handle_420_image (dec, &yuv, &out);
+  } else if (dec->info.pixelformat == OC_PF_422) {
+    result = theora_handle_422_image (dec, &yuv, &out);
+  } else if (dec->info.pixelformat == OC_PF_444) {
+    result = theora_handle_444_image (dec, &yuv, &out);
+  } else {
+    g_assert_not_reached ();
+  }
+
+  if (result != GST_FLOW_OK)
+    return result;
 
   GST_BUFFER_OFFSET (out) = dec->frame_nr;
   if (dec->frame_nr != -1)
@@ -1299,12 +1436,6 @@
         (NULL), ("dimensions of image do not match header"));
     return GST_FLOW_ERROR;
   }
-no_buffer:
-  {
-    GST_DEBUG_OBJECT (dec, "could not get buffer, reason: %s",
-        gst_flow_get_name (result));
-    return result;
-  }
 }
 
 static GstFlowReturn
diff -Naur ext/theora/theoraenc.c ext/theora/theoraenc.c
--- ext/theora/theoraenc.c	2009-05-06 14:42:51.000000000 +0200
+++ ext/theora/theoraenc.c	2009-05-19 18:44:45.000000000 +0200
@@ -181,7 +181,21 @@
     GST_STATIC_CAPS ("video/x-theora")
     );
 
-GST_BOILERPLATE (GstTheoraEnc, gst_theora_enc, GstElement, GST_TYPE_ELEMENT);
+static void
+_do_init (GType object_type)
+{
+  const GInterfaceInfo preset_interface_info = {
+    NULL,                       /* interface_init */
+    NULL,                       /* interface_finalize */
+    NULL                        /* interface_data */
+  };
+
+  g_type_add_interface_static (object_type, GST_TYPE_PRESET,
+      &preset_interface_info);
+}
+
+GST_BOILERPLATE_FULL (GstTheoraEnc, gst_theora_enc, GstElement,
+    GST_TYPE_ELEMENT, _do_init);
 
 static gboolean theora_enc_sink_event (GstPad * pad, GstEvent * event);
 static gboolean theora_enc_src_event (GstPad * pad, GstEvent * event);
diff -Naur ext/vorbis/vorbis.c ext/vorbis/vorbis.c
--- ext/vorbis/vorbis.c	2009-04-01 13:49:11.000000000 +0200
+++ ext/vorbis/vorbis.c	2009-05-19 18:44:45.000000000 +0200
@@ -36,7 +36,7 @@
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
-  if (!gst_element_register (plugin, "vorbisenc", GST_RANK_NONE,
+  if (!gst_element_register (plugin, "vorbisenc", GST_RANK_PRIMARY,
           GST_TYPE_VORBISENC))
     return FALSE;
 
diff -Naur ext/vorbis/vorbisenc.c ext/vorbis/vorbisenc.c
--- ext/vorbis/vorbisenc.c	2009-05-06 14:42:51.000000000 +0200
+++ ext/vorbis/vorbisenc.c	2009-05-19 18:44:45.000000000 +0200
@@ -145,9 +145,11 @@
 gst_vorbis_enc_add_interfaces (GType vorbisenc_type)
 {
   static const GInterfaceInfo tag_setter_info = { NULL, NULL, NULL };
+  static const GInterfaceInfo preset_info = { NULL, NULL, NULL };
 
   g_type_add_interface_static (vorbisenc_type, GST_TYPE_TAG_SETTER,
       &tag_setter_info);
+  g_type_add_interface_static (vorbisenc_type, GST_TYPE_PRESET, &preset_info);
 }
 
 static void
diff -Naur gst/adder/adder.vcproj gst/adder/adder.vcproj
--- gst/adder/adder.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/adder/adder.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,148 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="adder"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678A1}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;adder_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstadder.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/adder.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstadder.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;adder_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstadder.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstadder.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstadder.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\gstadder.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/adder/gstadder.c gst/adder/gstadder.c
--- gst/adder/gstadder.c	2009-04-01 13:49:11.000000000 +0200
+++ gst/adder/gstadder.c	2009-05-19 18:44:45.000000000 +0200
@@ -288,7 +288,7 @@
     gst_structure_get_int (structure, "endianness", &adder->endianness);
     gst_structure_get_boolean (structure, "signed", &adder->is_signed);
 
-    GST_INFO_OBJECT (adder, "parse_caps sets adder to format int, %d bit",
+    GST_INFO_OBJECT (pad, "parse_caps sets adder to format int, %d bit",
         adder->width);
 
     if (adder->endianness != G_BYTE_ORDER)
@@ -315,7 +315,7 @@
     gst_structure_get_int (structure, "width", &adder->width);
     gst_structure_get_int (structure, "endianness", &adder->endianness);
 
-    GST_INFO_OBJECT (adder, "parse_caps sets adder to format float, %d bit",
+    GST_INFO_OBJECT (pad, "parse_caps sets adder to format float, %d bit",
         adder->width);
 
     if (adder->endianness != G_BYTE_ORDER)
@@ -582,6 +582,7 @@
         event, GST_EVENT_TYPE_NAME (event));
   }
   gst_object_unref (pad);
+  /* continue on other pads, even if one failed */
   return TRUE;
 }
 
@@ -596,6 +597,7 @@
 {
   gboolean ret;
   GstIterator *it;
+  GstIteratorResult ires;
   GValue vret = { 0 };
 
   GST_LOG_OBJECT (adder, "Forwarding event %p (%s)", event,
@@ -606,13 +608,30 @@
   g_value_init (&vret, G_TYPE_BOOLEAN);
   g_value_set_boolean (&vret, TRUE);
   it = gst_element_iterate_sink_pads (GST_ELEMENT_CAST (adder));
-  gst_iterator_fold (it, (GstIteratorFoldFunction) forward_event_func, &vret,
-      event);
+  while (TRUE) {
+    ires = gst_iterator_fold (it, (GstIteratorFoldFunction) forward_event_func,
+        &vret, event);
+    switch (ires) {
+      case GST_ITERATOR_RESYNC:
+        GST_WARNING ("resync");
+        gst_iterator_resync (it);
+        g_value_set_boolean (&vret, TRUE);
+        break;
+      case GST_ITERATOR_OK:
+      case GST_ITERATOR_DONE:
+        ret = g_value_get_boolean (&vret);
+        goto done;
+      default:
+        ret = FALSE;
+        goto done;
+    }
+  }
+done:
   gst_iterator_free (it);
+  GST_LOG_OBJECT (adder, "Forwarded event %p (%s), ret=%d", event,
+      GST_EVENT_TYPE_NAME (event), ret);
   gst_event_unref (event);
 
-  ret = g_value_get_boolean (&vret);
-
   return ret;
 }
 
@@ -625,10 +644,6 @@
   adder = GST_ADDER (gst_pad_get_parent (pad));
 
   switch (GST_EVENT_TYPE (event)) {
-    case GST_EVENT_QOS:
-      /* QoS might be tricky */
-      result = FALSE;
-      break;
     case GST_EVENT_SEEK:
     {
       GstSeekFlags flags;
@@ -648,6 +663,7 @@
          * when all pads received a FLUSH_STOP. */
         gst_pad_push_event (adder->srcpad, gst_event_new_flush_start ());
       }
+      GST_DEBUG_OBJECT (adder, "handling seek event: %" GST_PTR_FORMAT, event);
       /* now wait for the collected to be finished and mark a new
        * segment */
       GST_OBJECT_LOCK (adder->collect);
@@ -657,16 +673,33 @@
         adder->segment_position = 0;
       adder->segment_pending = TRUE;
       GST_OBJECT_UNLOCK (adder->collect);
+      GST_DEBUG_OBJECT (adder, "forwarding seek event: %" GST_PTR_FORMAT,
+          event);
 
       result = forward_event (adder, event);
+      if (result) {
+        /* seek failed. maybe source is a live source. send a flush_stop
+         * FIXME: ideally we just forward flush event, but live sources don't
+         * send anything and we need a flush events to unlock the collect
+         * function
+         */
+        adder->flush_stop_pending =
+            ((flags & GST_SEEK_FLAG_FLUSH) == GST_SEEK_FLAG_FLUSH);
+      }
       break;
     }
+    case GST_EVENT_QOS:
+      /* QoS might be tricky */
+      result = FALSE;
+      break;
     case GST_EVENT_NAVIGATION:
       /* navigation is rather pointless. */
       result = FALSE;
       break;
     default:
       /* just forward the rest for now */
+      GST_DEBUG_OBJECT (adder, "forward unhandled event: %s",
+          GST_EVENT_TYPE_NAME (event));
       result = forward_event (adder, event);
       break;
   }
@@ -695,6 +728,7 @@
        * and downstream (using our source pad, the bastard!).
        */
       adder->segment_pending = TRUE;
+      adder->flush_stop_pending = FALSE;
       break;
     default:
       break;
@@ -969,9 +1003,22 @@
     event = gst_event_new_new_segment_full (FALSE, adder->segment_rate,
         1.0, GST_FORMAT_TIME, adder->timestamp, -1, adder->segment_position);
 
-    gst_pad_push_event (adder->srcpad, event);
-    adder->segment_pending = FALSE;
-    adder->segment_position = 0;
+    if (event) {
+      if (!gst_pad_push_event (adder->srcpad, event)) {
+        GST_WARNING_OBJECT (adder->srcpad, "Sending event  %p (%s) failed.",
+            event, GST_EVENT_TYPE_NAME (event));
+      }
+      adder->segment_pending = FALSE;
+      adder->segment_position = 0;
+    } else {
+      GST_WARNING_OBJECT (adder->srcpad, "Creating new segment event for "
+          "start:%" G_GINT64_FORMAT "  pos:%" G_GINT64_FORMAT " failed",
+          adder->timestamp, adder->segment_position);
+    }
+  }
+  if (adder->flush_stop_pending) {
+    gst_pad_push_event (adder->srcpad, gst_event_new_flush_stop ());
+    adder->flush_stop_pending = FALSE;
   }
 
   /* set timestamps on the output buffer */
@@ -997,6 +1044,8 @@
       GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (outbuf)));
   ret = gst_pad_push (adder->srcpad, outbuf);
 
+  GST_LOG_OBJECT (adder, "pushed outbuf, result = %s", gst_flow_get_name (ret));
+
   return ret;
 
   /* ERRORS */
diff -Naur gst/adder/gstadder.h gst/adder/gstadder.h
--- gst/adder/gstadder.h	2009-01-21 11:36:13.000000000 +0100
+++ gst/adder/gstadder.h	2009-05-19 18:44:45.000000000 +0200
@@ -87,6 +87,8 @@
   gboolean        segment_pending;
   guint64         segment_position;
   gdouble         segment_rate;
+  /* src event handling */
+  gboolean        flush_stop_pending;
 };
 
 struct _GstAdderClass {
diff -Naur gst/audioconvert/audioconvert.vcproj gst/audioconvert/audioconvert.vcproj
--- gst/audioconvert/audioconvert.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/audioconvert/audioconvert.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,154 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="audioconvert"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678A5}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;audioconvert_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudioconvert.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/audioconvert.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstaudioconvert.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;audioconvert_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudioconvert.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstaudioconvert.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstaudioconvert.c">
+			</File>
+			<File
+				RelativePath=".\bufferframesconvert.c">
+			</File>
+			<File
+				RelativePath=".\plugin.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\plugin.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/audioconvert/channelmixtest.c gst/audioconvert/channelmixtest.c
--- gst/audioconvert/channelmixtest.c	1970-01-01 01:00:00.000000000 +0100
+++ gst/audioconvert/channelmixtest.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,95 @@
+/* GStreamer
+ * Copyright (C) 2005 Benjamin Otte <otte@gnome.org>
+ *
+ * channelmixtest.c: simple test of channel mixing
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstchannelmix.h"
+#include "plugin.h"
+
+int
+main (gint argc, gchar ** argv)
+{
+  GstElement *bin, *src, *sink;
+  GstAudioConvert *c;
+  GstCaps *caps;
+  guint i, j, k;
+  struct
+  {
+    gchar *sinkcaps;
+    gchar *srccaps;
+    gfloat matrix[6][6];        /* use a predefined matrix here, makes stuff simpler */
+  } tests[] = {
+    /* stereo => mono */
+    {
+      "audio/x-raw-int, channels=2", "audio/x-raw-int, channels=1", { {
+      0.5,}, {
+    0.5,},}},
+        /* mono => stereo */
+    {
+      "audio/x-raw-int, channels=1", "audio/x-raw-int, channels=2", { {
+    1, 1,},}}
+  };
+
+  gst_init (&argc, &argv);
+
+  for (i = 0; i < G_N_ELEMENTS (tests); i++) {
+    g_print ("running test %u\n", i);
+    bin = gst_element_factory_make ("pipeline", NULL);
+    c = g_object_new (GST_TYPE_AUDIO_CONVERT, NULL);
+    /* avoid gst being braindead */
+    gst_object_set_name (GST_OBJECT (c), "shuddup");
+    src = gst_element_factory_make ("fakesrc", NULL);
+    sink = gst_element_factory_make ("fakesink", NULL);
+    gst_bin_add_many (GST_BIN (bin), src, c, sink, NULL);
+    caps = gst_caps_from_string (tests[i].sinkcaps);
+    g_assert (caps);
+    if (!gst_element_link_filtered (src, GST_ELEMENT (c), caps))
+      g_assert_not_reached ();
+    gst_caps_unref (caps);
+    caps = gst_caps_from_string (tests[i].srccaps);
+    g_assert (caps);
+    if (!gst_element_link_filtered (GST_ELEMENT (c), sink, caps))
+      g_assert_not_reached ();
+    gst_caps_unref (caps);
+    if (!gst_element_set_state (bin, GST_STATE_PLAYING))
+      g_assert_not_reached ();
+    g_assert (c->srccaps.channels <= 6);
+    g_assert (c->sinkcaps.channels <= 6);
+    for (j = 0; j < 6; j++) {
+      for (k = 0; k < 6; k++) {
+        if (j < c->sinkcaps.channels && k < c->srccaps.channels) {
+          if (tests[i].matrix[j][k] != c->matrix[j][k]) {
+            g_printerr ("matrix[j][k] should be %g but is %g\n",
+                tests[i].matrix[j][k], c->matrix[j][k]);
+            g_assert_not_reached ();
+          }
+        } else {
+          g_assert (tests[i].matrix[j][k] == 0);
+        }
+      }
+    }
+    gst_object_unref (bin);
+  }
+
+  return 0;
+}
diff -Naur gst/audiorate/audiorate.vcproj gst/audiorate/audiorate.vcproj
--- gst/audiorate/audiorate.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/audiorate/audiorate.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="audiorate"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678A6}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;audiorate_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudiorate.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/audiorate.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstaudiorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;audiorate_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudiorate.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstaudiorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstaudiorate.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/audioresample/gstaudioresample.c gst/audioresample/gstaudioresample.c
--- gst/audioresample/gstaudioresample.c	2009-05-06 14:42:51.000000000 +0200
+++ gst/audioresample/gstaudioresample.c	2009-05-19 18:44:45.000000000 +0200
@@ -778,6 +778,10 @@
   if (!resample->state)
     return;
 
+  /* Don't drain samples if we were resetted. */
+  if (resample->next_ts == -1)
+    return;
+
   need_convert = (resample->funcs->width != resample->width);
 
   resample->funcs->get_ratio (resample->state, &num, &den);
diff -Naur gst/audiotestsrc/gstaudiotestsrc.c gst/audiotestsrc/gstaudiotestsrc.c
--- gst/audiotestsrc/gstaudiotestsrc.c	2009-01-21 11:36:13.000000000 +0100
+++ gst/audiotestsrc/gstaudiotestsrc.c	2009-05-19 18:44:45.000000000 +0200
@@ -101,18 +101,18 @@
         "width = (int) 16, "
         "depth = (int) 16, "
         "rate = (int) [ 1, MAX ], "
-        "channels = (int) 1; "
+        "channels = (int) [ 1, 2 ]; "
         "audio/x-raw-int, "
         "endianness = (int) BYTE_ORDER, "
         "signed = (boolean) true, "
         "width = (int) 32, "
         "depth = (int) 32,"
         "rate = (int) [ 1, MAX ], "
-        "channels = (int) 1; "
+        "channels = (int) [ 1, 2 ]; "
         "audio/x-raw-float, "
         "endianness = (int) BYTE_ORDER, "
         "width = (int) { 32, 64 }, "
-        "rate = (int) [ 1, MAX ], " "channels = (int) 1")
+        "rate = (int) [ 1, MAX ], " "channels = (int) [ 1, 2 ]")
     );
 
 
@@ -132,7 +132,7 @@
     {GST_AUDIO_TEST_SRC_WAVE_SILENCE, "Silence", "silence"},
     {GST_AUDIO_TEST_SRC_WAVE_WHITE_NOISE, "White noise", "white-noise"},
     {GST_AUDIO_TEST_SRC_WAVE_PINK_NOISE, "Pink noise", "pink-noise"},
-    {GST_AUDIO_TEST_SRC_WAVE_SINE_TAB, "Sine table", "sine table"},
+    {GST_AUDIO_TEST_SRC_WAVE_SINE_TAB, "Sine table", "sine-table"},
     {GST_AUDIO_TEST_SRC_WAVE_TICKS, "Periodic Ticks", "ticks"},
     {0, NULL, NULL},
   };
@@ -286,6 +286,9 @@
     gst_structure_fixate_field_nearest_int (structure, "width", 32);
   else if (strcmp (name, "audio/x-raw-float") == 0)
     gst_structure_fixate_field_nearest_int (structure, "width", 64);
+
+  /* fixate to mono unless downstream requires stereo, for backwards compat */
+  gst_structure_fixate_field_nearest_int (structure, "channels", 1);
 }
 
 static gboolean
@@ -333,6 +336,9 @@
       break;
   }
 
+  ret &= gst_structure_get_int (structure, "channels", &src->channels);
+  GST_DEBUG_OBJECT (src, "negotiated to %d channels", src->channels);
+
   gst_audio_test_src_change_wave (src);
 
   return ret;
@@ -407,18 +413,21 @@
 static void \
 gst_audio_test_src_create_sine_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble step, amp; \
   \
   step = M_PI_M2 * src->freq / src->samplerate; \
   amp = src->volume * scale; \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
     src->accumulator += step; \
     if (src->accumulator >= M_PI_M2) \
       src->accumulator -= M_PI_M2; \
     \
-    samples[i] = (g##type) (sin (src->accumulator) * amp); \
+    for (c = 0; c < src->channels; ++c) { \
+      samples[i++] = (g##type) (sin (src->accumulator) * amp); \
+    } \
   } \
 }
 
@@ -438,18 +447,21 @@
 static void \
 gst_audio_test_src_create_square_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble step, amp; \
   \
   step = M_PI_M2 * src->freq / src->samplerate; \
   amp = src->volume * scale; \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
     src->accumulator += step; \
     if (src->accumulator >= M_PI_M2) \
       src->accumulator -= M_PI_M2; \
     \
-    samples[i] = (g##type) ((src->accumulator < M_PI) ? amp : -amp); \
+    for (c = 0; c < src->channels; ++c) { \
+      samples[i++] = (g##type) ((src->accumulator < M_PI) ? amp : -amp); \
+    } \
   } \
 }
 
@@ -469,21 +481,24 @@
 static void \
 gst_audio_test_src_create_saw_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble step, amp; \
   \
   step = M_PI_M2 * src->freq / src->samplerate; \
   amp = (src->volume * scale) / M_PI; \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
     src->accumulator += step; \
     if (src->accumulator >= M_PI_M2) \
       src->accumulator -= M_PI_M2; \
     \
     if (src->accumulator < M_PI) { \
-      samples[i] = (g##type) (src->accumulator * amp); \
+      for (c = 0; c < src->channels; ++c) \
+        samples[i++] = (g##type) (src->accumulator * amp); \
     } else { \
-      samples[i] = (g##type) ((M_PI_M2 - src->accumulator) * -amp); \
+      for (c = 0; c < src->channels; ++c) \
+        samples[i++] = (g##type) ((M_PI_M2 - src->accumulator) * -amp); \
     } \
   } \
 }
@@ -504,23 +519,27 @@
 static void \
 gst_audio_test_src_create_triangle_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble step, amp; \
   \
   step = M_PI_M2 * src->freq / src->samplerate; \
   amp = (src->volume * scale) / M_PI_2; \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
     src->accumulator += step; \
     if (src->accumulator >= M_PI_M2) \
       src->accumulator -= M_PI_M2; \
     \
     if (src->accumulator < (M_PI * 0.5)) { \
-      samples[i] = (g##type) (src->accumulator * amp); \
+      for (c = 0; c < src->channels; ++c) \
+        samples[i++] = (g##type) (src->accumulator * amp); \
     } else if (src->accumulator < (M_PI * 1.5)) { \
-      samples[i] = (g##type) ((src->accumulator - M_PI) * -amp); \
+      for (c = 0; c < src->channels; ++c) \
+        samples[i++] = (g##type) ((src->accumulator - M_PI) * -amp); \
     } else { \
-      samples[i] = (g##type) ((M_PI_M2 - src->accumulator) * -amp); \
+      for (c = 0; c < src->channels; ++c) \
+        samples[i++] = (g##type) ((M_PI_M2 - src->accumulator) * -amp); \
     } \
   } \
 }
@@ -541,7 +560,7 @@
 static void \
 gst_audio_test_src_create_silence_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  memset (samples, 0, src->generate_samples_per_buffer * sizeof (g##type)); \
+  memset (samples, 0, src->generate_samples_per_buffer * sizeof (g##type) * src->channels); \
 }
 
 DEFINE_SILENCE (int16);
@@ -560,11 +579,13 @@
 static void \
 gst_audio_test_src_create_white_noise_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble amp = (src->volume * scale); \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
-    samples[i] = (g##type) (amp * g_random_double_range (-1.0, 1.0)); \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
+    for (c = 0; c < src->channels; ++c) \
+      samples[i++] = (g##type) (amp * g_random_double_range (-1.0, 1.0)); \
   } \
 }
 
@@ -648,15 +669,18 @@
 static void \
 gst_audio_test_src_create_pink_noise_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble amp; \
   \
   amp = src->volume * scale; \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
-    samples[i] = \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
+    for (c = 0; c < src->channels; ++c) { \
+      samples[i++] = \
         (g##type) (gst_audio_test_src_generate_pink_noise_value (&src->pink) * \
         amp); \
+    } \
   } \
 }
 
@@ -690,18 +714,20 @@
 static void \
 gst_audio_test_src_create_sine_table_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble step, scl; \
   \
   step = M_PI_M2 * src->freq / src->samplerate; \
   scl = 1024.0 / M_PI_M2; \
   \
-  for (i = 0; i < src->generate_samples_per_buffer; i++) { \
+  i = 0; \
+  while (i < (src->generate_samples_per_buffer * src->channels)) { \
     src->accumulator += step; \
     if (src->accumulator >= M_PI_M2) \
       src->accumulator -= M_PI_M2; \
     \
-    samples[i] = (g##type) scale * src->wave_table[(gint) (src->accumulator * scl)]; \
+    for (c = 0; c < src->channels; ++c) \
+      samples[i++] = (g##type) scale * src->wave_table[(gint) (src->accumulator * scl)]; \
   } \
 }
 
@@ -721,7 +747,7 @@
 static void \
 gst_audio_test_src_create_tick_##type (GstAudioTestSrc * src, g##type * samples) \
 { \
-  gint i; \
+  gint i, c; \
   gdouble step, scl; \
   \
   step = M_PI_M2 * src->freq / src->samplerate; \
@@ -733,9 +759,11 @@
       src->accumulator -= M_PI_M2; \
     \
     if ((src->next_sample + i)%src->samplerate < 1600) { \
-      samples[i] = (g##type) scale * src->wave_table[(gint) (src->accumulator * scl)]; \
+      for (c = 0; c < src->channels; ++c) \
+        samples[(i * src->channels) + c] = (g##type) scale * src->wave_table[(gint) (src->accumulator * scl)]; \
     } else { \
-      samples[i] = 0; \
+      for (c = 0; c < src->channels; ++c) \
+        samples[(i * src->channels) + c] = 0; \
     } \
   } \
 }
@@ -863,7 +891,7 @@
 }
 
 /* seek to time, will be called when we operate in push mode. In pull mode we
- * get the requiested byte offset. */
+ * get the requested byte offset. */
 static gboolean
 gst_audio_test_src_do_seek (GstBaseSrc * basesrc, GstSegment * segment)
 {
@@ -876,7 +904,7 @@
   /* now move to the time indicated */
   src->next_sample =
       gst_util_uint64_scale_int (time, src->samplerate, GST_SECOND);
-  src->next_byte = src->next_sample * src->sample_size;
+  src->next_byte = src->next_sample * src->sample_size * src->channels;
   src->next_time =
       gst_util_uint64_scale_int (src->next_sample, GST_SECOND, src->samplerate);
 
@@ -949,7 +977,7 @@
   if (length == -1)
     samples = src->samples_per_buffer;
   else
-    samples = length / src->sample_size;
+    samples = length / (src->sample_size * src->channels);
 
   /* if no offset was given, use our next logical byte */
   if (offset == -1)
@@ -959,7 +987,7 @@
   if (offset != src->next_byte) {
     GST_DEBUG_OBJECT (src, "seek to new offset %" G_GUINT64_FORMAT, offset);
     /* we have a discont in the expected sample offset, do a 'seek' */
-    src->next_sample = src->next_byte / src->sample_size;
+    src->next_sample = offset / (src->sample_size * src->channels);
     src->next_time =
         gst_util_uint64_scale_int (src->next_sample, GST_SECOND,
         src->samplerate);
@@ -981,7 +1009,7 @@
     next_sample = src->next_sample + samples;
   }
 
-  bytes = src->generate_samples_per_buffer * src->sample_size;
+  bytes = src->generate_samples_per_buffer * src->sample_size * src->channels;
 
   if ((res = gst_pad_alloc_buffer (basesrc->srcpad, src->next_sample,
               bytes, GST_PAD_CAPS (basesrc->srcpad), &buf)) != GST_FLOW_OK) {
diff -Naur gst/audiotestsrc/gstaudiotestsrc.h gst/audiotestsrc/gstaudiotestsrc.h
--- gst/audiotestsrc/gstaudiotestsrc.h	2009-01-21 11:36:13.000000000 +0100
+++ gst/audiotestsrc/gstaudiotestsrc.h	2009-05-19 18:44:45.000000000 +0200
@@ -105,6 +105,7 @@
   gdouble freq;
     
   /* audio parameters */
+  gint channels;
   gint samplerate;
   gint samples_per_buffer;
   gint sample_size;
diff -Naur gst/ffmpegcolorspace/ffmpegcolorspace.vcproj gst/ffmpegcolorspace/ffmpegcolorspace.vcproj
--- gst/ffmpegcolorspace/ffmpegcolorspace.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/ffmpegcolorspace/ffmpegcolorspace.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,181 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="ffmpegcolorspace"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678B1}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;ffmpegcolorspace_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstffmpegcolorspace.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/ffmpegcolorspace.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstffmpegcolorspace.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;ffmpegcolorspace_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstffmpegcolorspace.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstffmpegcolorspace.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstffmpegcolorspace.c">
+			</File>
+			<File
+				RelativePath=".\gstffmpeg.c">
+			</File>
+			<File
+				RelativePath=".\gstffmpegcodecmap.c">
+			</File>
+			<File
+				RelativePath=".\dsputil.c">
+			</File>
+			<File
+				RelativePath=".\mem.c">
+			</File>
+			<File
+				RelativePath=".\utils.c">
+			</File>
+			<File
+				RelativePath=".\imgconvert.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\gstffmpegcodecmap.h">
+			</File>
+			<File
+				RelativePath=".\imgconvert_template.h">
+			</File>
+			<File
+				RelativePath=".\common.h">
+			</File>
+			<File
+				RelativePath=".\dsputil.h">
+			</File>
+			<File
+				RelativePath=".\mmx.h">
+			</File>
+			<File
+				RelativePath=".\avcodec.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/playback/gstdecodebin2.c gst/playback/gstdecodebin2.c
--- gst/playback/gstdecodebin2.c	2009-05-06 14:42:51.000000000 +0200
+++ gst/playback/gstdecodebin2.c	2009-05-19 18:44:45.000000000 +0200
@@ -655,7 +655,8 @@
 
   decode_bin->caps =
       gst_caps_from_string ("video/x-raw-yuv;video/x-raw-rgb;video/x-raw-gray;"
-      "audio/x-raw-int;audio/x-raw-float;" "text/plain;text/x-pango-markup");
+      "audio/x-raw-int;audio/x-raw-float;" "text/plain;text/x-pango-markup;"
+      "video/x-dvd-subpicture");
 }
 
 static void
@@ -748,14 +749,21 @@
 static void
 gst_decode_bin_set_caps (GstDecodeBin * dbin, GstCaps * caps)
 {
+  GstCaps *old;
+
   GST_DEBUG_OBJECT (dbin, "Setting new caps: %" GST_PTR_FORMAT, caps);
 
   GST_OBJECT_LOCK (dbin);
-  if (dbin->caps)
-    gst_caps_unref (dbin->caps);
-  if (caps)
-    gst_caps_ref (caps);
-  dbin->caps = caps;
+  old = dbin->caps;
+  if (old != caps) {
+    if (caps)
+      gst_caps_ref (caps);
+
+    dbin->caps = caps;
+
+    if (old)
+      gst_caps_unref (old);
+  }
   GST_OBJECT_UNLOCK (dbin);
 }
 
@@ -765,7 +773,6 @@
  *
  * MT-safe
  */
-
 static GstCaps *
 gst_decode_bin_get_caps (GstDecodeBin * dbin)
 {
diff -Naur gst/playback/gstdecodebin.c gst/playback/gstdecodebin.c
--- gst/playback/gstdecodebin.c	2009-01-21 11:36:13.000000000 +0100
+++ gst/playback/gstdecodebin.c	2009-05-19 18:44:45.000000000 +0200
@@ -1286,7 +1286,9 @@
 static void
 remove_element_chain (GstDecodeBin * decode_bin, GstPad * pad)
 {
-  GList *int_links, *walk;
+  GstIterator *iter;
+  gboolean done = FALSE;
+  gpointer item;
   GstElement *elem = GST_ELEMENT (GST_OBJECT_PARENT (pad));
 
   while (GST_OBJECT_PARENT (elem) &&
@@ -1300,69 +1302,86 @@
   }
 
   GST_DEBUG_OBJECT (decode_bin, "%s:%s", GST_DEBUG_PAD_NAME (pad));
-  int_links = gst_pad_get_internal_links (pad);
+  iter = gst_pad_iterate_internal_links (pad);
+  if (!iter)
+    goto no_iter;
 
   /* remove all elements linked to this pad up to the ghostpad
    * that we created for this stream */
-  for (walk = int_links; walk; walk = g_list_next (walk)) {
-    GstPad *pad;
-    GstPad *ghostpad;
-    GstPad *peer;
-
-    pad = GST_PAD (walk->data);
-    GST_DEBUG_OBJECT (decode_bin, "inspecting internal pad %s:%s",
-        GST_DEBUG_PAD_NAME (pad));
-
-    ghostpad = get_our_ghost_pad (decode_bin, pad);
-    if (ghostpad) {
-      GST_DEBUG_OBJECT (decode_bin, "found our ghost pad %s:%s for %s:%s",
-          GST_DEBUG_PAD_NAME (ghostpad), GST_DEBUG_PAD_NAME (pad));
-
-      g_signal_emit (G_OBJECT (decode_bin),
-          gst_decode_bin_signals[SIGNAL_REMOVED_DECODED_PAD], 0, ghostpad);
+  while (!done) {
+    switch (gst_iterator_next (iter, &item)) {
+      case GST_ITERATOR_OK:{
+        GstPad *pad;
+        GstPad *ghostpad;
+        GstPad *peer;
 
-      gst_element_remove_pad (GST_ELEMENT (decode_bin), ghostpad);
-      gst_object_unref (ghostpad);
-      continue;
-    } else {
-      GST_DEBUG_OBJECT (decode_bin, "not one of our ghostpads");
-    }
+        pad = GST_PAD (item);
+        GST_DEBUG_OBJECT (decode_bin, "inspecting internal pad %s:%s",
+            GST_DEBUG_PAD_NAME (pad));
 
-    peer = gst_pad_get_peer (pad);
-    if (peer == NULL)
-      continue;
+        ghostpad = get_our_ghost_pad (decode_bin, pad);
+        if (ghostpad) {
+          GST_DEBUG_OBJECT (decode_bin, "found our ghost pad %s:%s for %s:%s",
+              GST_DEBUG_PAD_NAME (ghostpad), GST_DEBUG_PAD_NAME (pad));
+
+          g_signal_emit (G_OBJECT (decode_bin),
+              gst_decode_bin_signals[SIGNAL_REMOVED_DECODED_PAD], 0, ghostpad);
+
+          gst_element_remove_pad (GST_ELEMENT (decode_bin), ghostpad);
+          gst_object_unref (ghostpad);
+          continue;
+        } else {
+          GST_DEBUG_OBJECT (decode_bin, "not one of our ghostpads");
+        }
 
-    GST_DEBUG_OBJECT (decode_bin, "internal pad %s:%s linked to pad %s:%s",
-        GST_DEBUG_PAD_NAME (pad), GST_DEBUG_PAD_NAME (peer));
+        peer = gst_pad_get_peer (pad);
+        if (peer) {
+          GstObject *parent = gst_pad_get_parent (peer);
 
-    {
-      GstObject *parent = gst_pad_get_parent (peer);
+          GST_DEBUG_OBJECT (decode_bin,
+              "internal pad %s:%s linked to pad %s:%s",
+              GST_DEBUG_PAD_NAME (pad), GST_DEBUG_PAD_NAME (peer));
 
-      if (parent) {
-        GstObject *grandparent = gst_object_get_parent (parent);
+          if (parent) {
+            GstObject *grandparent = gst_object_get_parent (parent);
 
-        if (grandparent != NULL) {
-          if (GST_ELEMENT (grandparent) != GST_ELEMENT (decode_bin)) {
-            GST_DEBUG_OBJECT (decode_bin, "dead end pad %s:%s parent %s",
-                GST_DEBUG_PAD_NAME (peer), GST_OBJECT_NAME (grandparent));
-          } else {
-            GST_DEBUG_OBJECT (decode_bin, "recursing element %s on pad %s:%s",
-                GST_ELEMENT_NAME (elem), GST_DEBUG_PAD_NAME (pad));
-            remove_element_chain (decode_bin, peer);
+            if (grandparent != NULL) {
+              if (GST_ELEMENT (grandparent) != GST_ELEMENT (decode_bin)) {
+                GST_DEBUG_OBJECT (decode_bin, "dead end pad %s:%s parent %s",
+                    GST_DEBUG_PAD_NAME (peer), GST_OBJECT_NAME (grandparent));
+              } else {
+                GST_DEBUG_OBJECT (decode_bin,
+                    "recursing element %s on pad %s:%s",
+                    GST_ELEMENT_NAME (elem), GST_DEBUG_PAD_NAME (pad));
+                remove_element_chain (decode_bin, peer);
+              }
+              gst_object_unref (grandparent);
+            }
+            gst_object_unref (parent);
           }
-          gst_object_unref (grandparent);
+          gst_object_unref (peer);
         }
-        gst_object_unref (parent);
+        gst_object_unref (item);
       }
+        break;
+      case GST_ITERATOR_RESYNC:
+        gst_iterator_resync (iter);
+        break;
+      case GST_ITERATOR_ERROR:
+        GST_ERROR_OBJECT (pad, "Could not iterate over internally linked pads");
+        done = TRUE;
+        break;
+      case GST_ITERATOR_DONE:
+        done = TRUE;
+        break;
     }
-    gst_object_unref (peer);
   }
   GST_DEBUG_OBJECT (decode_bin, "removing %s", GST_ELEMENT_NAME (elem));
 
-  g_list_free (int_links);
+  gst_iterator_free (iter);
 
+no_iter:
   gst_element_set_state (elem, GST_STATE_NULL);
-
   gst_bin_remove (GST_BIN (decode_bin), elem);
 }
 
diff -Naur gst/playback/gstplaybin2.c gst/playback/gstplaybin2.c
--- gst/playback/gstplaybin2.c	2009-04-15 21:18:28.000000000 +0200
+++ gst/playback/gstplaybin2.c	2009-05-19 18:44:45.000000000 +0200
@@ -286,6 +286,9 @@
   GPtrArray *text_channels;     /* links to selector pads */
   GPtrArray *subp_channels;     /* links to selector pads */
 
+  GstElement *audio_sink;       /* autoplugged audio and video sinks */
+  GstElement *video_sink;
+
   /* uridecodebins for uri and subtitle uri */
   GstElement *uridecodebin;
   GstElement *suburidecodebin;
@@ -419,6 +422,7 @@
 #define DEFAULT_VIDEO_SINK        NULL
 #define DEFAULT_VIS_PLUGIN        NULL
 #define DEFAULT_TEXT_SINK         NULL
+#define DEFAULT_SUBPIC_SINK       NULL
 #define DEFAULT_VOLUME            1.0
 #define DEFAULT_MUTE              FALSE
 #define DEFAULT_FRAME             NULL
@@ -445,6 +449,7 @@
   PROP_VIDEO_SINK,
   PROP_VIS_PLUGIN,
   PROP_TEXT_SINK,
+  PROP_SUBPIC_SINK,
   PROP_VOLUME,
   PROP_MUTE,
   PROP_FRAME,
@@ -704,6 +709,10 @@
       g_param_spec_object ("text-sink", "Text plugin",
           "the text output element to use (NULL = default textoverlay)",
           GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (gobject_klass, PROP_SUBPIC_SINK,
+      g_param_spec_object ("subpic-sink", "Subpicture plugin",
+          "the subpicture output element to use (NULL = default dvdspu)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (gobject_klass, PROP_VOLUME,
       g_param_spec_double ("volume", "Volume", "The audio volume",
@@ -983,6 +992,12 @@
   g_ptr_array_free (group->text_channels, TRUE);
   g_ptr_array_free (group->subp_channels, TRUE);
   g_mutex_free (group->lock);
+  if (group->audio_sink)
+    gst_object_unref (group->audio_sink);
+  group->audio_sink = NULL;
+  if (group->video_sink)
+    gst_object_unref (group->video_sink);
+  group->video_sink = NULL;
 }
 
 static void
@@ -1432,11 +1447,11 @@
       gst_play_bin_set_encoding (playbin, g_value_get_string (value));
       break;
     case PROP_VIDEO_SINK:
-      gst_play_sink_set_video_sink (playbin->playsink,
+      gst_play_sink_set_sink (playbin->playsink, GST_PLAY_SINK_TYPE_VIDEO,
           g_value_get_object (value));
       break;
     case PROP_AUDIO_SINK:
-      gst_play_sink_set_audio_sink (playbin->playsink,
+      gst_play_sink_set_sink (playbin->playsink, GST_PLAY_SINK_TYPE_AUDIO,
           g_value_get_object (value));
       break;
     case PROP_VIS_PLUGIN:
@@ -1444,7 +1459,11 @@
           g_value_get_object (value));
       break;
     case PROP_TEXT_SINK:
-      gst_play_sink_set_text_sink (playbin->playsink,
+      gst_play_sink_set_sink (playbin->playsink, GST_PLAY_SINK_TYPE_TEXT,
+          g_value_get_object (value));
+      break;
+    case PROP_SUBPIC_SINK:
+      gst_play_sink_set_sink (playbin->playsink, GST_PLAY_SINK_TYPE_SUBPIC,
           g_value_get_object (value));
       break;
     case PROP_VOLUME:
@@ -1571,11 +1590,11 @@
       break;
     case PROP_VIDEO_SINK:
       g_value_set_object (value,
-          gst_play_sink_get_video_sink (playbin->playsink));
+          gst_play_sink_get_sink (playbin->playsink, GST_PLAY_SINK_TYPE_VIDEO));
       break;
     case PROP_AUDIO_SINK:
       g_value_set_object (value,
-          gst_play_sink_get_audio_sink (playbin->playsink));
+          gst_play_sink_get_sink (playbin->playsink, GST_PLAY_SINK_TYPE_AUDIO));
       break;
     case PROP_VIS_PLUGIN:
       g_value_set_object (value,
@@ -1583,7 +1602,12 @@
       break;
     case PROP_TEXT_SINK:
       g_value_set_object (value,
-          gst_play_sink_get_text_sink (playbin->playsink));
+          gst_play_sink_get_sink (playbin->playsink, GST_PLAY_SINK_TYPE_TEXT));
+      break;
+    case PROP_SUBPIC_SINK:
+      g_value_set_object (value,
+          gst_play_sink_get_sink (playbin->playsink,
+              GST_PLAY_SINK_TYPE_SUBPIC));
       break;
     case PROP_VOLUME:
       g_value_set_double (value, gst_play_sink_get_volume (playbin->playsink));
@@ -1986,6 +2010,16 @@
   GST_SOURCE_GROUP_UNLOCK (group);
 
   if (configure) {
+    /* if we have custom sinks, configure them now */
+    GST_SOURCE_GROUP_LOCK (group);
+    GST_LOG_OBJECT (playbin, "setting custom audio sink %p", group->audio_sink);
+    gst_play_sink_set_sink (playbin->playsink, GST_PLAY_SINK_TYPE_AUDIO,
+        group->audio_sink);
+    GST_LOG_OBJECT (playbin, "setting custom video sink %p", group->video_sink);
+    gst_play_sink_set_sink (playbin->playsink, GST_PLAY_SINK_TYPE_VIDEO,
+        group->video_sink);
+    GST_SOURCE_GROUP_UNLOCK (group);
+
     GST_LOG_OBJECT (playbin, "reconfigure sink");
     /* we configure the modes if we were the last decodebin to complete. */
     gst_play_sink_reconfigure (playbin->playsink);
@@ -2095,6 +2129,8 @@
   GstPlayBin *playbin;
   GstElement *element;
   const gchar *klass;
+  GstPlaySinkType type;
+  GstElement **sinkp;
 
   playbin = group->playbin;
 
@@ -2113,15 +2149,42 @@
 
   klass = gst_element_factory_get_klass (factory);
 
+  /* figure out the klass */
+  if (strstr (klass, "Audio")) {
+    GST_DEBUG_OBJECT (playbin, "we found an audio sink");
+    type = GST_PLAY_SINK_TYPE_AUDIO;
+    sinkp = &group->audio_sink;
+  } else if (strstr (klass, "Video")) {
+    GST_DEBUG_OBJECT (playbin, "we found a video sink");
+    type = GST_PLAY_SINK_TYPE_VIDEO;
+    sinkp = &group->video_sink;
+  } else {
+    /* unknown klass, skip this element */
+    GST_WARNING_OBJECT (playbin, "unknown sink klass %s found", klass);
+    return GST_AUTOPLUG_SELECT_SKIP;
+  }
+
   /* if we are asked to do visualisations and it's an audio sink, skip the
    * element. We can only do visualisations with raw sinks */
   if (gst_play_sink_get_flags (playbin->playsink) & GST_PLAY_FLAG_VIS) {
-    if (strstr (klass, "Audio")) {
+    if (type == GST_PLAY_SINK_TYPE_AUDIO) {
       GST_DEBUG_OBJECT (playbin, "skip audio sink because of vis");
       return GST_AUTOPLUG_SELECT_SKIP;
     }
   }
 
+  /* now see if we already have a sink element */
+  GST_SOURCE_GROUP_LOCK (group);
+  if (*sinkp) {
+    GST_DEBUG_OBJECT (playbin, "we already have a pending sink, expose pad");
+    /* for now, just assume that we can link the pad to this same sink. FIXME,
+     * check that we can link this new pad to this sink as well. */
+    GST_SOURCE_GROUP_UNLOCK (group);
+    return GST_AUTOPLUG_SELECT_EXPOSE;
+  }
+  GST_DEBUG_OBJECT (playbin, "we have no pending sink, try to create one");
+  GST_SOURCE_GROUP_UNLOCK (group);
+
   if ((element = gst_element_factory_create (factory, NULL)) == NULL) {
     GST_WARNING_OBJECT (playbin, "Could not create an element from %s",
         gst_plugin_feature_get_name (GST_PLUGIN_FEATURE (factory)));
@@ -2139,18 +2202,24 @@
     return GST_AUTOPLUG_SELECT_SKIP;
   }
 
-  /* get klass to figure out if it's audio or video */
-  if (strstr (klass, "Audio")) {
-    GST_DEBUG_OBJECT (playbin, "configure audio sink");
-    gst_play_sink_set_audio_sink (playbin->playsink, element);
-    g_object_notify (G_OBJECT (playbin), "audio-sink");
-  } else if (strstr (klass, "Video")) {
-    GST_DEBUG_OBJECT (playbin, "configure video sink");
-    gst_play_sink_set_video_sink (playbin->playsink, element);
-    g_object_notify (G_OBJECT (playbin), "video-sink");
+  /* remember the sink in the group now, the element is floating, we take
+   * ownership now */
+  GST_SOURCE_GROUP_LOCK (group);
+  if (*sinkp == NULL) {
+    /* store the sink in the group, we will configure it later when we
+     * reconfigure the sink */
+    GST_DEBUG_OBJECT (playbin, "remember sink");
+    gst_object_ref (element);
+    gst_object_sink (element);
+    *sinkp = element;
   } else {
-    GST_WARNING_OBJECT (playbin, "unknown sink klass %s found", klass);
+    /* some other thread configured a sink while we were testing the sink, set
+     * the sink back to NULL and assume we can use the other sink */
+    GST_DEBUG_OBJECT (playbin, "another sink was found, expose pad");
+    gst_element_set_state (element, GST_STATE_NULL);
+    gst_object_unref (element);
   }
+  GST_SOURCE_GROUP_UNLOCK (group);
 
   /* tell decodebin to expose the pad because we are going to use this
    * sink */
@@ -2389,6 +2458,13 @@
       select->selector = NULL;
     }
   }
+  /* delete any custom sinks we might have */
+  if (group->audio_sink)
+    gst_object_unref (group->audio_sink);
+  group->audio_sink = NULL;
+  if (group->video_sink)
+    gst_object_unref (group->video_sink);
+  group->video_sink = NULL;
   /* we still have the decodebins added to the playbin2 but we can't remove them
    * yet or change their state because this function might be called from the
    * streaming threads, instead block the state so that state changes on the
diff -Naur gst/playback/gstplaysink.c gst/playback/gstplaysink.c
--- gst/playback/gstplaysink.c	2009-05-08 21:17:01.000000000 +0200
+++ gst/playback/gstplaysink.c	2009-05-19 18:44:45.000000000 +0200
@@ -123,6 +123,7 @@
   GMutex *lock;
 
   gboolean async_pending;
+  gboolean need_async_start;
 
   GstPlayFlags flags;
 
@@ -243,6 +244,7 @@
   playsink->flags = GST_PLAY_FLAG_SOFT_VOLUME;
 
   playsink->lock = g_mutex_new ();
+  playsink->need_async_start = TRUE;
 }
 
 static void
@@ -330,70 +332,94 @@
 }
 
 void
-gst_play_sink_set_video_sink (GstPlaySink * playsink, GstElement * sink)
+gst_play_sink_set_sink (GstPlaySink * playsink, GstPlaySinkType type,
+    GstElement * sink)
 {
-  GST_PLAY_SINK_LOCK (playsink);
-  if (playsink->video_sink)
-    gst_object_unref (playsink->video_sink);
-
-  if (sink) {
-    gst_object_ref (sink);
-    gst_object_sink (sink);
-  }
-  playsink->video_sink = sink;
-  GST_PLAY_SINK_UNLOCK (playsink);
-}
-
-GstElement *
-gst_play_sink_get_video_sink (GstPlaySink * playsink)
-{
-  GstElement *result = NULL;
-  GstPlayVideoChain *chain;
+  GstElement **elem = NULL, *old = NULL;
 
   GST_PLAY_SINK_LOCK (playsink);
-  if ((chain = (GstPlayVideoChain *) playsink->videochain)) {
-    /* we have an active chain, get the sink */
-    if (chain->sink)
-      result = gst_object_ref (chain->sink);
+  switch (type) {
+    case GST_PLAY_SINK_TYPE_AUDIO:
+    case GST_PLAY_SINK_TYPE_AUDIO_RAW:
+      elem = &playsink->audio_sink;
+      break;
+    case GST_PLAY_SINK_TYPE_VIDEO:
+    case GST_PLAY_SINK_TYPE_VIDEO_RAW:
+      elem = &playsink->video_sink;
+      break;
+    case GST_PLAY_SINK_TYPE_TEXT:
+      elem = &playsink->text_sink;
+      break;
+    case GST_PLAY_SINK_TYPE_SUBPIC:
+      elem = &playsink->subp_sink;
+      break;
+    default:
+      break;
   }
-  /* nothing found, return last configured sink */
-  if (result == NULL && playsink->video_sink)
-    result = gst_object_ref (playsink->video_sink);
-  GST_PLAY_SINK_UNLOCK (playsink);
-
-  return result;
-}
-
-void
-gst_play_sink_set_audio_sink (GstPlaySink * playsink, GstElement * sink)
-{
-  GST_PLAY_SINK_LOCK (playsink);
-  if (playsink->audio_sink)
-    gst_object_unref (playsink->audio_sink);
-
-  if (sink) {
-    gst_object_ref (sink);
-    gst_object_sink (sink);
+  if (elem) {
+    old = *elem;
+    if (sink) {
+      gst_object_ref (sink);
+      gst_object_sink (sink);
+    }
+    *elem = sink;
   }
-  playsink->audio_sink = sink;
   GST_PLAY_SINK_UNLOCK (playsink);
+
+  if (old)
+    gst_object_unref (old);
 }
 
 GstElement *
-gst_play_sink_get_audio_sink (GstPlaySink * playsink)
+gst_play_sink_get_sink (GstPlaySink * playsink, GstPlaySinkType type)
 {
   GstElement *result = NULL;
-  GstPlayAudioChain *chain;
+  GstElement *elem = NULL, *chainp = NULL;
 
   GST_PLAY_SINK_LOCK (playsink);
-  if ((chain = (GstPlayAudioChain *) playsink->audiochain)) {
-    /* we have an active chain, get the sink */
-    if (chain->sink)
-      result = gst_object_ref (chain->sink);
+  switch (type) {
+    case GST_PLAY_SINK_TYPE_AUDIO:
+    {
+      GstPlayAudioChain *chain;
+      if ((chain = (GstPlayAudioChain *) playsink->audiochain))
+        chainp = chain->sink;
+      elem = playsink->audio_sink;
+      break;
+    }
+    case GST_PLAY_SINK_TYPE_VIDEO:
+    {
+      GstPlayVideoChain *chain;
+      if ((chain = (GstPlayVideoChain *) playsink->videochain))
+        chainp = chain->sink;
+      elem = playsink->video_sink;
+      break;
+    }
+    case GST_PLAY_SINK_TYPE_TEXT:
+    {
+      GstPlayTextChain *chain;
+      if ((chain = (GstPlayTextChain *) playsink->textchain))
+        chainp = chain->sink;
+      elem = playsink->text_sink;
+      break;
+    }
+    case GST_PLAY_SINK_TYPE_SUBPIC:
+    {
+      GstPlaySubpChain *chain;
+      if ((chain = (GstPlaySubpChain *) playsink->subpchain))
+        chainp = chain->sink;
+      elem = playsink->subp_sink;
+      break;
+    }
+    default:
+      break;
+  }
+  if (chainp) {
+    /* we have an active chain with a sink, get the sink */
+    result = gst_object_ref (chainp);
   }
   /* nothing found, return last configured sink */
-  if (result == NULL && playsink->audio_sink)
-    result = gst_object_ref (playsink->audio_sink);
+  if (result == NULL && elem)
+    result = gst_object_ref (elem);
   GST_PLAY_SINK_UNLOCK (playsink);
 
   return result;
@@ -519,76 +545,6 @@
 }
 
 void
-gst_play_sink_set_text_sink (GstPlaySink * playsink, GstElement * sink)
-{
-  GST_PLAY_SINK_LOCK (playsink);
-  if (playsink->text_sink)
-    gst_object_unref (playsink->text_sink);
-
-  if (sink) {
-    gst_object_ref (sink);
-    gst_object_sink (sink);
-  }
-  playsink->text_sink = sink;
-  GST_PLAY_SINK_UNLOCK (playsink);
-}
-
-GstElement *
-gst_play_sink_get_text_sink (GstPlaySink * playsink)
-{
-  GstElement *result = NULL;
-  GstPlayTextChain *chain;
-
-  GST_PLAY_SINK_LOCK (playsink);
-  if ((chain = (GstPlayTextChain *) playsink->textchain)) {
-    /* we have an active chain, get the sink */
-    if (chain->sink)
-      result = gst_object_ref (chain->sink);
-  }
-  /* nothing found, return last configured sink */
-  if (result == NULL && playsink->text_sink)
-    result = gst_object_ref (playsink->text_sink);
-  GST_PLAY_SINK_UNLOCK (playsink);
-
-  return result;
-}
-
-void
-gst_play_sink_set_subp_sink (GstPlaySink * playsink, GstElement * sink)
-{
-  GST_PLAY_SINK_LOCK (playsink);
-  if (playsink->subp_sink)
-    gst_object_unref (playsink->subp_sink);
-
-  if (sink) {
-    gst_object_ref (sink);
-    gst_object_sink (sink);
-  }
-  playsink->subp_sink = sink;
-  GST_PLAY_SINK_UNLOCK (playsink);
-}
-
-GstElement *
-gst_play_sink_get_subp_sink (GstPlaySink * playsink)
-{
-  GstElement *result = NULL;
-  GstPlaySubpChain *chain;
-
-  GST_PLAY_SINK_LOCK (playsink);
-  if ((chain = (GstPlaySubpChain *) playsink->subpchain)) {
-    /* we have an active chain, get the sink */
-    if (chain->sink)
-      result = gst_object_ref (chain->sink);
-  }
-  /* nothing found, return last configured sink */
-  if (result == NULL && playsink->subp_sink)
-    result = gst_object_ref (playsink->subp_sink);
-  GST_PLAY_SINK_UNLOCK (playsink);
-
-  return result;
-}
-
-void
 gst_play_sink_set_volume (GstPlaySink * playsink, gdouble volume)
 {
   GstPlayAudioChain *chain;
@@ -801,8 +757,12 @@
 {
   GstMessage *message;
 
+  if (!playsink->need_async_start)
+    return;
+
   playsink->async_pending = TRUE;
 
+  GST_INFO_OBJECT (playsink, "Sending async_start message");
   message = gst_message_new_async_start (GST_OBJECT_CAST (playsink), FALSE);
   GST_BIN_CLASS (gst_play_sink_parent_class)->handle_message (GST_BIN_CAST
       (playsink), message);
@@ -814,12 +774,15 @@
   GstMessage *message;
 
   if (playsink->async_pending) {
+    GST_INFO_OBJECT (playsink, "Sending async_done message");
     message = gst_message_new_async_done (GST_OBJECT_CAST (playsink));
     GST_BIN_CLASS (gst_play_sink_parent_class)->handle_message (GST_BIN_CAST
         (playsink), message);
 
     playsink->async_pending = FALSE;
   }
+
+  playsink->need_async_start = FALSE;
 }
 
 /* try to change the state of an element. This function returns the element when
@@ -1164,6 +1127,8 @@
      * overlay. the only thing we can do is insert an identity and ghost the src
      * and sink pads. */
     chain->conv = gst_element_factory_make ("identity", "tidentity");
+    g_object_set (chain->conv, "signal-handoffs", FALSE, NULL);
+    g_object_set (chain->conv, "silent", TRUE, NULL);
     gst_bin_add (bin, chain->conv);
     srcpad = gst_element_get_static_pad (chain->conv, "src");
     videosinkpad = gst_element_get_static_pad (chain->conv, "sink");
@@ -1810,8 +1775,8 @@
           playsink->audio_tee_vissrc = NULL;
         }
         srcpad =
-            gst_element_get_static_pad (GST_ELEMENT_CAST (playsink->
-                vischain->chain.bin), "src");
+            gst_element_get_static_pad (GST_ELEMENT_CAST (playsink->vischain->
+                chain.bin), "src");
         gst_pad_unlink (srcpad, playsink->videochain->sinkpad);
       }
       add_chain (GST_PLAY_CHAIN (playsink->videochain), FALSE);
@@ -1976,8 +1941,8 @@
     if (playsink->vischain) {
       GST_DEBUG_OBJECT (playsink, "setting up vis chain");
       srcpad =
-          gst_element_get_static_pad (GST_ELEMENT_CAST (playsink->
-              vischain->chain.bin), "src");
+          gst_element_get_static_pad (GST_ELEMENT_CAST (playsink->vischain->
+              chain.bin), "src");
       add_chain (GST_PLAY_CHAIN (playsink->vischain), TRUE);
       activate_chain (GST_PLAY_CHAIN (playsink->vischain), TRUE);
       if (playsink->audio_tee_vissrc == NULL) {
@@ -2396,6 +2361,7 @@
       break;
     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
       /* FIXME Release audio device when we implement that */
+      playsink->need_async_start = TRUE;
       break;
     case GST_STATE_CHANGE_PAUSED_TO_READY:
       /* remove sinks we added */
@@ -2415,12 +2381,15 @@
         activate_chain (GST_PLAY_CHAIN (playsink->textchain), FALSE);
         add_chain (GST_PLAY_CHAIN (playsink->textchain), FALSE);
       }
+      if (playsink->subpchain) {
+        activate_chain (GST_PLAY_CHAIN (playsink->subpchain), FALSE);
+        add_chain (GST_PLAY_CHAIN (playsink->subpchain), FALSE);
+      }
       do_async_done (playsink);
       break;
     default:
       break;
   }
-
   return ret;
 
   /* ERRORS */
diff -Naur gst/playback/gstplaysink.h gst/playback/gstplaysink.h
--- gst/playback/gstplaysink.h	2009-04-01 13:49:11.000000000 +0200
+++ gst/playback/gstplaysink.h	2009-05-19 18:44:45.000000000 +0200
@@ -36,6 +36,8 @@
   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLAY_SINK))
 #define GST_IS_PLAY_SINK_CLASS(klass) \
   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PLAY_SINK))
+#define GST_PLAY_SINK_CAST(obj) \
+  ((GstPlaySink*)(obj))
 
 /**
  * GstPlaySinkType:
@@ -70,21 +72,12 @@
 GstPad *         gst_play_sink_request_pad    (GstPlaySink *playsink, GstPlaySinkType type);
 void             gst_play_sink_release_pad    (GstPlaySink *playsink, GstPad *pad);
 
-void             gst_play_sink_set_video_sink (GstPlaySink * playsink, GstElement * sink);
-GstElement *     gst_play_sink_get_video_sink (GstPlaySink * playsink);
-
-void             gst_play_sink_set_audio_sink (GstPlaySink * playsink, GstElement * sink);
-GstElement *     gst_play_sink_get_audio_sink (GstPlaySink * playsink);
+void             gst_play_sink_set_sink       (GstPlaySink * playsink, GstPlaySinkType type, GstElement * sink);
+GstElement *     gst_play_sink_get_sink       (GstPlaySink * playsink, GstPlaySinkType type);
 
 void             gst_play_sink_set_vis_plugin (GstPlaySink * playsink, GstElement * vis);
 GstElement *     gst_play_sink_get_vis_plugin (GstPlaySink * playsink);
 
-void             gst_play_sink_set_text_sink  (GstPlaySink * playsink, GstElement * sink);
-GstElement *     gst_play_sink_get_text_sink  (GstPlaySink * playsink);
-
-void             gst_play_sink_set_subp_sink  (GstPlaySink * playsink, GstElement * sink);
-GstElement *     gst_play_sink_get_subp_sink  (GstPlaySink * playsink);
-
 void             gst_play_sink_set_volume     (GstPlaySink *playsink, gdouble volume);
 gdouble          gst_play_sink_get_volume     (GstPlaySink *playsink);
 
diff -Naur gst/playback/gsturidecodebin.c gst/playback/gsturidecodebin.c
--- gst/playback/gsturidecodebin.c	2009-04-01 13:49:11.000000000 +0200
+++ gst/playback/gsturidecodebin.c	2009-05-19 18:44:45.000000000 +0200
@@ -74,6 +74,7 @@
   gchar *encoding;
 
   gboolean is_stream;
+  gboolean need_queue;
   guint64 buffer_duration;      /* When streaming, buffer duration (ns) */
   guint buffer_size;            /* When streaming, buffer size (bytes) */
 
@@ -452,10 +453,10 @@
   g_mutex_free (dec->lock);
   g_free (dec->uri);
   g_free (dec->encoding);
-  if (dec->factories) {
+  if (dec->factories)
     g_value_array_free (dec->factories);
-    dec->factories = NULL;
-  }
+  if (dec->caps)
+    gst_caps_unref (dec->caps);
 
   G_OBJECT_CLASS (parent_class)->finalize (obj);
 }
@@ -756,6 +757,9 @@
   "mmsu://", "mmst://", NULL
 };
 
+/* list of URIs that need a queue because they are pretty bursty */
+static const gchar *queue_uris[] = { "cdda://", NULL };
+
 /* blacklisted URIs, we know they will always fail. */
 static const gchar *blacklisted_uris[] = { NULL };
 
@@ -774,6 +778,7 @@
 };
 
 #define IS_STREAM_URI(uri)          (array_has_value (stream_uris, uri))
+#define IS_QUEUE_URI(uri)           (array_has_value (queue_uris, uri))
 #define IS_BLACKLISTED_URI(uri)     (array_has_value (blacklisted_uris, uri))
 #define IS_NO_MEDIA_MIME(mime)      (array_has_value (no_media_mimes, mime))
 #define IS_RAW_MEDIA(media)         (array_has_value (raw_media, media))
@@ -804,9 +809,11 @@
   GST_LOG_OBJECT (decoder, "found source type %s", G_OBJECT_TYPE_NAME (source));
 
   decoder->is_stream = IS_STREAM_URI (decoder->uri);
-
   GST_LOG_OBJECT (decoder, "source is stream: %d", decoder->is_stream);
 
+  decoder->need_queue = IS_QUEUE_URI (decoder->uri);
+  GST_LOG_OBJECT (decoder, "source needs queue: %d", decoder->need_queue);
+
   /* make HTTP sources send extra headers so we get icecast
    * metadata in case the stream is an icecast stream */
   if (!strncmp (decoder->uri, "http://", 7) &&
@@ -926,6 +933,7 @@
  * @is_raw: are all pads raw data
  * @have_out: does the source have output
  * @is_dynamic: is this a dynamic source
+ * @use_queue: put a queue before raw output pads
  *
  * Check the source of @decoder and collect information about it.
  *
@@ -942,7 +950,7 @@
  */
 static gboolean
 analyse_source (GstURIDecodeBin * decoder, gboolean * is_raw,
-    gboolean * have_out, gboolean * is_dynamic)
+    gboolean * have_out, gboolean * is_dynamic, gboolean use_queue)
 {
   GstIterator *pads_iter;
   gboolean done = FALSE;
@@ -981,8 +989,28 @@
         }
 
         /* caps on source pad are all raw, we can add the pad */
-        if (*is_raw)
-          new_decoded_pad_cb (decoder->source, pad, FALSE, decoder);
+        if (*is_raw) {
+          GstElement *outelem;
+
+          if (use_queue) {
+            GstPad *sinkpad;
+
+            /* insert a queue element right before the raw pad */
+            outelem = gst_element_factory_make ("queue2", "queue");
+            gst_bin_add (GST_BIN_CAST (decoder), outelem);
+
+            sinkpad = gst_element_get_static_pad (outelem, "sink");
+            gst_pad_link (pad, sinkpad);
+            gst_object_unref (sinkpad);
+            gst_object_unref (pad);
+
+            /* get the new raw srcpad */
+            pad = gst_element_get_static_pad (outelem, "src");
+          } else {
+            outelem = decoder->source;
+          }
+          new_decoded_pad_cb (outelem, pad, FALSE, decoder);
+        }
         gst_object_unref (pad);
         break;
     }
@@ -1123,6 +1151,10 @@
   if (!decodebin)
     goto no_decodebin;
 
+  /* configure caps if we have any */
+  if (decoder->caps)
+    g_object_set (decodebin, "caps", decoder->caps, NULL);
+
   /* connect signals to proxy */
   g_signal_connect (G_OBJECT (decodebin), "unknown-type",
       G_CALLBACK (proxy_unknown_type_signal), decoder);
@@ -1384,7 +1416,8 @@
    * if so, we can create streams for the pads and be done with it.
    * Also check that is has source pads, if not, we assume it will
    * do everything itself.  */
-  if (!analyse_source (decoder, &is_raw, &have_out, &is_dynamic))
+  if (!analyse_source (decoder, &is_raw, &have_out, &is_dynamic,
+          decoder->need_queue))
     goto invalid_source;
 
   if (is_raw) {
diff -Naur gst/tcp/gstmultifdsink.c gst/tcp/gstmultifdsink.c
--- gst/tcp/gstmultifdsink.c	2009-05-07 23:17:08.000000000 +0200
+++ gst/tcp/gstmultifdsink.c	2009-05-19 18:44:45.000000000 +0200
@@ -218,6 +218,8 @@
 
   PROP_RESEND_STREAMHEADER,
 
+  PROP_NUM_FDS,
+
   PROP_LAST
 };
 
@@ -520,6 +522,11 @@
           DEFAULT_RESEND_STREAMHEADER,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  g_object_class_install_property (gobject_class, PROP_NUM_FDS,
+      g_param_spec_uint ("num-fds", "Number of fds",
+          "The current number of client file descriptors.",
+          0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstMultiFdSink::add:
    * @gstmultifdsink: the multifdsink element to emit this signal on
@@ -2798,6 +2805,9 @@
     case PROP_RESEND_STREAMHEADER:
       g_value_set_boolean (value, multifdsink->resend_streamheader);
       break;
+    case PROP_NUM_FDS:
+      g_value_set_uint (value, g_hash_table_size (multifdsink->fd_hash));
+      break;
 
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
diff -Naur gst/tcp/tcp.vcproj gst/tcp/tcp.vcproj
--- gst/tcp/tcp.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/tcp/tcp.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="avi"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678D1}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;AVI_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstavi.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/avi.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstavi.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;AVI_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstavi.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstavi.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstavi.c">
+			</File>
+			<File
+				RelativePath=".\gstavidemux.c">
+			</File>
+			<File
+				RelativePath=".\gstavimux.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\avi-ids.h">
+			</File>
+			<File
+				RelativePath=".\gstavidemux.h">
+			</File>
+			<File
+				RelativePath=".\gstavimux.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/typefind/gsttypefindfunctions.c gst/typefind/gsttypefindfunctions.c
--- gst/typefind/gsttypefindfunctions.c	2009-04-01 13:49:11.000000000 +0200
+++ gst/typefind/gsttypefindfunctions.c	2009-05-19 18:44:45.000000000 +0200
@@ -931,6 +931,10 @@
         offset += length;
       }
       g_assert (found <= GST_MP3_TYPEFIND_TRY_HEADERS);
+      if (head_data == NULL &&
+          gst_type_find_peek (tf, offset + start_off - 1, 1) == NULL)
+        /* Incomplete last frame - don't count it. */
+        found--;
       if (found == GST_MP3_TYPEFIND_TRY_HEADERS ||
           (found >= GST_MP3_TYPEFIND_MIN_HEADERS && head_data == NULL)) {
         /* we can make a valid guess */
diff -Naur gst/typefind/typefindfunctions.vcproj gst/typefind/typefindfunctions.vcproj
--- gst/typefind/typefindfunctions.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/typefind/typefindfunctions.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="typefindfunctions"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678D2}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;typefindfunctions_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gsttypefindfunctions.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/typefindfunctions.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gsttypefindfunctions.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;typefindfunctions_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gsttypefindfunctions.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gsttypefindfunctions.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gsttypefindfunctions.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/videorate/gstvideorate.c gst/videorate/gstvideorate.c
--- gst/videorate/gstvideorate.c	2009-05-06 14:42:51.000000000 +0200
+++ gst/videorate/gstvideorate.c	2009-05-19 18:44:45.000000000 +0200
@@ -268,6 +268,7 @@
     videorate->from_rate_denominator = rate_denominator;
     otherpad = videorate->srcpad;
   }
+
   /* now try to find something for the peer */
   opeer = gst_pad_get_peer (otherpad);
   if (opeer) {
@@ -358,6 +359,7 @@
   videorate->drop = 0;
   videorate->dup = 0;
   videorate->next_ts = GST_CLOCK_TIME_NONE;
+  videorate->last_ts = GST_CLOCK_TIME_NONE;
   videorate->discont = TRUE;
   gst_video_rate_swap_prev (videorate, NULL, 0);
 
@@ -584,11 +586,17 @@
               GST_TIME_FORMAT " max %" GST_TIME_FORMAT,
               GST_TIME_ARGS (min), GST_TIME_ARGS (max));
 
-          /* add latency. We don't really know since we hold on to the frames
-           * until we get a next frame, which can be anything. We assume
-           * however that this will take from_rate time. */
-          latency = gst_util_uint64_scale (GST_SECOND,
-              videorate->from_rate_denominator, videorate->from_rate_numerator);
+          if (videorate->from_rate_numerator != 0) {
+            /* add latency. We don't really know since we hold on to the frames
+             * until we get a next frame, which can be anything. We assume
+             * however that this will take from_rate time. */
+            latency = gst_util_uint64_scale (GST_SECOND,
+                videorate->from_rate_denominator,
+                videorate->from_rate_numerator);
+          } else {
+            /* no input framerate, we don't know */
+            latency = 0;
+          }
 
           GST_DEBUG_OBJECT (videorate, "Our latency: %"
               GST_TIME_FORMAT, GST_TIME_ARGS (latency));
@@ -621,7 +629,7 @@
 {
   GstVideoRate *videorate;
   GstFlowReturn res = GST_FLOW_OK;
-  GstClockTime intime, in_ts;
+  GstClockTime intime, in_ts, in_dur;
 
   videorate = GST_VIDEO_RATE (GST_PAD_PARENT (pad));
 
@@ -631,9 +639,19 @@
     goto not_negotiated;
 
   in_ts = GST_BUFFER_TIMESTAMP (buffer);
+  in_dur = GST_BUFFER_DURATION (buffer);
+
+  if (G_UNLIKELY (in_ts == GST_CLOCK_TIME_NONE)) {
+    in_ts = videorate->last_ts;
+    if (G_UNLIKELY (in_ts == GST_CLOCK_TIME_NONE))
+      goto invalid_buffer;
+  }
 
-  if (G_UNLIKELY (in_ts == GST_CLOCK_TIME_NONE))
-    goto invalid_buffer;
+  /* get the time of the next expected buffer timestamp, we use this when the
+   * next buffer has -1 as a timestamp */
+  videorate->last_ts = in_ts;
+  if (in_dur != GST_CLOCK_TIME_NONE)
+    videorate->last_ts += in_dur;
 
   GST_DEBUG_OBJECT (videorate, "got buffer with timestamp %" GST_TIME_FORMAT,
       GST_TIME_ARGS (in_ts));
@@ -698,7 +716,7 @@
           GST_TIME_ARGS (videorate->next_ts));
 
       /* output first one when its the best */
-      if (diff1 < diff2) {
+      if (diff1 <= diff2) {
         count++;
 
         /* on error the _flush function posted a warning already */
@@ -707,7 +725,8 @@
           goto done;
         }
       }
-      /* continue while the first one was the best */
+      /* continue while the first one was the best, if they were equal avoid
+       * going into an infinite loop */
     }
     while (diff1 < diff2);
 
@@ -820,6 +839,7 @@
   switch (transition) {
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       videorate->discont = TRUE;
+      videorate->last_ts = -1;
       break;
     default:
       break;
diff -Naur gst/videorate/gstvideorate.h gst/videorate/gstvideorate.h
--- gst/videorate/gstvideorate.h	2009-05-06 14:42:51.000000000 +0200
+++ gst/videorate/gstvideorate.h	2009-05-19 18:44:45.000000000 +0200
@@ -57,6 +57,7 @@
   guint64 prev_ts;              /* Previous buffer timestamp */
   guint64 segment_out;          /* in-segment counting */
   gboolean discont;
+  guint64 last_ts;              /* Timestamp of last input buffer */
 
   /* segment handling */
   GstSegment segment;
diff -Naur gst/videorate/videorate.vcproj gst/videorate/videorate.vcproj
--- gst/videorate/videorate.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/videorate/videorate.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="videorate"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678DD}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;videorate_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideorate.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/videorate.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstvideorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;videorate_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideorate.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstvideorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstvideorate.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/videoscale/videoscale.vcproj gst/videoscale/videoscale.vcproj
--- gst/videoscale/videoscale.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/videoscale/videoscale.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,154 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="videoscale"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678DE}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;videoscale_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideoscale.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/videoscale.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstvideoscale.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;videoscale_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideoscale.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstvideoscale.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstvideoscale.c">
+			</File>
+			<File
+				RelativePath=".\videoscale.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\gstvideoscale.h">
+			</File>
+			<File
+				RelativePath=".\videoscale.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/videotestsrc/videotestsrc.c gst/videotestsrc/videotestsrc.c
--- gst/videotestsrc/videotestsrc.c	2009-04-01 13:49:11.000000000 +0200
+++ gst/videotestsrc/videotestsrc.c	2009-05-19 18:44:45.000000000 +0200
@@ -314,6 +314,9 @@
 static void paint_setup_v308 (paintinfo * p, unsigned char *dest);
 static void paint_setup_NV12 (paintinfo * p, unsigned char *dest);
 static void paint_setup_NV21 (paintinfo * p, unsigned char *dest);
+static void paint_setup_v410 (paintinfo * p, unsigned char *dest);
+static void paint_setup_v216 (paintinfo * p, unsigned char *dest);
+static void paint_setup_v210 (paintinfo * p, unsigned char *dest);
 
 #if 0
 static void paint_setup_IMC1 (paintinfo * p, unsigned char *dest);
@@ -348,6 +351,9 @@
 static void paint_hline_Y800 (paintinfo * p, int x, int y, int w);
 static void paint_hline_v308 (paintinfo * p, int x, int y, int w);
 static void paint_hline_AYUV (paintinfo * p, int x, int y, int w);
+static void paint_hline_v410 (paintinfo * p, int x, int y, int w);
+static void paint_hline_v216 (paintinfo * p, int x, int y, int w);
+static void paint_hline_v210 (paintinfo * p, int x, int y, int w);
 
 #if 0
 static void paint_hline_IMC1 (paintinfo * p, int x, int y, int w);
@@ -369,6 +375,9 @@
   {VTS_YUV, "YVYU", "YVYU", 16, paint_setup_YVYU, paint_hline_YUY2},
   {VTS_YUV, "v308", "v308", 24, paint_setup_v308, paint_hline_v308},
   {VTS_YUV, "AYUV", "AYUV", 32, paint_setup_AYUV, paint_hline_AYUV},
+  {VTS_YUV, "v410", "v410", 32, paint_setup_v410, paint_hline_v410},
+  {VTS_YUV, "v210", "v210", 21, paint_setup_v210, paint_hline_v210},
+  {VTS_YUV, "v216", "v216", 32, paint_setup_v216, paint_hline_v216},
 
   /* interlaced */
   /*{ VTS_YUV,  "IUYV", "IUY2", 16, paint_setup_YVYU, paint_hline_YUY2 }, */
@@ -1338,7 +1347,6 @@
 }
 
 
-
 static void
 paint_setup_I420 (paintinfo * p, unsigned char *dest)
 {
@@ -1438,6 +1446,38 @@
 }
 
 static void
+paint_setup_v410 (paintinfo * p, unsigned char *dest)
+{
+  p->yp = dest + 0;
+  p->up = dest + 0;
+  p->vp = dest + 0;
+  p->ystride = p->width * 4;
+  p->endptr = dest + p->ystride * p->height;
+}
+
+static void
+paint_setup_v216 (paintinfo * p, unsigned char *dest)
+{
+  p->ap = dest;
+  p->yp = dest + 2;
+  p->up = dest + 0;
+  p->vp = dest + 4;
+  p->ystride = p->width * 4;
+  p->endptr = dest + p->ystride * p->height;
+}
+
+static void
+paint_setup_v210 (paintinfo * p, unsigned char *dest)
+{
+  p->ap = dest;
+  p->yp = dest + 0;
+  p->up = dest + 0;
+  p->vp = dest + 0;
+  p->ystride = ((p->width + 47) / 48) * 128;    /* no, really. */
+  p->endptr = dest + p->ystride * p->height;
+}
+
+static void
 paint_setup_YUY2 (paintinfo * p, unsigned char *dest)
 {
   p->yp = dest;
@@ -1491,6 +1531,75 @@
   oil_splat_u8 (p->ap + offset, 4, &alpha, w);
 }
 
+#define TO_16(x) (((x)<<8) | (x))
+#define TO_10(x) (((x)<<2) | ((x)>>6))
+
+static void
+paint_hline_v216 (paintinfo * p, int x, int y, int w)
+{
+  int x1 = x / 2;
+  int x2 = (x + w) / 2;
+  uint16_t Y, U, V;
+  int i;
+  int offset;
+
+  offset = y * p->ystride;
+  Y = TO_16 (p->yuv_color->Y);
+  U = TO_16 (p->yuv_color->U);
+  V = TO_16 (p->yuv_color->V);
+  for (i = x; i < x + w; i++) {
+    GST_WRITE_UINT16_LE (p->yp + offset + i * 4, Y);
+  }
+  for (i = x1; i < x2; i++) {
+    GST_WRITE_UINT16_LE (p->up + offset + i * 8, U);
+    GST_WRITE_UINT16_LE (p->vp + offset + i * 8, V);
+  }
+}
+
+static void
+paint_hline_v410 (paintinfo * p, int x, int y, int w)
+{
+  uint32_t a;
+  uint8_t *data;
+  int i;
+
+  a = (TO_10 (p->yuv_color->U) << 22) |
+      (TO_10 (p->yuv_color->Y) << 12) | (TO_10 (p->yuv_color->V) << 2);
+
+  data = p->yp + y * p->ystride + x * 4;
+  for (i = 0; i < w; i++) {
+    GST_WRITE_UINT32_LE (data, a);
+  }
+}
+
+static void
+paint_hline_v210 (paintinfo * p, int x, int y, int w)
+{
+  uint32_t a0, a1, a2, a3;
+  uint8_t *data;
+  int i;
+
+  /* FIXME this is kinda gross.  it only handles x values in
+     multiples of 6 */
+
+  a0 = TO_10 (p->yuv_color->U) | (TO_10 (p->yuv_color->Y) << 10)
+      | (TO_10 (p->yuv_color->V) << 20);
+  a1 = TO_10 (p->yuv_color->Y) | (TO_10 (p->yuv_color->U) << 10)
+      | (TO_10 (p->yuv_color->Y) << 20);
+  a2 = TO_10 (p->yuv_color->V) | (TO_10 (p->yuv_color->Y) << 10)
+      | (TO_10 (p->yuv_color->U) << 20);
+  a3 = TO_10 (p->yuv_color->Y) | (TO_10 (p->yuv_color->V) << 10)
+      | (TO_10 (p->yuv_color->Y) << 20);
+
+  data = p->yp + y * p->ystride;
+  for (i = x / 6; i < (x + w) / 6; i++) {
+    GST_WRITE_UINT32_LE (data + i * 16 + 0, a0);
+    GST_WRITE_UINT32_LE (data + i * 16 + 4, a1);
+    GST_WRITE_UINT32_LE (data + i * 16 + 8, a2);
+    GST_WRITE_UINT32_LE (data + i * 16 + 12, a3);
+  }
+}
+
 static void
 paint_hline_YUY2 (paintinfo * p, int x, int y, int w)
 {
diff -Naur gst/videotestsrc/videotestsrc.vcproj gst/videotestsrc/videotestsrc.vcproj
--- gst/videotestsrc/videotestsrc.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/videotestsrc/videotestsrc.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,154 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="videotestsrc"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678DF}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;videotestsrc_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideotestsrc.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/videotestsrc.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstvideotestsrc.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;videotestsrc_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideotestsrc.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstvideotestsrc.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstvideotestsrc.c">
+			</File>
+			<File
+				RelativePath=".\videotestsrc.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\videotestsrc.h">
+			</File>
+			<File
+				RelativePath=".\gstvideotestsrc.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst/volume/volume.vcproj gst/volume/volume.vcproj
--- gst/volume/volume.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst/volume/volume.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,148 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="volume"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D678E2}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../win32/Debug"
+			IntermediateDirectory="../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;volume_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvolume.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Debug;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/volume.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstvolume.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../win32/Release"
+			IntermediateDirectory="../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer/win32;../../../gstreamer;../../../gstreamer/libs;../../../glib;../../../glib/glib;../../../glib/gmodule;&quot;../../gst-libs&quot;;../../../popt/include;../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;volume_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvolume.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/Release;../../../glib/glib;../../../glib/gmodule;../../../glib/gthread;../../../glib/gobject;../../../gettext/lib;../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstvolume.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstvolume.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\gstvolume.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst-libs/ext/Makefile.am gst-libs/ext/Makefile.am
--- gst-libs/ext/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/ext/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,2 @@
+SUBDIRS =
+DIST_SUBDIRS =
diff -Naur gst-libs/gst/audio/audio.def gst-libs/gst/audio/audio.def
--- gst-libs/gst/audio/audio.def	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/audio/audio.def	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,5 @@
+EXPORTS
+    gst_plugin_desc
+    gst_audio_length
+    gst_audio_is_buffer_framed
+    gst_audio_highest_sample_value
diff -Naur gst-libs/gst/audio/audiofilter.vcproj gst-libs/gst/audio/audiofilter.vcproj
--- gst-libs/gst/audio/audiofilter.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/audio/audiofilter.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,144 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="audiofilter"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D67894}"
+	RootNamespace="audiofilter"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../../win32/Debug"
+			IntermediateDirectory="../../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;AUDIOFILTER_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudiofilter.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Debug;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile="audio.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/audiofilter.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstaudiofilter.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../../win32/Release"
+			IntermediateDirectory="../../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;AUDIOFILTER_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudiofilter.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Release;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile="audio.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstaudiofilter.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstaudiofilter.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\gstaudiofilter.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst-libs/gst/audio/audio.vcproj gst-libs/gst/audio/audio.vcproj
--- gst-libs/gst/audio/audio.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/audio/audio.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,153 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="audio"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D67893}"
+	RootNamespace="audio"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../../win32/Debug"
+			IntermediateDirectory="../../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;AUDIO_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudio.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Debug;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile="audio.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/audio.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstaudio.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../../win32/Release"
+			IntermediateDirectory="../../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;AUDIO_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstaudio.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Release;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile="audio.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstaudio.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\audio.c">
+			</File>
+			<File
+				RelativePath=".\audio.def">
+			</File>
+			<File
+				RelativePath=".\audioclock.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\audio.h">
+			</File>
+			<File
+				RelativePath=".\audioclock.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst-libs/gst/audio/gstaudioclock.c gst-libs/gst/audio/gstaudioclock.c
--- gst-libs/gst/audio/gstaudioclock.c	2009-04-15 21:18:27.000000000 +0200
+++ gst-libs/gst/audio/gstaudioclock.c	2009-05-19 18:44:45.000000000 +0200
@@ -165,12 +165,21 @@
   aclock = GST_AUDIO_CLOCK_CAST (clock);
 
   result = aclock->func (clock, aclock->user_data);
-  if (result == GST_CLOCK_TIME_NONE)
+  if (result == GST_CLOCK_TIME_NONE) {
     result = aclock->last_time;
-  else {
+  } else {
     result += aclock->abidata.ABI.time_offset;
-    aclock->last_time = result;
+    /* clock must be increasing */
+    if (aclock->last_time < result)
+      aclock->last_time = result;
+    else
+      result = aclock->last_time;
   }
+
+  GST_DEBUG_OBJECT (clock,
+      "result %" GST_TIME_FORMAT ", last_time %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (result), GST_TIME_ARGS (aclock->last_time));
+
   return result;
 }
 
@@ -194,6 +203,9 @@
   aclock = GST_AUDIO_CLOCK_CAST (clock);
 
   result = aclock->func (clock, aclock->user_data);
+  if (result == GST_CLOCK_TIME_NONE) {
+    result = aclock->last_time - aclock->abidata.ABI.time_offset;
+  }
 
   return result;
 }
diff -Naur gst-libs/gst/audio/gstbaseaudiosink.c gst-libs/gst/audio/gstbaseaudiosink.c
--- gst-libs/gst/audio/gstbaseaudiosink.c	2009-04-21 21:33:22.000000000 +0200
+++ gst-libs/gst/audio/gstbaseaudiosink.c	2009-05-19 18:44:45.000000000 +0200
@@ -1489,7 +1489,7 @@
       break;
 
     /* else something interrupted us and we wait for preroll. */
-    if (gst_base_sink_wait_preroll (bsink) != GST_FLOW_OK)
+    if ((ret = gst_base_sink_wait_preroll (bsink)) != GST_FLOW_OK)
       goto stopping;
 
     /* if we got interrupted, we cannot assume that the next sample should
@@ -1549,7 +1549,7 @@
 stopping:
   {
     GST_DEBUG_OBJECT (sink, "ringbuffer is stopping");
-    return GST_FLOW_WRONG_STATE;
+    return ret;
   }
 sync_latency_failed:
   {
diff -Naur gst-libs/gst/interfaces/colorbalance.c gst-libs/gst/interfaces/colorbalance.c
--- gst-libs/gst/interfaces/colorbalance.c	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/colorbalance.c	2009-05-19 18:44:45.000000000 +0200
@@ -185,6 +185,24 @@
 }
 
 /**
+ * gst_color_balance_get_balance_type:
+ * @balance: The #GstColorBalance implementation
+ *
+ * Get the #GstColorBalanceType of this implementation.
+ *
+ * Returns: A the #GstColorBalanceType.
+ *
+ * Since: 0.10.24
+ */
+GstColorBalanceType
+gst_color_balance_get_balance_type (GstColorBalance * balance)
+{
+  GstColorBalanceClass *klass = GST_COLOR_BALANCE_GET_CLASS (balance);
+
+  return klass->balance_type;
+}
+
+/**
  * gst_color_balance_value_changed:
  * @balance: A #GstColorBalance instance
  * @channel: A #GstColorBalanceChannel whose value has changed
diff -Naur gst-libs/gst/interfaces/colorbalancechannel.h gst-libs/gst/interfaces/colorbalancechannel.h
--- gst-libs/gst/interfaces/colorbalancechannel.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/colorbalancechannel.h	2009-05-19 18:44:45.000000000 +0200
@@ -39,22 +39,26 @@
 #define GST_IS_COLOR_BALANCE_CHANNEL_CLASS(klass) \
   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_COLOR_BALANCE_CHANNEL))
 
+typedef struct _GstColorBalanceChannel GstColorBalanceChannel;
+typedef struct _GstColorBalanceChannelClass GstColorBalanceChannelClass;
+
 /**
  * GstColorBalanceChannel:
  * @label: A string containing a descriptive name for this channel
  * @min_value: The minimum valid value for this channel.
  * @max_value: The maximum valid value for this channel.
  */
-typedef struct _GstColorBalanceChannel {
+struct _GstColorBalanceChannel {
   GObject parent;
 
   /*< public >*/
   gchar  *label;
   gint    min_value;
   gint    max_value;
-} GstColorBalanceChannel;
+};
+
 
-typedef struct _GstColorBalanceChannelClass {
+struct _GstColorBalanceChannelClass {
   GObjectClass parent;
 
   /* signals */
@@ -62,7 +66,7 @@
                           gint                    value);
 
   gpointer _gst_reserved[GST_PADDING];
-} GstColorBalanceChannelClass;
+};
 
 GType   gst_color_balance_channel_get_type (void);
 
diff -Naur gst-libs/gst/interfaces/colorbalance.h gst-libs/gst/interfaces/colorbalance.h
--- gst-libs/gst/interfaces/colorbalance.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/colorbalance.h	2009-05-19 18:44:45.000000000 +0200
@@ -46,6 +46,7 @@
 #define GST_COLOR_BALANCE_TYPE(klass) (klass->balance_type)
 
 typedef struct _GstColorBalance GstColorBalance;
+typedef struct _GstColorBalanceClass GstColorBalanceClass;
   
 /**
  * GstColorBalanceType:
@@ -65,7 +66,7 @@
   GST_COLOR_BALANCE_SOFTWARE
 } GstColorBalanceType;
 
-typedef struct _GstColorBalanceClass {
+struct _GstColorBalanceClass {
   GTypeInterface klass;
 
   GstColorBalanceType balance_type;
@@ -85,7 +86,7 @@
                           gint                    value);
 
   gpointer _gst_reserved[GST_PADDING];
-} GstColorBalanceClass;
+};
 
 GType   gst_color_balance_get_type      (void);
 
@@ -98,6 +99,9 @@
 gint    gst_color_balance_get_value     (GstColorBalance        *balance,
                                          GstColorBalanceChannel *channel);
 
+GstColorBalanceType
+        gst_color_balance_get_balance_type (GstColorBalance        *balance);
+
 /* trigger signal */
 void    gst_color_balance_value_changed (GstColorBalance        *balance,
                                          GstColorBalanceChannel *channel,
diff -Naur gst-libs/gst/interfaces/mixer.c gst-libs/gst/interfaces/mixer.c
--- gst-libs/gst/interfaces/mixer.c	2009-04-01 13:49:11.000000000 +0200
+++ gst-libs/gst/interfaces/mixer.c	2009-05-19 18:44:45.000000000 +0200
@@ -324,6 +324,24 @@
 }
 
 /**
+ * gst_mixer_get_mixer_type:
+ * @mixer: The #GstMixer implementation
+ *
+ * Get the #GstMixerType of this mixer implementation.
+ *
+ * Returns: A the #GstMixerType.
+ *
+ * Since: 0.10.24
+ */
+GstMixerType
+gst_mixer_get_mixer_type (GstMixer * mixer)
+{
+  GstMixerClass *klass = GST_MIXER_GET_CLASS (mixer);
+
+  return klass->mixer_type;
+}
+
+/**
  * gst_mixer_get_mixer_flags:
  * @mixer: The #GstMixer implementation
  *
diff -Naur gst-libs/gst/interfaces/mixer.h gst-libs/gst/interfaces/mixer.h
--- gst-libs/gst/interfaces/mixer.h	2009-04-01 13:49:11.000000000 +0200
+++ gst-libs/gst/interfaces/mixer.h	2009-05-19 18:44:45.000000000 +0200
@@ -204,6 +204,7 @@
 void            gst_mixer_options_list_changed (GstMixer        *mixer,
                                                 GstMixerOptions *opts);
 
+GstMixerType    gst_mixer_get_mixer_type  (GstMixer *mixer);
 
 GstMixerFlags   gst_mixer_get_mixer_flags (GstMixer *mixer);
 
diff -Naur gst-libs/gst/interfaces/navigation.h gst-libs/gst/interfaces/navigation.h
--- gst-libs/gst/interfaces/navigation.h	2009-04-15 21:18:27.000000000 +0200
+++ gst-libs/gst/interfaces/navigation.h	2009-05-19 18:44:45.000000000 +0200
@@ -37,15 +37,16 @@
     (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_NAVIGATION, GstNavigationInterface))
 
 typedef struct _GstNavigation GstNavigation;
+typedef struct _GstNavigationInterface GstNavigationInterface;
 
-typedef struct _GstNavigationInterface {
+struct _GstNavigationInterface {
   GTypeInterface g_iface;
 
   /* virtual functions */
   void (*send_event) (GstNavigation *navigation, GstStructure *structure);
   
   gpointer _gst_reserved[GST_PADDING];
-} GstNavigationInterface;
+};
 
 GType           gst_navigation_get_type (void);
 
diff -Naur gst-libs/gst/interfaces/propertyprobe.h gst-libs/gst/interfaces/propertyprobe.h
--- gst-libs/gst/interfaces/propertyprobe.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/propertyprobe.h	2009-05-19 18:44:45.000000000 +0200
@@ -47,7 +47,7 @@
  * GstPropertyProbeInterface:
  * @klass: parent interface type.
  * @probe_needed: default signal handler
- * @get_properties: virtual method to get list of pobable properties
+ * @get_properties: virtual method to get list of probable properties
  * @needs_probe: virtual method to tell if probe need update
  * @probe_property: virtual method to probe a property
  * @get_values: virtual method to get probe results for a property
diff -Naur gst-libs/gst/interfaces/tunerchannel.h gst-libs/gst/interfaces/tunerchannel.h
--- gst-libs/gst/interfaces/tunerchannel.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/tunerchannel.h	2009-05-19 18:44:45.000000000 +0200
@@ -39,6 +39,9 @@
 #define GST_IS_TUNER_CHANNEL_CLASS(klass) \
   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TUNER_CHANNEL))
 
+typedef struct _GstTunerChannel GstTunerChannel;
+typedef struct _GstTunerChannelClass GstTunerChannelClass;
+
 /**
  * GstTunerChannelFlags:
  * @GST_TUNER_CHANNEL_INPUT: The channel is for input
@@ -77,7 +80,7 @@
  * @min_signal: Minimum reported signal strength value.
  * @max_signal: Maximum reported signal strength value.
  */
-typedef struct _GstTunerChannel {
+struct _GstTunerChannel {
   GObject              parent;
 
   /*< public >*/
@@ -88,9 +91,9 @@
   gulong               max_frequency;
   gint                 min_signal;
   gint                 max_signal;
-} GstTunerChannel;
+};
 
-typedef struct _GstTunerChannelClass {
+struct _GstTunerChannelClass {
   GObjectClass parent;
 
   /*< private >*/
@@ -101,7 +104,7 @@
                              gint             signal);
 
   gpointer _gst_reserved[GST_PADDING];
-} GstTunerChannelClass;
+};
 
 GType           gst_tuner_channel_get_type      (void);
 
diff -Naur gst-libs/gst/interfaces/tuner.h gst-libs/gst/interfaces/tuner.h
--- gst-libs/gst/interfaces/tuner.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/tuner.h	2009-05-19 18:44:45.000000000 +0200
@@ -43,8 +43,9 @@
   (G_TYPE_INSTANCE_GET_INTERFACE ((inst), GST_TYPE_TUNER, GstTunerClass))
 
 typedef struct _GstTuner GstTuner;
+typedef struct _GstTunerClass GstTunerClass;
 
-typedef struct _GstTunerClass {
+struct _GstTunerClass {
   GTypeInterface klass;
 
   /* virtual functions */
@@ -80,7 +81,7 @@
                              gint             signal);
 
   gpointer _gst_reserved[GST_PADDING];
-} GstTunerClass;
+};
 
 GType           gst_tuner_get_type              (void);
 
diff -Naur gst-libs/gst/interfaces/tunernorm.h gst-libs/gst/interfaces/tunernorm.h
--- gst-libs/gst/interfaces/tunernorm.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/tunernorm.h	2009-05-19 18:44:45.000000000 +0200
@@ -37,25 +37,28 @@
 #define GST_IS_TUNER_NORM_CLASS(klass) \
   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TUNER_NORM))
 
+typedef struct _GstTunerNorm GstTunerNorm;
+typedef struct _GstTunerNormClass GstTunerNormClass;
+
 /**
  * GstTunerNorm:
  * @label: A string containing a descriptive name for the norm
  * @framerate: A GValue containing the framerate associated with this norm,
  *             if any. (May be unset).
  */
-typedef struct _GstTunerNorm {
+struct _GstTunerNorm {
   GObject parent;
 
   /*< public >*/
   gchar  *label;
   GValue  framerate;
-} GstTunerNorm;
+};
 
-typedef struct _GstTunerNormClass {
+struct _GstTunerNormClass {
   GObjectClass parent;
 
   gpointer _gst_reserved[GST_PADDING];
-} GstTunerNormClass;
+};
 
 GType           gst_tuner_norm_get_type         (void);
 
diff -Naur gst-libs/gst/interfaces/videoorientation.h gst-libs/gst/interfaces/videoorientation.h
--- gst-libs/gst/interfaces/videoorientation.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/videoorientation.h	2009-05-19 18:44:45.000000000 +0200
@@ -42,6 +42,7 @@
  * Opaque #GstVideoOrientation data structure.
  */
 typedef struct _GstVideoOrientation GstVideoOrientation;
+typedef struct _GstVideoOrientationInterface GstVideoOrientationInterface;
 
 /**
  * GstVideoOrientationInterface:
@@ -57,7 +58,7 @@
  *
  * #GstVideoOrientationInterface interface.
  */
-typedef struct _GstVideoOrientationInterface {
+struct _GstVideoOrientationInterface {
   GTypeInterface parent;
 
   /* virtual functions */
@@ -73,7 +74,7 @@
 
   /*< private > */
   gpointer _gst_reserved[GST_PADDING];
-} GstVideoOrientationInterface;
+};
 
 GType           gst_video_orientation_get_type              (void);
 
diff -Naur gst-libs/gst/interfaces/xoverlay.h gst-libs/gst/interfaces/xoverlay.h
--- gst-libs/gst/interfaces/xoverlay.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/interfaces/xoverlay.h	2009-05-19 18:44:45.000000000 +0200
@@ -47,6 +47,7 @@
  * Opaque #GstXOverlay data structure.
  */
 typedef struct _GstXOverlay GstXOverlay;
+typedef struct _GstXOverlayClass GstXOverlayClass;
 
 /**
  * GstXOverlayClass:
@@ -57,7 +58,7 @@
  *
  * #GstXOverlay interface
  */
-typedef struct _GstXOverlayClass {
+struct _GstXOverlayClass {
   GTypeInterface klass;
 
   /* virtual functions */
@@ -71,7 +72,7 @@
 
   /*< private >*/
   gpointer                 _gst_reserved[GST_PADDING - 1];
-} GstXOverlayClass;
+};
 
 GType   gst_x_overlay_get_type          (void);
 
diff -Naur gst-libs/gst/pbutils/descriptions.c gst-libs/gst/pbutils/descriptions.c
--- gst-libs/gst/pbutils/descriptions.c	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/pbutils/descriptions.c	2009-05-19 18:44:45.000000000 +0200
@@ -65,7 +65,9 @@
   {"application/vnd.rn-realmedia", "Realmedia", FLAG_CONTAINER},
   {"application/x-id3", N_("ID3 tag"), FLAG_CONTAINER},
   {"application/x-ape", N_("APE tag"), FLAG_CONTAINER},
+  {"application/x-apetag", N_("APE tag"), FLAG_CONTAINER},
   {"application/x-icy", N_("ICY internet radio"), FLAG_CONTAINER},
+  {"application/x-3gp", "3GP", FLAG_CONTAINER},
   {"video/x-fli", "FLI/FLC/FLX Animation", FLAG_CONTAINER},
   {"video/x-flv", "Flash", FLAG_CONTAINER},
   {"video/x-matroska", "Matroska", FLAG_CONTAINER},
@@ -73,6 +75,7 @@
   {"video/x-msvideo", "AVI", FLAG_CONTAINER},
   {"video/x-quicktime", "Quicktime", FLAG_CONTAINER},
   {"video/quicktime", "Quicktime", FLAG_CONTAINER},
+  {"video/mj2", "Motion JPEG 2000", FLAG_CONTAINER},
 
   /* audio formats with static descriptions */
   {"audio/x-ac3", "AC-3 (ATSC A/52)", 0},
@@ -197,6 +200,9 @@
   {"image/tiff", "TIFF", 0},
   {"image/x-cmu-raster", "CMU Raster Format", 0},
   {"image/x-icon", "ICO", 0},
+  {"image/x-j2c", "JPEG 2000", 0},
+  {"image/x-jpc", "JPEG 2000", 0},
+  {"image/jp2", "JPEG 2000", 0},
   {"image/x-xcf", "XFC", 0},
   {"image/x-pixmap", "XPM", 0},
   {"image/x-xpixmap", "XPM", 0},
diff -Naur gst-libs/gst/riff/riff.def gst-libs/gst/riff/riff.def
--- gst-libs/gst/riff/riff.def	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/riff/riff.def	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,27 @@
+EXPORTS
+    gst_plugin_desc
+    gst_riff_read_get_type
+    gst_riff_read_element_data
+    gst_riff_create_video_template_caps
+    gst_riff_create_video_caps
+    gst_riff_create_video_caps_with_data
+    gst_riff_create_audio_template_caps
+    gst_riff_create_audio_caps
+    gst_riff_create_audio_caps_with_data
+    gst_riff_create_iavs_template_caps
+    gst_riff_create_iavs_caps
+    gst_riff_read_header
+    gst_riff_read_data
+    gst_riff_read_seek
+    gst_riff_read_skip
+    gst_riff_read_info
+    gst_riff_read_list
+    gst_riff_read_ascii
+    gst_riff_read_strh
+    gst_riff_read_strf_iavs
+    gst_riff_read_strf_auds
+    gst_riff_read_strf_auds_with_data
+    gst_riff_read_strf_vids_with_data
+    gst_riff_peek_tag
+    gst_riff_peek_list
+    gst_riff_peek_head
diff -Naur gst-libs/gst/riff/riff-media.c gst-libs/gst/riff/riff-media.c
--- gst-libs/gst/riff/riff-media.c	2009-04-01 13:49:11.000000000 +0200
+++ gst-libs/gst/riff/riff-media.c	2009-05-19 18:44:45.000000000 +0200
@@ -114,6 +114,13 @@
         *codec_name = g_strdup ("Uncompressed packed YVU 4:1:0");
       break;
 
+    case GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'):
+      caps = gst_caps_new_simple ("video/x-raw-yuv",
+          "format", GST_TYPE_FOURCC, codec_fcc, NULL);
+      if (codec_name)
+        *codec_name = g_strdup ("Uncompressed packed YUV 4:2:2");
+      break;
+
     case GST_MAKE_FOURCC ('M', 'J', 'P', 'G'): /* YUY2 MJPEG */
     case GST_MAKE_FOURCC ('A', 'V', 'R', 'n'):
     case GST_MAKE_FOURCC ('I', 'J', 'P', 'G'):
@@ -1684,6 +1691,7 @@
     GST_MAKE_FOURCC ('T', 'M', '2', '0'),
     GST_MAKE_FOURCC ('T', 'S', 'C', 'C'),
     GST_MAKE_FOURCC ('U', 'L', 'T', 'I'),
+    GST_MAKE_FOURCC ('U', 'Y', 'V', 'Y'),
     GST_MAKE_FOURCC ('V', 'C', 'R', '1'),
     GST_MAKE_FOURCC ('V', 'C', 'R', '2'),
     GST_MAKE_FOURCC ('V', 'D', 'O', 'W'),
diff -Naur gst-libs/gst/riff/riff.vcproj gst-libs/gst/riff/riff.vcproj
--- gst-libs/gst/riff/riff.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/riff/riff.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,158 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="riff"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D67890}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../../win32/Debug"
+			IntermediateDirectory="../../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;RIFF_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstriff.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Debug;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile="riff.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/riff.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstriff.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../../win32/Release"
+			IntermediateDirectory="../../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;RIFF_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstriff.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Release;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile="riff.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstriff.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\riff-media.c">
+			</File>
+			<File
+				RelativePath=".\riff-read.c">
+			</File>
+			<File
+				RelativePath=".\riff.c">
+			</File>
+			<File
+				RelativePath=".\riff.def">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\riff-ids.h">
+			</File>
+			<File
+				RelativePath=".\riff-media.h">
+			</File>
+			<File
+				RelativePath=".\riff-read.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur gst-libs/gst/rtp/gstbasertppayload.c gst-libs/gst/rtp/gstbasertppayload.c
--- gst-libs/gst/rtp/gstbasertppayload.c	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/rtp/gstbasertppayload.c	2009-05-19 18:44:45.000000000 +0200
@@ -469,7 +469,7 @@
   GstCaps *srccaps, *peercaps;
   gboolean res;
 
-  /* fill in the defaults, there properties cannot be negotiated. */
+  /* fill in the defaults, their properties cannot be negotiated. */
   srccaps = gst_caps_new_simple ("application/x-rtp",
       "media", G_TYPE_STRING, payload->media,
       "clock-rate", G_TYPE_INT, payload->clock_rate,
diff -Naur gst-libs/gst/rtp/gstbasertppayload.h gst-libs/gst/rtp/gstbasertppayload.h
--- gst-libs/gst/rtp/gstbasertppayload.h	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/rtp/gstbasertppayload.h	2009-05-19 18:44:45.000000000 +0200
@@ -118,7 +118,7 @@
   /* receive caps on the sink pad, configure the payloader. */
   gboolean      (*set_caps)             (GstBaseRTPPayload *payload, GstCaps *caps);
   /* handle a buffer, perform 0 or more gst_basertppayload_push() on
-   * the RTP buffers */
+   * the RTP buffers. This function takes ownership of the buffer. */
   GstFlowReturn (*handle_buffer)        (GstBaseRTPPayload *payload, 
                                          GstBuffer *buffer);
   gboolean      (*handle_event)         (GstPad * pad, GstEvent * event);
diff -Naur gst-libs/gst/tag/gsttagdemux.c gst-libs/gst/tag/gsttagdemux.c
--- gst-libs/gst/tag/gsttagdemux.c	2009-04-01 13:49:11.000000000 +0200
+++ gst-libs/gst/tag/gsttagdemux.c	2009-05-19 18:44:45.000000000 +0200
@@ -111,6 +111,8 @@
   GstSegment segment;
   gboolean need_newseg;
   gboolean newseg_update;
+
+  GList *pending_events;
 };
 
 /* Require at least 8kB of data before we attempt typefind. 
@@ -267,6 +269,11 @@
   gst_segment_init (&tagdemux->priv->segment, GST_FORMAT_UNDEFINED);
   tagdemux->priv->need_newseg = TRUE;
   tagdemux->priv->newseg_update = FALSE;
+
+  g_list_foreach (tagdemux->priv->pending_events,
+      (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (tagdemux->priv->pending_events);
+  tagdemux->priv->pending_events = NULL;
 }
 
 static void
@@ -663,6 +670,8 @@
           return GST_FLOW_UNEXPECTED;
       }
       if (outbuf) {
+        GList *events;
+
         if (G_UNLIKELY (demux->priv->srcpad == NULL)) {
           gst_buffer_unref (outbuf);
           return GST_FLOW_ERROR;
@@ -677,7 +686,20 @@
           demux->priv->need_newseg = FALSE;
         }
 
-        /* Send pending tag event */
+        /* send any pending events we cached */
+        GST_OBJECT_LOCK (demux);
+        events = demux->priv->pending_events;
+        demux->priv->pending_events = NULL;
+        GST_OBJECT_UNLOCK (demux);
+
+        while (events != NULL) {
+          GST_DEBUG_OBJECT (demux->priv->srcpad, "sending cached %s event: %"
+              GST_PTR_FORMAT, GST_EVENT_TYPE_NAME (events->data), events->data);
+          gst_pad_push_event (demux->priv->srcpad, GST_EVENT (events->data));
+          events = g_list_delete_link (events, events);
+        }
+
+        /* Send our own pending tag event */
         if (demux->priv->send_tag_event) {
           gst_tag_demux_send_tag_event (demux);
           demux->priv->send_tag_event = FALSE;
@@ -735,7 +757,18 @@
       break;
     }
     default:
-      ret = gst_pad_event_default (pad, event);
+      if (demux->priv->need_newseg) {
+        /* Cache all events if we have a pending segment, so they don't get
+         * lost (esp. tag events) */
+        GST_INFO_OBJECT (demux, "caching event: %" GST_PTR_FORMAT, event);
+        GST_OBJECT_LOCK (demux);
+        demux->priv->pending_events =
+            g_list_append (demux->priv->pending_events, event);
+        GST_OBJECT_UNLOCK (demux);
+        ret = TRUE;
+      } else {
+        ret = gst_pad_event_default (pad, event);
+      }
       break;
   }
 
diff -Naur gst-libs/gst/tag/gstvorbistag.c gst-libs/gst/tag/gstvorbistag.c
--- gst-libs/gst/tag/gstvorbistag.c	2009-04-01 13:49:11.000000000 +0200
+++ gst-libs/gst/tag/gstvorbistag.c	2009-05-19 18:44:45.000000000 +0200
@@ -460,6 +460,39 @@
 }
 MyForEach;
 
+static GList *
+gst_tag_to_coverart (const GValue * image_value)
+{
+  gchar *coverart_data, *data_result, *mime_result;
+  const gchar *mime_type;
+  GstStructure *mime_struct;
+  GstBuffer *buffer;
+  GList *l = NULL;
+
+  g_return_val_if_fail (image_value != NULL, NULL);
+
+  buffer = gst_value_get_buffer (image_value);
+  g_return_val_if_fail (gst_caps_is_fixed (buffer->caps), NULL);
+  mime_struct = gst_caps_get_structure (buffer->caps, 0);
+  mime_type = gst_structure_get_name (mime_struct);
+
+  if (strcmp (mime_type, "text/uri-list") == 0) {
+    /* URI reference */
+    coverart_data = g_strndup ((gchar *) buffer->data, buffer->size);
+  } else {
+    coverart_data = g_base64_encode (buffer->data, buffer->size);
+  }
+
+  data_result = g_strdup_printf ("COVERART=%s", coverart_data);
+  mime_result = g_strdup_printf ("COVERARTMIME=%s", mime_type);
+  g_free (coverart_data);
+
+  l = g_list_append (l, data_result);
+  l = g_list_append (l, mime_result);
+
+  return l;
+}
+
 /**
  * gst_tag_to_vorbis_comments:
  * @list: a #GstTagList
@@ -481,6 +514,18 @@
   g_return_val_if_fail (list != NULL, NULL);
   g_return_val_if_fail (tag != NULL, NULL);
 
+  /* Special case: cover art is split into two tags to store data and
+   * MIME-type. Even if the tag list contains multiple entries, there is
+   * no reasonable way to save more than one.
+   * If both, preview image and image, are present we prefer the
+   * image tag.
+   */
+  if ((strcmp (tag, GST_TAG_PREVIEW_IMAGE) == 0 &&
+          gst_tag_list_get_tag_size (list, GST_TAG_IMAGE) == 0) ||
+      strcmp (tag, GST_TAG_IMAGE) == 0) {
+    return gst_tag_to_coverart (gst_tag_list_get_value_index (list, tag, 0));
+  }
+
   if (strcmp (tag, GST_TAG_EXTENDED_COMMENT) != 0) {
     vorbis_tag = gst_tag_to_vorbis_tag (tag);
     if (!vorbis_tag)
diff -Naur gst-libs/gst/video/gstbasevideocodec.c gst-libs/gst/video/gstbasevideocodec.c
--- gst-libs/gst/video/gstbasevideocodec.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideocodec.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,564 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideocodec.h"
+
+#include <string.h>
+#include <math.h>
+
+GST_DEBUG_CATEGORY (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+/* GstBaseVideoCodec signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_base_video_codec_finalize (GObject * object);
+
+static GstStateChangeReturn gst_base_video_codec_change_state (GstElement *
+    element, GstStateChange transition);
+
+
+GST_BOILERPLATE (GstBaseVideoCodec, gst_base_video_codec, GstElement,
+    GST_TYPE_ELEMENT);
+
+static void
+gst_base_video_codec_base_init (gpointer g_class)
+{
+  GST_DEBUG_CATEGORY_INIT (basevideo_debug, "basevideo", 0,
+      "Base Video Classes");
+
+}
+
+static void
+gst_base_video_codec_class_init (GstBaseVideoCodecClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_codec_finalize;
+
+  element_class->change_state = gst_base_video_codec_change_state;
+}
+
+static void
+gst_base_video_codec_init (GstBaseVideoCodec * base_video_codec,
+    GstBaseVideoCodecClass * klass)
+{
+  GstPadTemplate *pad_template;
+
+  GST_DEBUG ("gst_base_video_codec_init");
+
+  pad_template =
+      gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "sink");
+  g_return_if_fail (pad_template != NULL);
+
+  base_video_codec->sinkpad = gst_pad_new_from_template (pad_template, "sink");
+  gst_element_add_pad (GST_ELEMENT (base_video_codec),
+      base_video_codec->sinkpad);
+
+  pad_template =
+      gst_element_class_get_pad_template (GST_ELEMENT_CLASS (klass), "src");
+  g_return_if_fail (pad_template != NULL);
+
+  base_video_codec->srcpad = gst_pad_new_from_template (pad_template, "src");
+  gst_element_add_pad (GST_ELEMENT (base_video_codec),
+      base_video_codec->srcpad);
+
+  base_video_codec->input_adapter = gst_adapter_new ();
+  base_video_codec->output_adapter = gst_adapter_new ();
+
+}
+
+static void
+gst_base_video_codec_reset (GstBaseVideoCodec * base_video_codec)
+{
+  GST_DEBUG ("reset");
+
+  base_video_codec->system_frame_number = 0;
+
+  gst_adapter_clear (base_video_codec->input_adapter);
+  gst_adapter_clear (base_video_codec->output_adapter);
+
+}
+
+static void
+gst_base_video_codec_finalize (GObject * object)
+{
+  GstBaseVideoCodec *base_video_codec;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_CODEC (object));
+  base_video_codec = GST_BASE_VIDEO_CODEC (object);
+
+  if (base_video_codec->input_adapter) {
+    g_object_unref (base_video_codec->input_adapter);
+  }
+  if (base_video_codec->output_adapter) {
+    g_object_unref (base_video_codec->output_adapter);
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+#ifdef unused
+static const GstQueryType *
+gst_base_video_codec_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_POSITION,
+    GST_QUERY_DURATION,
+    GST_QUERY_CONVERT,
+    0
+  };
+
+  return query_types;
+}
+#endif
+
+#if 0
+static gboolean
+gst_base_video_codec_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res;
+  GstBaseVideoCodec *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (dec->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          dec->fps_d * GST_SECOND, dec->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  } else {
+    GST_WARNING ("unhandled conversion from %d to %d", src_format,
+        *dest_format);
+    res = FALSE;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+
+static gboolean
+gst_base_video_codec_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoCodec *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  switch (src_format) {
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_d * GST_SECOND, dec->fps_n);
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+        {
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_n, dec->fps_d * GST_SECOND);
+          break;
+        }
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoCodec *base_codec;
+  gboolean res = FALSE;
+
+  base_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_POSITION:
+    {
+      GstFormat format;
+      gint64 time;
+      gint64 value;
+
+      gst_query_parse_position (query, &format, NULL);
+
+      time = gst_util_uint64_scale (base_codec->system_frame_number,
+          base_codec->state.fps_n, base_codec->state.fps_d);
+      time += base_codec->state.segment.time;
+      GST_DEBUG ("query position %lld", time);
+      res = gst_base_video_encoded_video_convert (&base_codec->state,
+          GST_FORMAT_TIME, time, &format, &value);
+      if (!res)
+        goto error;
+
+      gst_query_set_position (query, format, value);
+      break;
+    }
+    case GST_QUERY_DURATION:
+      res = gst_pad_query (GST_PAD_PEER (base_codec->sinkpad), query);
+      if (!res)
+        goto error;
+      break;
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      GST_DEBUG ("query convert");
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_codec->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_codec);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_codec, "query failed");
+  goto done;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoCodec *base_video_codec;
+  gboolean res = FALSE;
+
+  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_video_codec);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_video_codec, "query failed");
+  goto done;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_src_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoCodec *base_video_codec;
+  gboolean res = FALSE;
+
+  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstFormat format, tformat;
+      gdouble rate;
+      GstEvent *real_seek;
+      GstSeekFlags flags;
+      GstSeekType cur_type, stop_type;
+      gint64 cur, stop;
+      gint64 tcur, tstop;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
+          &cur, &stop_type, &stop);
+      gst_event_unref (event);
+
+      tformat = GST_FORMAT_TIME;
+      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
+          format, cur, &tformat, &tcur);
+      if (!res)
+        goto convert_error;
+      res = gst_base_video_encoded_video_convert (&base_video_codec->state,
+          format, stop, &tformat, &tstop);
+      if (!res)
+        goto convert_error;
+
+      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+          flags, cur_type, tcur, stop_type, tstop);
+
+      res = gst_pad_push_event (base_video_codec->sinkpad, real_seek);
+
+      break;
+    }
+#if 0
+    case GST_EVENT_QOS:
+    {
+      gdouble proportion;
+      GstClockTimeDiff diff;
+      GstClockTime timestamp;
+
+      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
+
+      GST_OBJECT_LOCK (base_video_codec);
+      base_video_codec->proportion = proportion;
+      base_video_codec->earliest_time = timestamp + diff;
+      GST_OBJECT_UNLOCK (base_video_codec);
+
+      GST_DEBUG_OBJECT (base_video_codec,
+          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT,
+          GST_TIME_ARGS (timestamp), diff);
+
+      res = gst_pad_push_event (base_video_codec->sinkpad, event);
+      break;
+    }
+#endif
+    default:
+      res = gst_pad_push_event (base_video_codec->sinkpad, event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_codec);
+  return res;
+
+convert_error:
+  GST_DEBUG_OBJECT (base_video_codec, "could not convert format");
+  goto done;
+}
+#endif
+
+#ifdef unused
+static gboolean
+gst_base_video_codec_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoCodec *base_video_codec;
+  gboolean ret = FALSE;
+
+  base_video_codec = GST_BASE_VIDEO_CODEC (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      gst_base_video_codec_reset (base_video_codec);
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    case GST_EVENT_EOS:
+      if (gst_base_video_codec_push_all (base_video_codec,
+              FALSE) == GST_FLOW_ERROR) {
+        gst_event_unref (event);
+        return FALSE;
+      }
+
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      GstFormat format;
+      gdouble rate;
+      gint64 start, stop, time;
+
+      gst_event_parse_new_segment (event, &update, &rate, &format, &start,
+          &stop, &time);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      if (rate <= 0.0)
+        goto newseg_wrong_rate;
+
+      GST_DEBUG ("newsegment %lld %lld", start, time);
+      gst_segment_set_newsegment (&base_video_codec->state.segment, update,
+          rate, format, start, stop, time);
+
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+    }
+    default:
+      ret = gst_pad_push_event (base_video_codec->srcpad, event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_codec);
+  return ret;
+
+newseg_wrong_format:
+  GST_DEBUG_OBJECT (base_video_codec, "received non TIME newsegment");
+  gst_event_unref (event);
+  goto done;
+
+newseg_wrong_rate:
+  GST_DEBUG_OBJECT (base_video_codec, "negative rates not supported");
+  gst_event_unref (event);
+  goto done;
+}
+#endif
+
+
+static GstStateChangeReturn
+gst_base_video_codec_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoCodec *base_video_codec = GST_BASE_VIDEO_CODEC (element);
+  GstStateChangeReturn ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_base_video_codec_reset (base_video_codec);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      break;
+    default:
+      break;
+  }
+
+  ret = parent_class->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_base_video_codec_reset (base_video_codec);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+#if 0
+guint64
+gst_base_video_codec_get_timestamp (GstBaseVideoCodec * base_video_codec,
+    int picture_number)
+{
+  if (picture_number < 0) {
+    return base_video_codec->timestamp_offset -
+        (gint64) gst_util_uint64_scale (-picture_number,
+        base_video_codec->state.fps_d * GST_SECOND,
+        base_video_codec->state.fps_n);
+  } else {
+    return base_video_codec->timestamp_offset +
+        gst_util_uint64_scale (picture_number,
+        base_video_codec->state.fps_d * GST_SECOND,
+        base_video_codec->state.fps_n);
+  }
+}
+#endif
+
+GstVideoFrame *
+gst_base_video_codec_new_frame (GstBaseVideoCodec * base_video_codec)
+{
+  GstVideoFrame *frame;
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+
+  frame->system_frame_number = base_video_codec->system_frame_number;
+  base_video_codec->system_frame_number++;
+
+  return frame;
+}
+
+void
+gst_base_video_codec_free_frame (GstVideoFrame * frame)
+{
+  if (frame->sink_buffer) {
+    gst_buffer_unref (frame->sink_buffer);
+  }
+#if 0
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+#endif
+
+  g_free (frame);
+}
diff -Naur gst-libs/gst/video/gstbasevideocodec.h gst-libs/gst/video/gstbasevideocodec.h
--- gst-libs/gst/video/gstbasevideocodec.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideocodec.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,145 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_CODEC_H_
+#define _GST_BASE_VIDEO_CODEC_H_
+
+#include <gst/gst.h>
+#include <gst/video/gstbasevideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_CODEC \
+  (gst_base_video_codec_get_type())
+#define GST_BASE_VIDEO_CODEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_CODEC,GstBaseVideoCodec))
+#define GST_BASE_VIDEO_CODEC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_CODEC,GstBaseVideoCodecClass))
+#define GST_BASE_VIDEO_CODEC_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_CODEC,GstBaseVideoCodecClass))
+#define GST_IS_BASE_VIDEO_CODEC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_CODEC))
+#define GST_IS_BASE_VIDEO_CODEC_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_CODEC))
+
+/**
+ * GST_BASE_VIDEO_CODEC_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_CODEC_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_CODEC_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_CODEC_SRC_NAME     "src"
+
+/**
+ * GST_BASE_VIDEO_CODEC_SRC_PAD:
+ * @obj: base video codec instance
+ *
+ * Gives the pointer to the source #GstPad object of the element.
+ */
+#define GST_BASE_VIDEO_CODEC_SRC_PAD(obj)         (((GstBaseVideoCodec *) (obj))->srcpad)
+
+/**
+ * GST_BASE_VIDEO_CODEC_SINK_PAD:
+ * @obj: base video codec instance
+ *
+ * Gives the pointer to the sink #GstPad object of the element.
+ */
+#define GST_BASE_VIDEO_CODEC_SINK_PAD(obj)        (((GstBaseVideoCodec *) (obj))->sinkpad)
+
+/**
+ * GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA:
+ *
+ */
+#define GST_BASE_VIDEO_CODEC_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
+
+typedef struct _GstBaseVideoCodec GstBaseVideoCodec;
+typedef struct _GstBaseVideoCodecClass GstBaseVideoCodecClass;
+
+struct _GstBaseVideoCodec
+{
+  GstElement element;
+
+  /*< private >*/
+  GstPad *sinkpad;
+  GstPad *srcpad;
+  GstAdapter *input_adapter;
+  GstAdapter *output_adapter;
+
+#if 0
+  /* FIXME need to move from subclasses */
+  GstVideoState state;
+#endif
+  
+  //int reorder_depth;
+
+  //gboolean have_sync;
+  //gboolean discont;
+  //gboolean started;
+
+  //GstVideoFrame *current_frame;
+  //int distance_from_sync;
+
+  //gboolean sink_clipping;
+
+  //guint64 presentation_frame_number;
+  guint64 system_frame_number;
+
+  //GstCaps *caps;
+  //gboolean set_output_caps;
+
+  //GstClockTime buffer_timestamp;
+
+  GstClockTime timestamp_offset;
+};
+
+struct _GstBaseVideoCodecClass
+{
+  GstElementClass element_class;
+
+  gboolean (*start) (GstBaseVideoCodec *codec);
+  gboolean (*stop) (GstBaseVideoCodec *codec);
+  gboolean (*reset) (GstBaseVideoCodec *codec);
+  GstFlowReturn (*parse_data) (GstBaseVideoCodec *codec, gboolean at_eos);
+  int (*scan_for_sync) (GstAdapter *adapter, gboolean at_eos,
+      int offset, int n);
+  GstFlowReturn (*shape_output) (GstBaseVideoCodec *codec, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoCodec *codec);
+
+};
+
+GType gst_base_video_codec_get_type (void);
+
+#if 0
+guint64 gst_base_video_codec_get_timestamp (GstBaseVideoCodec *codec,
+    int picture_number);
+#endif
+
+GstVideoFrame * gst_base_video_codec_new_frame (GstBaseVideoCodec *base_video_codec);
+void gst_base_video_codec_free_frame (GstVideoFrame *frame);
+
+
+G_END_DECLS
+
+#endif
+
diff -Naur gst-libs/gst/video/gstbasevideodecoder.c gst-libs/gst/video/gstbasevideodecoder.c
--- gst-libs/gst/video/gstbasevideodecoder.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideodecoder.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,1160 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideodecoder.h"
+
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+static void gst_base_video_decoder_finalize (GObject * object);
+
+static gboolean gst_base_video_decoder_sink_setcaps (GstPad * pad,
+    GstCaps * caps);
+static gboolean gst_base_video_decoder_sink_event (GstPad * pad,
+    GstEvent * event);
+static gboolean gst_base_video_decoder_src_event (GstPad * pad,
+    GstEvent * event);
+static GstFlowReturn gst_base_video_decoder_chain (GstPad * pad,
+    GstBuffer * buf);
+static gboolean gst_base_video_decoder_sink_query (GstPad * pad,
+    GstQuery * query);
+static GstStateChangeReturn gst_base_video_decoder_change_state (GstElement *
+    element, GstStateChange transition);
+static const GstQueryType *gst_base_video_decoder_get_query_types (GstPad *
+    pad);
+static gboolean gst_base_video_decoder_src_query (GstPad * pad,
+    GstQuery * query);
+static gboolean gst_base_video_decoder_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value, GstFormat * dest_format,
+    gint64 * dest_value);
+static void gst_base_video_decoder_reset (GstBaseVideoDecoder *
+    base_video_decoder);
+
+static guint64
+gst_base_video_decoder_get_timestamp (GstBaseVideoDecoder * base_video_decoder,
+    int picture_number);
+static guint64
+gst_base_video_decoder_get_field_timestamp (GstBaseVideoDecoder *
+    base_video_decoder, int field_offset);
+static GstVideoFrame *gst_base_video_decoder_new_frame (GstBaseVideoDecoder *
+    base_video_decoder);
+static void gst_base_video_decoder_free_frame (GstVideoFrame * frame);
+
+GST_BOILERPLATE (GstBaseVideoDecoder, gst_base_video_decoder,
+    GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC);
+
+static void
+gst_base_video_decoder_base_init (gpointer g_class)
+{
+
+}
+
+static void
+gst_base_video_decoder_class_init (GstBaseVideoDecoderClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_decoder_finalize;
+
+  gstelement_class->change_state = gst_base_video_decoder_change_state;
+
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+gst_base_video_decoder_init (GstBaseVideoDecoder * base_video_decoder,
+    GstBaseVideoDecoderClass * klass)
+{
+  GstPad *pad;
+
+  GST_DEBUG ("gst_base_video_decoder_init");
+
+  pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_decoder);
+
+  gst_pad_set_chain_function (pad, gst_base_video_decoder_chain);
+  gst_pad_set_event_function (pad, gst_base_video_decoder_sink_event);
+  gst_pad_set_setcaps_function (pad, gst_base_video_decoder_sink_setcaps);
+  gst_pad_set_query_function (pad, gst_base_video_decoder_sink_query);
+
+  pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder);
+
+  gst_pad_set_event_function (pad, gst_base_video_decoder_src_event);
+  gst_pad_set_query_type_function (pad, gst_base_video_decoder_get_query_types);
+  gst_pad_set_query_function (pad, gst_base_video_decoder_src_query);
+
+  base_video_decoder->input_adapter = gst_adapter_new ();
+  base_video_decoder->output_adapter = gst_adapter_new ();
+
+  gst_segment_init (&base_video_decoder->state.segment, GST_FORMAT_TIME);
+  gst_base_video_decoder_reset (base_video_decoder);
+
+  base_video_decoder->current_frame =
+      gst_base_video_decoder_new_frame (base_video_decoder);
+
+  base_video_decoder->sink_clipping = TRUE;
+}
+
+static gboolean
+gst_base_video_decoder_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstStructure *structure;
+  const GValue *codec_data;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG ("setcaps %" GST_PTR_FORMAT, caps);
+
+  if (base_video_decoder->codec_data) {
+    gst_buffer_unref (base_video_decoder->codec_data);
+    base_video_decoder->codec_data = NULL;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+
+  codec_data = gst_structure_get_value (structure, "codec_data");
+  if (codec_data && G_VALUE_TYPE (codec_data) == GST_TYPE_BUFFER) {
+    base_video_decoder->codec_data = gst_value_get_buffer (codec_data);
+  }
+
+  if (base_video_decoder_class->start) {
+    base_video_decoder_class->start (base_video_decoder);
+  }
+
+  g_object_unref (base_video_decoder);
+
+  return TRUE;
+}
+
+static void
+gst_base_video_decoder_finalize (GObject * object)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_DECODER (object));
+  base_video_decoder = GST_BASE_VIDEO_DECODER (object);
+  base_video_decoder_class = GST_BASE_VIDEO_DECODER_GET_CLASS (object);
+
+  gst_base_video_decoder_reset (base_video_decoder);
+
+  GST_DEBUG_OBJECT (object, "finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_base_video_decoder_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  gboolean ret = FALSE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+    {
+      GstVideoFrame *frame;
+
+      frame = g_malloc0 (sizeof (GstVideoFrame));
+      frame->presentation_frame_number =
+          base_video_decoder->presentation_frame_number;
+      frame->presentation_duration = 0;
+      base_video_decoder->presentation_frame_number++;
+
+      base_video_decoder->frames =
+          g_list_append (base_video_decoder->frames, frame);
+      if (base_video_decoder_class->finish) {
+        base_video_decoder_class->finish (base_video_decoder, frame);
+      }
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+          event);
+    }
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      double rate;
+      double applied_rate;
+      GstFormat format;
+      gint64 start;
+      gint64 stop;
+      gint64 position;
+
+      gst_event_parse_new_segment_full (event, &update, &rate,
+          &applied_rate, &format, &start, &stop, &position);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      GST_DEBUG ("new segment %lld %lld", start, position);
+
+      gst_segment_set_newsegment_full (&base_video_decoder->state.segment,
+          update, rate, applied_rate, format, start, stop, position);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+          event);
+    }
+      break;
+    default:
+      /* FIXME this changes the order of events */
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+          event);
+      break;
+  }
+
+done:
+  gst_object_unref (base_video_decoder);
+  return ret;
+
+newseg_wrong_format:
+  {
+    GST_DEBUG_OBJECT (base_video_decoder, "received non TIME newsegment");
+    gst_event_unref (event);
+    goto done;
+  }
+}
+
+static gboolean
+gst_base_video_decoder_src_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  gboolean res = FALSE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstFormat format, tformat;
+      gdouble rate;
+      GstEvent *real_seek;
+      GstSeekFlags flags;
+      GstSeekType cur_type, stop_type;
+      gint64 cur, stop;
+      gint64 tcur, tstop;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
+          &cur, &stop_type, &stop);
+      gst_event_unref (event);
+
+      tformat = GST_FORMAT_TIME;
+      res =
+          gst_base_video_decoder_src_convert (pad, format, cur, &tformat,
+          &tcur);
+      if (!res)
+        goto convert_error;
+      res =
+          gst_base_video_decoder_src_convert (pad, format, stop, &tformat,
+          &tstop);
+      if (!res)
+        goto convert_error;
+
+      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+          flags, cur_type, tcur, stop_type, tstop);
+
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+          (base_video_decoder), real_seek);
+
+      break;
+    }
+    case GST_EVENT_QOS:
+    {
+      gdouble proportion;
+      GstClockTimeDiff diff;
+      GstClockTime timestamp;
+
+      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
+
+      GST_OBJECT_LOCK (base_video_decoder);
+      base_video_decoder->proportion = proportion;
+      base_video_decoder->earliest_time = timestamp + diff;
+      GST_OBJECT_UNLOCK (base_video_decoder);
+
+      GST_DEBUG_OBJECT (base_video_decoder,
+          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT ", %g",
+          GST_TIME_ARGS (timestamp), diff, proportion);
+
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+          (base_video_decoder), event);
+      break;
+    }
+    default:
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD
+          (base_video_decoder), event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_decoder);
+  return res;
+
+convert_error:
+  GST_DEBUG_OBJECT (base_video_decoder, "could not convert format");
+  goto done;
+}
+
+
+#if 0
+static gboolean
+gst_base_video_decoder_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoDecoder *enc;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  switch (src_format) {
+    case GST_FORMAT_BYTES:
+      switch (*dest_format) {
+#if 0
+        case GST_FORMAT_DEFAULT:
+          *dest_value = gst_util_uint64_scale_int (src_value, 1,
+              enc->bytes_per_picture);
+          break;
+#endif
+        case GST_FORMAT_TIME:
+          /* seems like a rather silly conversion, implement me if you like */
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value,
+              GST_SECOND * enc->fps_d, enc->fps_n);
+          break;
+#if 0
+        case GST_FORMAT_BYTES:
+          *dest_value = gst_util_uint64_scale_int (src_value,
+              enc->bytes_per_picture, 1);
+          break;
+#endif
+        default:
+          res = FALSE;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+}
+#endif
+
+static gboolean
+gst_base_video_decoder_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoDecoder *enc;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a encoding state */
+
+  GST_DEBUG ("src convert");
+  switch (src_format) {
+#if 0
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+              enc->fps_d * GST_SECOND, enc->fps_n);
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+        {
+          *dest_value = gst_util_uint64_scale (src_value,
+              enc->fps_n, enc->fps_d * GST_SECOND);
+          break;
+        }
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+#endif
+    default:
+      res = FALSE;
+      break;
+  }
+
+  gst_object_unref (enc);
+
+  return res;
+}
+
+static const GstQueryType *
+gst_base_video_decoder_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_CONVERT,
+    0
+  };
+
+  return query_types;
+}
+
+static gboolean
+gst_base_video_decoder_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoDecoder *enc;
+  gboolean res;
+
+  enc = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  switch GST_QUERY_TYPE
+    (query) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res =
+          gst_base_video_decoder_src_convert (pad, src_fmt, src_val, &dest_fmt,
+          &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+    }
+  gst_object_unref (enc);
+  return res;
+
+error:
+  GST_DEBUG_OBJECT (enc, "query failed");
+  gst_object_unref (enc);
+  return res;
+}
+
+static gboolean
+gst_base_video_decoder_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  gboolean res = FALSE;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+
+  GST_DEBUG_OBJECT (base_video_decoder, "sink query fps=%d/%d",
+      base_video_decoder->state.fps_n, base_video_decoder->state.fps_d);
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_rawvideo_convert (&base_video_decoder->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_video_decoder);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_video_decoder, "query failed");
+  goto done;
+}
+
+
+#if 0
+static gboolean
+gst_pad_is_negotiated (GstPad * pad)
+{
+  GstCaps *caps;
+
+  g_return_val_if_fail (pad != NULL, FALSE);
+
+  caps = gst_pad_get_negotiated_caps (pad);
+  if (caps) {
+    gst_caps_unref (caps);
+    return TRUE;
+  }
+
+  return FALSE;
+}
+#endif
+
+static void
+gst_base_video_decoder_reset (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GList *g;
+
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG ("reset");
+
+  base_video_decoder->started = FALSE;
+
+  base_video_decoder->discont = TRUE;
+  base_video_decoder->have_sync = FALSE;
+
+  base_video_decoder->timestamp_offset = GST_CLOCK_TIME_NONE;
+  base_video_decoder->system_frame_number = 0;
+  base_video_decoder->presentation_frame_number = 0;
+  base_video_decoder->last_sink_timestamp = GST_CLOCK_TIME_NONE;
+  base_video_decoder->last_sink_offset_end = GST_CLOCK_TIME_NONE;
+  base_video_decoder->base_picture_number = 0;
+  base_video_decoder->last_timestamp = GST_CLOCK_TIME_NONE;
+
+  base_video_decoder->offset = 0;
+
+  if (base_video_decoder->caps) {
+    gst_caps_unref (base_video_decoder->caps);
+    base_video_decoder->caps = NULL;
+  }
+
+  if (base_video_decoder->current_frame) {
+    gst_base_video_decoder_free_frame (base_video_decoder->current_frame);
+    base_video_decoder->current_frame = NULL;
+  }
+
+  base_video_decoder->have_src_caps = FALSE;
+
+  for (g = g_list_first (base_video_decoder->frames); g; g = g_list_next (g)) {
+    GstVideoFrame *frame = g->data;
+    gst_base_video_decoder_free_frame (frame);
+  }
+  g_list_free (base_video_decoder->frames);
+  base_video_decoder->frames = NULL;
+
+  if (base_video_decoder_class->reset) {
+    base_video_decoder_class->reset (base_video_decoder);
+  }
+}
+
+static GstFlowReturn
+gst_base_video_decoder_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *klass;
+  GstBuffer *buffer;
+  GstFlowReturn ret;
+
+  GST_DEBUG ("chain %lld", GST_BUFFER_TIMESTAMP (buf));
+
+#if 0
+  /* requiring the pad to be negotiated makes it impossible to use
+   * oggdemux or filesrc ! decoder */
+  if (!gst_pad_is_negotiated (pad)) {
+    GST_DEBUG ("not negotiated");
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+#endif
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (gst_pad_get_parent (pad));
+  klass = GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG_OBJECT (base_video_decoder, "chain");
+
+  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
+    GST_DEBUG_OBJECT (base_video_decoder, "received DISCONT buffer");
+    if (base_video_decoder->started) {
+      gst_base_video_decoder_reset (base_video_decoder);
+    }
+  }
+
+  if (!base_video_decoder->started) {
+    klass->start (base_video_decoder);
+    base_video_decoder->started = TRUE;
+  }
+
+  if (GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
+    GST_DEBUG ("timestamp %lld offset %lld", GST_BUFFER_TIMESTAMP (buf),
+        base_video_decoder->offset);
+    base_video_decoder->last_sink_timestamp = GST_BUFFER_TIMESTAMP (buf);
+  }
+  if (GST_BUFFER_OFFSET_END (buf) != -1) {
+    GST_DEBUG ("gp %lld", GST_BUFFER_OFFSET_END (buf));
+    base_video_decoder->last_sink_offset_end = GST_BUFFER_OFFSET_END (buf);
+  }
+  base_video_decoder->offset += GST_BUFFER_SIZE (buf);
+
+#if 0
+  if (base_video_decoder->timestamp_offset == GST_CLOCK_TIME_NONE &&
+      GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
+    GST_DEBUG ("got new offset %lld", GST_BUFFER_TIMESTAMP (buf));
+    base_video_decoder->timestamp_offset = GST_BUFFER_TIMESTAMP (buf);
+  }
+#endif
+
+  if (base_video_decoder->current_frame == NULL) {
+    base_video_decoder->current_frame =
+        gst_base_video_decoder_new_frame (base_video_decoder);
+  }
+
+  gst_adapter_push (base_video_decoder->input_adapter, buf);
+
+  if (!base_video_decoder->have_sync) {
+    int n, m;
+
+    GST_DEBUG ("no sync, scanning");
+
+    n = gst_adapter_available (base_video_decoder->input_adapter);
+    m = klass->scan_for_sync (base_video_decoder, FALSE, 0, n);
+
+    gst_adapter_flush (base_video_decoder->input_adapter, m);
+
+    if (m < n) {
+      GST_DEBUG ("found possible sync after %d bytes (of %d)", m, n);
+
+      /* this is only "maybe" sync */
+      base_video_decoder->have_sync = TRUE;
+    }
+
+    if (!base_video_decoder->have_sync) {
+      gst_object_unref (base_video_decoder);
+      return GST_FLOW_OK;
+    }
+  }
+
+  buffer = gst_adapter_get_buffer (base_video_decoder->input_adapter);
+
+  base_video_decoder->buffer_timestamp = GST_BUFFER_TIMESTAMP (buffer);
+  gst_buffer_unref (buffer);
+
+  do {
+    ret = klass->parse_data (base_video_decoder, FALSE);
+  } while (ret == GST_FLOW_OK);
+
+  if (ret == GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA) {
+    gst_object_unref (base_video_decoder);
+    return GST_FLOW_OK;
+  }
+
+  gst_object_unref (base_video_decoder);
+  return ret;
+}
+
+static GstStateChangeReturn
+gst_base_video_decoder_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoDecoder *base_video_decoder;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstStateChangeReturn ret;
+
+  base_video_decoder = GST_BASE_VIDEO_DECODER (element);
+  base_video_decoder_class = GST_BASE_VIDEO_DECODER_GET_CLASS (element);
+
+  switch (transition) {
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      if (base_video_decoder_class->stop) {
+        base_video_decoder_class->stop (base_video_decoder);
+      }
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void
+gst_base_video_decoder_free_frame (GstVideoFrame * frame)
+{
+  g_return_if_fail (frame != NULL);
+
+  if (frame->sink_buffer) {
+    gst_buffer_unref (frame->sink_buffer);
+  }
+#if 0
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+#endif
+
+  g_free (frame);
+}
+
+static GstVideoFrame *
+gst_base_video_decoder_new_frame (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstVideoFrame *frame;
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+
+  frame->system_frame_number = base_video_decoder->system_frame_number;
+  base_video_decoder->system_frame_number++;
+
+  frame->decode_frame_number = frame->system_frame_number -
+      base_video_decoder->reorder_depth;
+
+  frame->decode_timestamp = -1;
+  frame->presentation_timestamp = -1;
+  frame->presentation_duration = -1;
+  frame->n_fields = 2;
+
+  return frame;
+}
+
+GstFlowReturn
+gst_base_video_decoder_finish_frame (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoFrame * frame)
+{
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstBuffer *src_buffer;
+
+  GST_DEBUG ("finish frame");
+
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  GST_DEBUG ("finish frame sync=%d pts=%lld", frame->is_sync_point,
+      frame->presentation_timestamp);
+
+  if (frame->is_sync_point) {
+    if (GST_CLOCK_TIME_IS_VALID (frame->presentation_timestamp)) {
+      if (frame->presentation_timestamp != base_video_decoder->timestamp_offset) {
+        GST_DEBUG ("sync timestamp %lld diff %lld",
+            frame->presentation_timestamp,
+            frame->presentation_timestamp -
+            base_video_decoder->state.segment.start);
+        base_video_decoder->timestamp_offset = frame->presentation_timestamp;
+        base_video_decoder->field_index = 0;
+      } else {
+        /* This case is for one initial timestamp and no others, e.g.,
+         * filesrc ! decoder ! xvimagesink */
+        GST_WARNING ("sync timestamp didn't change, ignoring");
+        frame->presentation_timestamp = GST_CLOCK_TIME_NONE;
+      }
+    } else {
+      GST_WARNING ("sync point doesn't have timestamp");
+      if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->timestamp_offset)) {
+        GST_ERROR ("No base timestamp.  Assuming frames start at 0");
+        base_video_decoder->timestamp_offset = 0;
+        base_video_decoder->field_index = 0;
+      }
+    }
+  }
+  frame->field_index = base_video_decoder->field_index;
+  base_video_decoder->field_index += frame->n_fields;
+
+  if (frame->presentation_timestamp == GST_CLOCK_TIME_NONE) {
+    frame->presentation_timestamp =
+        gst_base_video_decoder_get_field_timestamp (base_video_decoder,
+        frame->field_index);
+    frame->presentation_duration = GST_CLOCK_TIME_NONE;
+    frame->decode_timestamp =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->decode_frame_number);
+  }
+  if (frame->presentation_duration == GST_CLOCK_TIME_NONE) {
+    frame->presentation_duration =
+        gst_base_video_decoder_get_field_timestamp (base_video_decoder,
+        frame->field_index + frame->n_fields) - frame->presentation_timestamp;
+  }
+
+  if (GST_CLOCK_TIME_IS_VALID (base_video_decoder->last_timestamp)) {
+    if (frame->presentation_timestamp < base_video_decoder->last_timestamp) {
+      GST_WARNING ("decreasing timestamp (%lld < %lld)",
+          frame->presentation_timestamp, base_video_decoder->last_timestamp);
+    }
+  }
+  base_video_decoder->last_timestamp = frame->presentation_timestamp;
+
+  GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  if (base_video_decoder->state.interlaced) {
+#ifndef GST_VIDEO_BUFFER_TFF
+#define GST_VIDEO_BUFFER_TFF (GST_MINI_OBJECT_FLAG_LAST << 5)
+#endif
+#ifndef GST_VIDEO_BUFFER_RFF
+#define GST_VIDEO_BUFFER_RFF (GST_MINI_OBJECT_FLAG_LAST << 6)
+#endif
+#ifndef GST_VIDEO_BUFFER_ONEFIELD
+#define GST_VIDEO_BUFFER_ONEFIELD (GST_MINI_OBJECT_FLAG_LAST << 7)
+#endif
+    int tff = base_video_decoder->state.top_field_first;
+
+    if (frame->field_index & 1) {
+      tff ^= 1;
+    }
+    if (tff) {
+      GST_BUFFER_FLAG_SET (frame->src_buffer, GST_VIDEO_BUFFER_TFF);
+    } else {
+      GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_TFF);
+    }
+    GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_RFF);
+    GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_ONEFIELD);
+    if (frame->n_fields == 3) {
+      GST_BUFFER_FLAG_SET (frame->src_buffer, GST_VIDEO_BUFFER_RFF);
+    } else if (frame->n_fields == 1) {
+      GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_VIDEO_BUFFER_ONEFIELD);
+    }
+  }
+
+  GST_BUFFER_TIMESTAMP (frame->src_buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (frame->src_buffer) = frame->presentation_duration;
+  GST_BUFFER_OFFSET (frame->src_buffer) = -1;
+  GST_BUFFER_OFFSET_END (frame->src_buffer) = -1;
+
+  GST_DEBUG ("pushing frame %lld", frame->presentation_timestamp);
+
+  base_video_decoder->frames =
+      g_list_remove (base_video_decoder->frames, frame);
+
+  gst_base_video_decoder_set_src_caps (base_video_decoder);
+
+  src_buffer = frame->src_buffer;
+
+  g_free (frame);
+
+  if (base_video_decoder->sink_clipping) {
+    gint64 start = GST_BUFFER_TIMESTAMP (src_buffer);
+    gint64 stop = GST_BUFFER_TIMESTAMP (src_buffer) +
+        GST_BUFFER_DURATION (src_buffer);
+
+    if (gst_segment_clip (&base_video_decoder->state.segment, GST_FORMAT_TIME,
+            start, stop, &start, &stop)) {
+      GST_BUFFER_TIMESTAMP (src_buffer) = start;
+      GST_BUFFER_DURATION (src_buffer) = stop - start;
+    } else {
+      GST_DEBUG ("dropping buffer outside segment");
+      gst_buffer_unref (src_buffer);
+      return GST_FLOW_OK;
+    }
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+      src_buffer);
+}
+
+int
+gst_base_video_decoder_get_height (GstBaseVideoDecoder * base_video_decoder)
+{
+  return base_video_decoder->state.height;
+}
+
+int
+gst_base_video_decoder_get_width (GstBaseVideoDecoder * base_video_decoder)
+{
+  return base_video_decoder->state.width;
+}
+
+GstFlowReturn
+gst_base_video_decoder_end_of_stream (GstBaseVideoDecoder * base_video_decoder,
+    GstBuffer * buffer)
+{
+
+  if (base_video_decoder->frames) {
+    GST_DEBUG ("EOS with frames left over");
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder),
+      buffer);
+}
+
+void
+gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder * base_video_decoder,
+    int n_bytes)
+{
+  GstBuffer *buf;
+
+  GST_DEBUG ("add to frame");
+
+#if 0
+  if (gst_adapter_available (base_video_decoder->output_adapter) == 0) {
+    GstBuffer *buffer;
+
+    buffer =
+        gst_adapter_get_orig_buffer_at_offset
+        (base_video_decoder->input_adapter, 0);
+    if (buffer) {
+      base_video_decoder->current_frame->presentation_timestamp =
+          GST_BUFFER_TIMESTAMP (buffer);
+      gst_buffer_unref (buffer);
+    }
+  }
+#endif
+
+  if (n_bytes == 0)
+    return;
+
+  buf = gst_adapter_take_buffer (base_video_decoder->input_adapter, n_bytes);
+
+  gst_adapter_push (base_video_decoder->output_adapter, buf);
+}
+
+static guint64
+gst_base_video_decoder_get_timestamp (GstBaseVideoDecoder * base_video_decoder,
+    int picture_number)
+{
+  if (base_video_decoder->state.fps_d == 0) {
+    return -1;
+  }
+  if (picture_number < base_video_decoder->base_picture_number) {
+    return base_video_decoder->timestamp_offset -
+        (gint64) gst_util_uint64_scale (base_video_decoder->base_picture_number
+        - picture_number, base_video_decoder->state.fps_d * GST_SECOND,
+        base_video_decoder->state.fps_n);
+  } else {
+    return base_video_decoder->timestamp_offset +
+        gst_util_uint64_scale (picture_number -
+        base_video_decoder->base_picture_number,
+        base_video_decoder->state.fps_d * GST_SECOND,
+        base_video_decoder->state.fps_n);
+  }
+}
+
+static guint64
+gst_base_video_decoder_get_field_timestamp (GstBaseVideoDecoder *
+    base_video_decoder, int field_offset)
+{
+  if (base_video_decoder->state.fps_d == 0) {
+    return GST_CLOCK_TIME_NONE;
+  }
+  if (field_offset < 0) {
+    GST_WARNING ("field offset < 0");
+    return GST_CLOCK_TIME_NONE;
+  }
+  return base_video_decoder->timestamp_offset +
+      gst_util_uint64_scale (field_offset,
+      base_video_decoder->state.fps_d * GST_SECOND,
+      base_video_decoder->state.fps_n * 2);
+}
+
+
+GstFlowReturn
+gst_base_video_decoder_have_frame (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstVideoFrame *frame = base_video_decoder->current_frame;
+  GstBuffer *buffer;
+  GstBaseVideoDecoderClass *base_video_decoder_class;
+  GstFlowReturn ret = GST_FLOW_OK;
+  int n_available;
+
+  GST_DEBUG ("have_frame");
+
+  base_video_decoder_class =
+      GST_BASE_VIDEO_DECODER_GET_CLASS (base_video_decoder);
+
+  n_available = gst_adapter_available (base_video_decoder->output_adapter);
+  if (n_available) {
+    buffer = gst_adapter_take_buffer (base_video_decoder->output_adapter,
+        n_available);
+  } else {
+    buffer = gst_buffer_new_and_alloc (0);
+  }
+
+  frame->distance_from_sync = base_video_decoder->distance_from_sync;
+  base_video_decoder->distance_from_sync++;
+
+#if 0
+  if (frame->presentation_timestamp == GST_CLOCK_TIME_NONE) {
+    frame->presentation_timestamp =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->presentation_frame_number);
+    frame->presentation_duration =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->presentation_frame_number + 1) - frame->presentation_timestamp;
+    frame->decode_timestamp =
+        gst_base_video_decoder_get_timestamp (base_video_decoder,
+        frame->decode_frame_number);
+  }
+#endif
+
+#if 0
+  GST_BUFFER_TIMESTAMP (buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (buffer) = frame->presentation_duration;
+  if (frame->decode_frame_number < 0) {
+    GST_BUFFER_OFFSET (buffer) = 0;
+  } else {
+    GST_BUFFER_OFFSET (buffer) = frame->decode_timestamp;
+  }
+  GST_BUFFER_OFFSET_END (buffer) = GST_CLOCK_TIME_NONE;
+#endif
+
+  GST_DEBUG ("pts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (frame->presentation_timestamp));
+  GST_DEBUG ("dts %" GST_TIME_FORMAT, GST_TIME_ARGS (frame->decode_timestamp));
+  GST_DEBUG ("dist %d", frame->distance_from_sync);
+
+  if (frame->is_sync_point) {
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+  if (base_video_decoder->discont) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    base_video_decoder->discont = FALSE;
+  }
+
+  frame->sink_buffer = buffer;
+
+  base_video_decoder->frames = g_list_append (base_video_decoder->frames,
+      frame);
+
+  /* do something with frame */
+  ret = base_video_decoder_class->handle_frame (base_video_decoder, frame);
+  if (!GST_FLOW_IS_SUCCESS (ret)) {
+    GST_DEBUG ("flow error!");
+  }
+
+  /* create new frame */
+  base_video_decoder->current_frame =
+      gst_base_video_decoder_new_frame (base_video_decoder);
+
+  return ret;
+}
+
+GstVideoState *
+gst_base_video_decoder_get_state (GstBaseVideoDecoder * base_video_decoder)
+{
+  return &base_video_decoder->state;
+
+}
+
+void
+gst_base_video_decoder_set_state (GstBaseVideoDecoder * base_video_decoder,
+    GstVideoState * state)
+{
+  memcpy (&base_video_decoder->state, state, sizeof (*state));
+
+}
+
+void
+gst_base_video_decoder_lost_sync (GstBaseVideoDecoder * base_video_decoder)
+{
+  g_return_if_fail (GST_IS_BASE_VIDEO_DECODER (base_video_decoder));
+
+  GST_DEBUG ("lost_sync");
+
+  if (gst_adapter_available (base_video_decoder->input_adapter) >= 1) {
+    gst_adapter_flush (base_video_decoder->input_adapter, 1);
+  }
+
+  base_video_decoder->have_sync = FALSE;
+}
+
+void
+gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder * base_video_decoder)
+{
+  GST_DEBUG ("set_sync_point");
+
+  base_video_decoder->current_frame->is_sync_point = TRUE;
+  base_video_decoder->distance_from_sync = 0;
+
+  base_video_decoder->current_frame->presentation_timestamp =
+      base_video_decoder->last_sink_timestamp;
+
+
+}
+
+GstVideoFrame *
+gst_base_video_decoder_get_frame (GstBaseVideoDecoder * base_video_decoder,
+    int frame_number)
+{
+  GList *g;
+
+  for (g = g_list_first (base_video_decoder->frames); g; g = g_list_next (g)) {
+    GstVideoFrame *frame = g->data;
+
+    if (frame->system_frame_number == frame_number) {
+      return frame;
+    }
+  }
+
+  return NULL;
+}
+
+void
+gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder * base_video_decoder)
+{
+  GstCaps *caps;
+  GstVideoState *state = &base_video_decoder->state;
+
+  if (base_video_decoder->have_src_caps)
+    return;
+
+  caps = gst_video_format_new_caps (state->format,
+      state->width, state->height,
+      state->fps_n, state->fps_d, state->par_n, state->par_d);
+  gst_caps_set_simple (caps, "interlaced",
+      G_TYPE_BOOLEAN, state->interlaced, NULL);
+
+  GST_DEBUG ("setting caps %" GST_PTR_FORMAT, caps);
+
+  gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_decoder), caps);
+
+  base_video_decoder->have_src_caps = TRUE;
+}
diff -Naur gst-libs/gst/video/gstbasevideodecoder.h gst-libs/gst/video/gstbasevideodecoder.h
--- gst-libs/gst/video/gstbasevideodecoder.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideodecoder.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,160 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_DECODER_H_
+#define _GST_BASE_VIDEO_DECODER_H_
+
+#include <gst/video/gstbasevideocodec.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_DECODER \
+  (gst_base_video_decoder_get_type())
+#define GST_BASE_VIDEO_DECODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_DECODER,GstBaseVideoDecoder))
+#define GST_BASE_VIDEO_DECODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_DECODER,GstBaseVideoDecoderClass))
+#define GST_BASE_VIDEO_DECODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_DECODER,GstBaseVideoDecoderClass))
+#define GST_IS_BASE_VIDEO_DECODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_DECODER))
+#define GST_IS_BASE_VIDEO_DECODER_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_DECODER))
+
+/**
+ * GST_BASE_VIDEO_DECODER_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_DECODER_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_DECODER_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_DECODER_SRC_NAME     "src"
+
+/**
+ *  * GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA:
+ *   *
+ *    */
+#define GST_BASE_VIDEO_DECODER_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
+
+
+typedef struct _GstBaseVideoDecoder GstBaseVideoDecoder;
+typedef struct _GstBaseVideoDecoderClass GstBaseVideoDecoderClass;
+
+struct _GstBaseVideoDecoder
+{
+  GstBaseVideoCodec base_video_codec;
+
+  /*< private >*/
+  GstAdapter *input_adapter;
+  GstAdapter *output_adapter;
+
+  GList *frames;
+
+  gboolean have_sync;
+  gboolean discont;
+  gboolean started;
+
+  GstVideoState state;
+
+  gboolean sink_clipping;
+
+  guint64 presentation_frame_number;
+  guint64 system_frame_number;
+
+  GstCaps *caps;
+  gboolean have_src_caps;
+
+  GstVideoFrame *current_frame;
+
+  int distance_from_sync;
+  int reorder_depth;
+
+  GstClockTime buffer_timestamp;
+
+  GstClockTime timestamp_offset;
+
+  gdouble proportion;
+  GstClockTime earliest_time;
+
+  GstBuffer *codec_data;
+
+  guint64 offset;
+  GstClockTime last_timestamp;
+
+  GstClockTime last_sink_timestamp;
+  GstClockTime last_sink_offset_end;
+  guint64 base_picture_number;
+
+  int field_index;
+};
+
+struct _GstBaseVideoDecoderClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
+
+  gboolean (*set_format) (GstBaseVideoDecoder *coder, GstVideoFormat,
+      int width, int height, int fps_n, int fps_d,
+      int par_n, int par_d);
+  gboolean (*start) (GstBaseVideoDecoder *coder);
+  gboolean (*stop) (GstBaseVideoDecoder *coder);
+  gboolean (*reset) (GstBaseVideoDecoder *coder);
+  int (*scan_for_sync) (GstBaseVideoDecoder *decoder, gboolean at_eos,
+      int offset, int n);
+  GstFlowReturn (*parse_data) (GstBaseVideoDecoder *decoder, gboolean at_eos);
+  gboolean (*finish) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*handle_frame) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*shape_output) (GstBaseVideoDecoder *coder, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoDecoder *coder);
+
+};
+
+GType gst_base_video_decoder_get_type (void);
+
+int gst_base_video_decoder_get_width (GstBaseVideoDecoder *coder);
+int gst_base_video_decoder_get_height (GstBaseVideoDecoder *coder);
+
+guint64 gst_base_video_decoder_get_timestamp_offset (GstBaseVideoDecoder *coder);
+
+GstVideoFrame *gst_base_video_decoder_get_frame (GstBaseVideoDecoder *coder,
+    int frame_number);
+void gst_base_video_decoder_add_to_frame (GstBaseVideoDecoder *base_video_decoder,
+    int n_bytes);
+GstFlowReturn gst_base_video_decoder_finish_frame (GstBaseVideoDecoder *base_video_decoder,
+    GstVideoFrame *frame);
+GstFlowReturn gst_base_video_decoder_end_of_stream (GstBaseVideoDecoder *base_video_decoder,
+    GstBuffer *buffer);
+GstFlowReturn
+gst_base_video_decoder_have_frame (GstBaseVideoDecoder *base_video_decoder);
+GstVideoState * gst_base_video_decoder_get_state (GstBaseVideoDecoder *base_video_decoder);
+void gst_base_video_decoder_set_state (GstBaseVideoDecoder *base_video_decoder,
+    GstVideoState *state);
+void gst_base_video_decoder_lost_sync (GstBaseVideoDecoder *base_video_decoder);
+void gst_base_video_decoder_set_sync_point (GstBaseVideoDecoder *base_video_decoder);
+
+void gst_base_video_decoder_set_src_caps (GstBaseVideoDecoder *base_video_decoder);
+
+
+G_END_DECLS
+
+#endif
+
diff -Naur gst-libs/gst/video/gstbasevideoencoder.c gst-libs/gst/video/gstbasevideoencoder.c
--- gst-libs/gst/video/gstbasevideoencoder.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideoencoder.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,490 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideoencoder.h"
+#include "gstbasevideoutils.h"
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+static void gst_base_video_encoder_finalize (GObject * object);
+
+static gboolean gst_base_video_encoder_sink_setcaps (GstPad * pad,
+    GstCaps * caps);
+static gboolean gst_base_video_encoder_sink_event (GstPad * pad,
+    GstEvent * event);
+static GstFlowReturn gst_base_video_encoder_chain (GstPad * pad,
+    GstBuffer * buf);
+static GstStateChangeReturn gst_base_video_encoder_change_state (GstElement *
+    element, GstStateChange transition);
+static const GstQueryType *gst_base_video_encoder_get_query_types (GstPad *
+    pad);
+static gboolean gst_base_video_encoder_src_query (GstPad * pad,
+    GstQuery * query);
+
+
+GST_BOILERPLATE (GstBaseVideoEncoder, gst_base_video_encoder, GstBaseVideoCodec,
+    GST_TYPE_BASE_VIDEO_CODEC);
+
+static void
+gst_base_video_encoder_base_init (gpointer g_class)
+{
+
+}
+
+static void
+gst_base_video_encoder_class_init (GstBaseVideoEncoderClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_encoder_finalize;
+
+  gstelement_class->change_state = gst_base_video_encoder_change_state;
+
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+gst_base_video_encoder_init (GstBaseVideoEncoder * base_video_encoder,
+    GstBaseVideoEncoderClass * klass)
+{
+  GstPad *pad;
+
+  GST_DEBUG ("gst_base_video_encoder_init");
+
+  pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_encoder);
+
+  gst_pad_set_chain_function (pad, gst_base_video_encoder_chain);
+  gst_pad_set_event_function (pad, gst_base_video_encoder_sink_event);
+  gst_pad_set_setcaps_function (pad, gst_base_video_encoder_sink_setcaps);
+
+  pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder);
+
+  gst_pad_set_query_type_function (pad, gst_base_video_encoder_get_query_types);
+  gst_pad_set_query_function (pad, gst_base_video_encoder_src_query);
+}
+
+static gboolean
+gst_base_video_encoder_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  base_video_encoder_class =
+      GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  GST_DEBUG ("setcaps");
+
+  gst_base_video_state_from_caps (&base_video_encoder->state, caps);
+
+  base_video_encoder_class->set_format (base_video_encoder,
+      &base_video_encoder->state);
+
+  base_video_encoder_class->start (base_video_encoder);
+
+  g_object_unref (base_video_encoder);
+
+  return TRUE;
+}
+
+static void
+gst_base_video_encoder_finalize (GObject * object)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_ENCODER (object));
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (object);
+  base_video_encoder_class = GST_BASE_VIDEO_ENCODER_GET_CLASS (object);
+
+  GST_DEBUG ("finalize");
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_base_video_encoder_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+  gboolean ret = FALSE;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  base_video_encoder_class =
+      GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+    {
+      GstVideoFrame *frame;
+
+      frame = g_malloc0 (sizeof (GstVideoFrame));
+      frame->presentation_frame_number =
+          base_video_encoder->presentation_frame_number;
+      frame->presentation_duration = 0;
+      frame->is_eos = TRUE;
+      base_video_encoder->presentation_frame_number++;
+
+      base_video_encoder->frames =
+          g_list_append (base_video_encoder->frames, frame);
+      base_video_encoder_class->finish (base_video_encoder, frame);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+          event);
+    }
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      double rate;
+      double applied_rate;
+      GstFormat format;
+      gint64 start;
+      gint64 stop;
+      gint64 position;
+
+      gst_event_parse_new_segment_full (event, &update, &rate,
+          &applied_rate, &format, &start, &stop, &position);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      GST_DEBUG ("new segment %lld %lld", start, position);
+
+      gst_segment_set_newsegment_full (&base_video_encoder->state.segment,
+          update, rate, applied_rate, format, start, stop, position);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+          event);
+    }
+      break;
+    default:
+      /* FIXME this changes the order of events */
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+          event);
+      break;
+  }
+
+done:
+  gst_object_unref (base_video_encoder);
+  return ret;
+
+newseg_wrong_format:
+  {
+    GST_DEBUG_OBJECT (base_video_encoder, "received non TIME newsegment");
+    gst_event_unref (event);
+    goto done;
+  }
+}
+
+static const GstQueryType *
+gst_base_video_encoder_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_CONVERT,
+    GST_QUERY_LATENCY,
+    0
+  };
+
+  return query_types;
+}
+
+static gboolean
+gst_base_video_encoder_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoEncoder *enc;
+  gboolean res;
+  GstPad *peerpad;
+
+  enc = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  peerpad = gst_pad_get_peer (GST_BASE_VIDEO_CODEC_SINK_PAD (enc));
+
+  switch GST_QUERY_TYPE
+    (query) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res =
+          gst_base_video_encoded_video_convert (&enc->state, src_fmt, src_val,
+          &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    case GST_QUERY_LATENCY:
+    {
+      gboolean live;
+      GstClockTime min_latency, max_latency;
+
+      res = gst_pad_query (peerpad, query);
+      if (res) {
+        gst_query_parse_latency (query, &live, &min_latency, &max_latency);
+
+        min_latency += enc->min_latency;
+        if (max_latency != GST_CLOCK_TIME_NONE) {
+          max_latency += enc->max_latency;
+        }
+
+        gst_query_set_latency (query, live, min_latency, max_latency);
+      }
+    }
+      break;
+    default:
+      res = gst_pad_query_default (pad, query);
+    }
+  gst_object_unref (peerpad);
+  gst_object_unref (enc);
+  return res;
+
+error:
+  GST_DEBUG_OBJECT (enc, "query failed");
+  gst_object_unref (peerpad);
+  gst_object_unref (enc);
+  return res;
+}
+
+static gboolean
+gst_pad_is_negotiated (GstPad * pad)
+{
+  GstCaps *caps;
+
+  g_return_val_if_fail (pad != NULL, FALSE);
+
+  caps = gst_pad_get_negotiated_caps (pad);
+  if (caps) {
+    gst_caps_unref (caps);
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
+static GstFlowReturn
+gst_base_video_encoder_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *klass;
+  GstVideoFrame *frame;
+
+  if (!gst_pad_is_negotiated (pad)) {
+    return GST_FLOW_NOT_NEGOTIATED;
+  }
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (gst_pad_get_parent (pad));
+  klass = GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  if (base_video_encoder->sink_clipping) {
+    gint64 start = GST_BUFFER_TIMESTAMP (buf);
+    gint64 stop = start + GST_BUFFER_DURATION (buf);
+    gint64 clip_start;
+    gint64 clip_stop;
+
+    if (!gst_segment_clip (&base_video_encoder->state.segment,
+            GST_FORMAT_TIME, start, stop, &clip_start, &clip_stop)) {
+      GST_DEBUG ("clipping to segment dropped frame");
+      goto done;
+    }
+  }
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+  frame->sink_buffer = buf;
+  frame->presentation_timestamp = GST_BUFFER_TIMESTAMP (buf);
+  frame->presentation_duration = GST_BUFFER_DURATION (buf);
+  frame->presentation_frame_number =
+      base_video_encoder->presentation_frame_number;
+  base_video_encoder->presentation_frame_number++;
+
+  base_video_encoder->frames =
+      g_list_append (base_video_encoder->frames, frame);
+
+  klass->handle_frame (base_video_encoder, frame);
+
+done:
+  g_object_unref (base_video_encoder);
+
+  return GST_FLOW_OK;
+}
+
+static GstStateChangeReturn
+gst_base_video_encoder_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoEncoder *base_video_encoder;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+  GstStateChangeReturn ret;
+
+  base_video_encoder = GST_BASE_VIDEO_ENCODER (element);
+  base_video_encoder_class = GST_BASE_VIDEO_ENCODER_GET_CLASS (element);
+
+  switch (transition) {
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      if (base_video_encoder_class->stop) {
+        base_video_encoder_class->stop (base_video_encoder);
+      }
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+GstFlowReturn
+gst_base_video_encoder_finish_frame (GstBaseVideoEncoder * base_video_encoder,
+    GstVideoFrame * frame)
+{
+  GstFlowReturn ret;
+  GstBaseVideoEncoderClass *base_video_encoder_class;
+
+  base_video_encoder_class =
+      GST_BASE_VIDEO_ENCODER_GET_CLASS (base_video_encoder);
+
+  frame->system_frame_number = base_video_encoder->system_frame_number;
+  base_video_encoder->system_frame_number++;
+
+  if (frame->is_sync_point) {
+    base_video_encoder->distance_from_sync = 0;
+    GST_BUFFER_FLAG_UNSET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (frame->src_buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  frame->distance_from_sync = base_video_encoder->distance_from_sync;
+  base_video_encoder->distance_from_sync++;
+
+  frame->decode_frame_number = frame->system_frame_number - 1;
+  if (frame->decode_frame_number < 0) {
+    frame->decode_timestamp = 0;
+  } else {
+    frame->decode_timestamp = gst_util_uint64_scale (frame->decode_frame_number,
+        GST_SECOND * base_video_encoder->state.fps_d,
+        base_video_encoder->state.fps_n);
+  }
+
+  GST_BUFFER_TIMESTAMP (frame->src_buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (frame->src_buffer) = frame->presentation_duration;
+  GST_BUFFER_OFFSET (frame->src_buffer) = frame->decode_timestamp;
+
+  base_video_encoder->frames =
+      g_list_remove (base_video_encoder->frames, frame);
+
+  if (!base_video_encoder->set_output_caps) {
+    GstCaps *caps;
+
+    if (base_video_encoder_class->get_caps) {
+      caps = base_video_encoder_class->get_caps (base_video_encoder);
+    } else {
+      caps = gst_caps_new_simple ("video/unknown", NULL);
+    }
+    base_video_encoder->caps = gst_caps_ref (caps);
+    gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder), caps);
+    base_video_encoder->set_output_caps = TRUE;
+  }
+
+  if (base_video_encoder_class->shape_output) {
+    ret = base_video_encoder_class->shape_output (base_video_encoder, frame);
+  } else {
+    ret =
+        gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+        frame->src_buffer);
+  }
+
+  g_free (frame);
+
+  return ret;
+}
+
+int
+gst_base_video_encoder_get_height (GstBaseVideoEncoder * base_video_encoder)
+{
+  return base_video_encoder->state.height;
+}
+
+int
+gst_base_video_encoder_get_width (GstBaseVideoEncoder * base_video_encoder)
+{
+  return base_video_encoder->state.width;
+}
+
+const GstVideoState *
+gst_base_video_encoder_get_state (GstBaseVideoEncoder * base_video_encoder)
+{
+  return &base_video_encoder->state;
+}
+
+GstFlowReturn
+gst_base_video_encoder_end_of_stream (GstBaseVideoEncoder * base_video_encoder,
+    GstBuffer * buffer)
+{
+
+  if (base_video_encoder->frames) {
+    GST_WARNING ("EOS with frames left over");
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_encoder),
+      buffer);
+}
+
+void
+gst_base_video_encoder_set_latency (GstBaseVideoEncoder * base_video_encoder,
+    GstClockTime min_latency, GstClockTime max_latency)
+{
+  g_return_if_fail (min_latency >= 0);
+  g_return_if_fail (max_latency >= min_latency);
+
+  base_video_encoder->min_latency = min_latency;
+  base_video_encoder->max_latency = max_latency;
+}
+
+void
+gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *
+    base_video_encoder, int n_fields)
+{
+  gint64 latency;
+
+  latency = gst_util_uint64_scale (n_fields,
+      base_video_encoder->state.fps_d * GST_SECOND,
+      2 * base_video_encoder->state.fps_n);
+
+  gst_base_video_encoder_set_latency (base_video_encoder, latency, latency);
+
+}
diff -Naur gst-libs/gst/video/gstbasevideoencoder.h gst-libs/gst/video/gstbasevideoencoder.h
--- gst-libs/gst/video/gstbasevideoencoder.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideoencoder.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,118 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_ENCODER_H_
+#define _GST_BASE_VIDEO_ENCODER_H_
+
+#include <gst/video/gstbasevideocodec.h>
+#include <gst/video/gstbasevideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_ENCODER \
+  (gst_base_video_encoder_get_type())
+#define GST_BASE_VIDEO_ENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_ENCODER,GstBaseVideoEncoder))
+#define GST_BASE_VIDEO_ENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_ENCODER,GstBaseVideoEncoderClass))
+#define GST_BASE_VIDEO_ENCODER_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_ENCODER,GstBaseVideoEncoderClass))
+#define GST_IS_BASE_VIDEO_ENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_ENCODER))
+#define GST_IS_BASE_VIDEO_ENCODER_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_ENCODER))
+
+/**
+ * GST_BASE_VIDEO_ENCODER_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_ENCODER_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_ENCODER_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_ENCODER_SRC_NAME     "src"
+
+
+typedef struct _GstBaseVideoEncoder GstBaseVideoEncoder;
+typedef struct _GstBaseVideoEncoderClass GstBaseVideoEncoderClass;
+
+struct _GstBaseVideoEncoder
+{
+  GstBaseVideoCodec base_video_codec;
+
+  /*< private >*/
+  GList *frames;
+
+  GstVideoState state;
+
+  gboolean sink_clipping;
+
+  guint64 presentation_frame_number;
+  guint64 system_frame_number;
+  int distance_from_sync;
+
+  GstCaps *caps;
+  gboolean set_output_caps;
+
+  gint64 min_latency;
+  gint64 max_latency;
+};
+
+struct _GstBaseVideoEncoderClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
+
+  gboolean (*set_format) (GstBaseVideoEncoder *coder, GstVideoState *state);
+  gboolean (*start) (GstBaseVideoEncoder *coder);
+  gboolean (*stop) (GstBaseVideoEncoder *coder);
+  gboolean (*finish) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
+  gboolean (*handle_frame) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
+  GstFlowReturn (*shape_output) (GstBaseVideoEncoder *coder, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoEncoder *coder);
+
+};
+
+GType gst_base_video_encoder_get_type (void);
+
+int gst_base_video_encoder_get_width (GstBaseVideoEncoder *coder);
+int gst_base_video_encoder_get_height (GstBaseVideoEncoder *coder);
+const GstVideoState *gst_base_video_encoder_get_state (GstBaseVideoEncoder *coder);
+
+guint64 gst_base_video_encoder_get_timestamp_offset (GstBaseVideoEncoder *coder);
+
+GstVideoFrame *gst_base_video_encoder_get_frame (GstBaseVideoEncoder *coder,
+    int frame_number);
+GstFlowReturn gst_base_video_encoder_finish_frame (GstBaseVideoEncoder *base_video_encoder,
+    GstVideoFrame *frame);
+GstFlowReturn gst_base_video_encoder_end_of_stream (GstBaseVideoEncoder *base_video_encoder,
+    GstBuffer *buffer);
+
+void gst_base_video_encoder_set_latency (GstBaseVideoEncoder *base_video_encoder,
+    GstClockTime min_latency, GstClockTime max_latency);
+void gst_base_video_encoder_set_latency_fields (GstBaseVideoEncoder *base_video_encoder,
+    int n_fields);
+
+
+G_END_DECLS
+
+#endif
+
diff -Naur gst-libs/gst/video/gstbasevideoparse.c gst-libs/gst/video/gstbasevideoparse.c
--- gst-libs/gst/video/gstbasevideoparse.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideoparse.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,862 @@
+/* Schrodinger
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideoparse.h"
+
+#include <string.h>
+#include <math.h>
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+
+
+/* GstBaseVideoParse signals and args */
+enum
+{
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+};
+
+static void gst_base_video_parse_finalize (GObject * object);
+
+static const GstQueryType *gst_base_video_parse_get_query_types (GstPad * pad);
+static gboolean gst_base_video_parse_src_query (GstPad * pad, GstQuery * query);
+static gboolean gst_base_video_parse_sink_query (GstPad * pad,
+    GstQuery * query);
+static gboolean gst_base_video_parse_src_event (GstPad * pad, GstEvent * event);
+static gboolean gst_base_video_parse_sink_event (GstPad * pad,
+    GstEvent * event);
+static GstStateChangeReturn gst_base_video_parse_change_state (GstElement *
+    element, GstStateChange transition);
+static GstFlowReturn gst_base_video_parse_push_all (GstBaseVideoParse *
+    base_video_parse, gboolean at_eos);
+static GstFlowReturn gst_base_video_parse_chain (GstPad * pad, GstBuffer * buf);
+static void gst_base_video_parse_free_frame (GstVideoFrame * frame);
+static GstVideoFrame *gst_base_video_parse_new_frame (GstBaseVideoParse *
+    base_video_parse);
+
+
+GST_BOILERPLATE (GstBaseVideoParse, gst_base_video_parse,
+    GstBaseVideoCodec, GST_TYPE_BASE_VIDEO_CODEC);
+
+static void
+gst_base_video_parse_base_init (gpointer g_class)
+{
+
+}
+
+static void
+gst_base_video_parse_class_init (GstBaseVideoParseClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->finalize = gst_base_video_parse_finalize;
+
+  element_class->change_state = gst_base_video_parse_change_state;
+}
+
+static void
+gst_base_video_parse_init (GstBaseVideoParse * base_video_parse,
+    GstBaseVideoParseClass * klass)
+{
+  GstPad *pad;
+
+  GST_DEBUG ("gst_base_video_parse_init");
+
+  pad = GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_parse);
+
+  gst_pad_set_chain_function (pad, gst_base_video_parse_chain);
+  gst_pad_set_query_function (pad, gst_base_video_parse_sink_query);
+  gst_pad_set_event_function (pad, gst_base_video_parse_sink_event);
+
+  pad = GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse);
+
+  gst_pad_set_query_type_function (pad, gst_base_video_parse_get_query_types);
+  gst_pad_set_query_function (pad, gst_base_video_parse_src_query);
+  gst_pad_set_event_function (pad, gst_base_video_parse_src_event);
+
+  base_video_parse->input_adapter = gst_adapter_new ();
+  base_video_parse->output_adapter = gst_adapter_new ();
+
+  base_video_parse->reorder_depth = 1;
+
+  base_video_parse->current_frame =
+      gst_base_video_parse_new_frame (base_video_parse);
+}
+
+static void
+gst_base_video_parse_reset (GstBaseVideoParse * base_video_parse)
+{
+  GST_DEBUG ("reset");
+
+  base_video_parse->discont = TRUE;
+  base_video_parse->have_sync = FALSE;
+
+  base_video_parse->system_frame_number = 0;
+  base_video_parse->presentation_frame_number = 0;
+
+  if (base_video_parse->caps) {
+    gst_caps_unref (base_video_parse->caps);
+    base_video_parse->caps = NULL;
+  }
+
+  gst_segment_init (&base_video_parse->state.segment, GST_FORMAT_TIME);
+  gst_adapter_clear (base_video_parse->input_adapter);
+  gst_adapter_clear (base_video_parse->output_adapter);
+
+  if (base_video_parse->current_frame) {
+    gst_base_video_parse_free_frame (base_video_parse->current_frame);
+  }
+  base_video_parse->current_frame =
+      gst_base_video_parse_new_frame (base_video_parse);
+
+}
+
+static void
+gst_base_video_parse_finalize (GObject * object)
+{
+  GstBaseVideoParse *base_video_parse;
+
+  g_return_if_fail (GST_IS_BASE_VIDEO_PARSE (object));
+  base_video_parse = GST_BASE_VIDEO_PARSE (object);
+
+  if (base_video_parse->input_adapter) {
+    g_object_unref (base_video_parse->input_adapter);
+  }
+  if (base_video_parse->output_adapter) {
+    g_object_unref (base_video_parse->output_adapter);
+  }
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static const GstQueryType *
+gst_base_video_parse_get_query_types (GstPad * pad)
+{
+  static const GstQueryType query_types[] = {
+    GST_QUERY_POSITION,
+    GST_QUERY_DURATION,
+    GST_QUERY_CONVERT,
+    0
+  };
+
+  return query_types;
+}
+
+#if 0
+static gboolean
+gst_base_video_parse_src_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res;
+  GstBaseVideoParse *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (dec->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          dec->fps_d * GST_SECOND, dec->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  } else {
+    GST_WARNING ("unhandled conversion from %d to %d", src_format,
+        *dest_format);
+    res = FALSE;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+
+static gboolean
+gst_base_video_parse_sink_convert (GstPad * pad,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = TRUE;
+  GstBaseVideoParse *dec;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  dec = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  /* FIXME: check if we are in a decoding state */
+
+  switch (src_format) {
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_d * GST_SECOND, dec->fps_n);
+          break;
+        default:
+          res = FALSE;
+      }
+      break;
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+        {
+          *dest_value = gst_util_uint64_scale (src_value,
+              dec->fps_n, dec->fps_d * GST_SECOND);
+          break;
+        }
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+
+  gst_object_unref (dec);
+
+  return res;
+}
+#endif
+
+static gboolean
+gst_base_video_parse_src_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoParse *base_parse;
+  gboolean res = FALSE;
+
+  base_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_POSITION:
+    {
+      GstFormat format;
+      gint64 time;
+      gint64 value;
+
+      gst_query_parse_position (query, &format, NULL);
+
+      time = gst_util_uint64_scale (base_parse->presentation_frame_number,
+          base_parse->state.fps_n, base_parse->state.fps_d);
+      time += base_parse->state.segment.time;
+      GST_DEBUG ("query position %lld", time);
+      res = gst_base_video_encoded_video_convert (&base_parse->state,
+          GST_FORMAT_TIME, time, &format, &value);
+      if (!res)
+        goto error;
+
+      gst_query_set_position (query, format, value);
+      break;
+    }
+    case GST_QUERY_DURATION:
+      res =
+          gst_pad_query (GST_PAD_PEER (GST_BASE_VIDEO_CODEC_SINK_PAD
+              (base_parse)), query);
+      if (!res)
+        goto error;
+      break;
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      GST_WARNING ("query convert");
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_parse->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_parse);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_parse, "query failed");
+  goto done;
+}
+
+static gboolean
+gst_base_video_parse_sink_query (GstPad * pad, GstQuery * query)
+{
+  GstBaseVideoParse *base_video_parse;
+  gboolean res = FALSE;
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_QUERY_TYPE (query)) {
+    case GST_QUERY_CONVERT:
+    {
+      GstFormat src_fmt, dest_fmt;
+      gint64 src_val, dest_val;
+
+      gst_query_parse_convert (query, &src_fmt, &src_val, &dest_fmt, &dest_val);
+      res = gst_base_video_encoded_video_convert (&base_video_parse->state,
+          src_fmt, src_val, &dest_fmt, &dest_val);
+      if (!res)
+        goto error;
+      gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
+      break;
+    }
+    default:
+      res = gst_pad_query_default (pad, query);
+      break;
+  }
+done:
+  gst_object_unref (base_video_parse);
+
+  return res;
+error:
+  GST_DEBUG_OBJECT (base_video_parse, "query failed");
+  goto done;
+}
+
+static gboolean
+gst_base_video_parse_src_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoParse *base_video_parse;
+  gboolean res = FALSE;
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_SEEK:
+    {
+      GstFormat format, tformat;
+      gdouble rate;
+      GstEvent *real_seek;
+      GstSeekFlags flags;
+      GstSeekType cur_type, stop_type;
+      gint64 cur, stop;
+      gint64 tcur, tstop;
+
+      gst_event_parse_seek (event, &rate, &format, &flags, &cur_type,
+          &cur, &stop_type, &stop);
+      gst_event_unref (event);
+
+      tformat = GST_FORMAT_TIME;
+      res = gst_base_video_encoded_video_convert (&base_video_parse->state,
+          format, cur, &tformat, &tcur);
+      if (!res)
+        goto convert_error;
+      res = gst_base_video_encoded_video_convert (&base_video_parse->state,
+          format, stop, &tformat, &tstop);
+      if (!res)
+        goto convert_error;
+
+      real_seek = gst_event_new_seek (rate, GST_FORMAT_TIME,
+          flags, cur_type, tcur, stop_type, tstop);
+
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_parse),
+          real_seek);
+
+      break;
+    }
+#if 0
+    case GST_EVENT_QOS:
+    {
+      gdouble proportion;
+      GstClockTimeDiff diff;
+      GstClockTime timestamp;
+
+      gst_event_parse_qos (event, &proportion, &diff, &timestamp);
+
+      GST_OBJECT_LOCK (base_video_parse);
+      base_video_parse->proportion = proportion;
+      base_video_parse->earliest_time = timestamp + diff;
+      GST_OBJECT_UNLOCK (base_video_parse);
+
+      GST_DEBUG_OBJECT (base_video_parse,
+          "got QoS %" GST_TIME_FORMAT ", %" G_GINT64_FORMAT,
+          GST_TIME_ARGS (timestamp), diff);
+
+      res = gst_pad_push_event (base_video_parse->sinkpad, event);
+      break;
+    }
+#endif
+    default:
+      res =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SINK_PAD (base_video_parse),
+          event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_parse);
+  return res;
+
+convert_error:
+  GST_DEBUG_OBJECT (base_video_parse, "could not convert format");
+  goto done;
+}
+
+static gboolean
+gst_base_video_parse_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstBaseVideoParse *base_video_parse;
+  gboolean ret = FALSE;
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_START:
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      gst_base_video_parse_reset (base_video_parse);
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    case GST_EVENT_EOS:
+      if (gst_base_video_parse_push_all (base_video_parse,
+              FALSE) == GST_FLOW_ERROR) {
+        gst_event_unref (event);
+        return FALSE;
+      }
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      gboolean update;
+      GstFormat format;
+      gdouble rate;
+      gint64 start, stop, time;
+
+      gst_event_parse_new_segment (event, &update, &rate, &format, &start,
+          &stop, &time);
+
+      if (format != GST_FORMAT_TIME)
+        goto newseg_wrong_format;
+
+      if (rate <= 0.0)
+        goto newseg_wrong_rate;
+
+      GST_DEBUG ("newsegment %lld %lld", start, time);
+      gst_segment_set_newsegment (&base_video_parse->state.segment, update,
+          rate, format, start, stop, time);
+
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+    }
+    default:
+      ret =
+          gst_pad_push_event (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+          event);
+      break;
+  }
+done:
+  gst_object_unref (base_video_parse);
+  return ret;
+
+newseg_wrong_format:
+  GST_DEBUG_OBJECT (base_video_parse, "received non TIME newsegment");
+  gst_event_unref (event);
+  goto done;
+
+newseg_wrong_rate:
+  GST_DEBUG_OBJECT (base_video_parse, "negative rates not supported");
+  gst_event_unref (event);
+  goto done;
+}
+
+
+static GstStateChangeReturn
+gst_base_video_parse_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstBaseVideoParse *base_parse = GST_BASE_VIDEO_PARSE (element);
+  GstStateChangeReturn ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_base_video_parse_reset (base_parse);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_base_video_parse_reset (base_parse);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static guint64
+gst_base_video_parse_get_timestamp (GstBaseVideoParse * base_video_parse,
+    int picture_number)
+{
+  if (picture_number < 0) {
+    return base_video_parse->timestamp_offset -
+        (gint64) gst_util_uint64_scale (-picture_number,
+        base_video_parse->state.fps_d * GST_SECOND,
+        base_video_parse->state.fps_n);
+  } else {
+    return base_video_parse->timestamp_offset +
+        gst_util_uint64_scale (picture_number,
+        base_video_parse->state.fps_d * GST_SECOND,
+        base_video_parse->state.fps_n);
+  }
+}
+
+static GstFlowReturn
+gst_base_video_parse_push_all (GstBaseVideoParse * base_video_parse,
+    gboolean at_eos)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  /* FIXME do stuff */
+
+  return ret;
+}
+
+static GstFlowReturn
+gst_base_video_parse_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstBaseVideoParse *base_video_parse;
+  GstBaseVideoParseClass *klass;
+  GstBuffer *buffer;
+  GstFlowReturn ret;
+
+  GST_DEBUG ("chain with %d bytes", GST_BUFFER_SIZE (buf));
+
+  base_video_parse = GST_BASE_VIDEO_PARSE (GST_PAD_PARENT (pad));
+  klass = GST_BASE_VIDEO_PARSE_GET_CLASS (base_video_parse);
+
+  if (!base_video_parse->started) {
+    klass->start (base_video_parse);
+    base_video_parse->started = TRUE;
+  }
+
+  if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))) {
+    GST_DEBUG_OBJECT (base_video_parse, "received DISCONT buffer");
+    gst_base_video_parse_reset (base_video_parse);
+    base_video_parse->discont = TRUE;
+    base_video_parse->have_sync = FALSE;
+  }
+
+  if (GST_BUFFER_TIMESTAMP (buf) != GST_CLOCK_TIME_NONE) {
+    base_video_parse->last_timestamp = GST_BUFFER_TIMESTAMP (buf);
+  }
+  gst_adapter_push (base_video_parse->input_adapter, buf);
+
+  if (!base_video_parse->have_sync) {
+    int n, m;
+
+    GST_DEBUG ("no sync, scanning");
+
+    n = gst_adapter_available (base_video_parse->input_adapter);
+    m = klass->scan_for_sync (base_video_parse->input_adapter, FALSE, 0, n);
+
+    gst_adapter_flush (base_video_parse->input_adapter, m);
+
+    if (m < n) {
+      GST_DEBUG ("found possible sync after %d bytes (of %d)", m, n);
+
+      /* this is only "maybe" sync */
+      base_video_parse->have_sync = TRUE;
+    }
+
+    if (!base_video_parse->have_sync) {
+      return GST_FLOW_OK;
+    }
+  }
+
+  buffer = gst_adapter_get_buffer (base_video_parse->input_adapter);
+
+  gst_buffer_unref (buffer);
+
+  /* FIXME check klass->parse_data */
+
+  do {
+    ret = klass->parse_data (base_video_parse, FALSE);
+  } while (ret == GST_FLOW_OK);
+
+  if (ret == GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA) {
+    return GST_FLOW_OK;
+  }
+  return ret;
+}
+
+GstVideoState *
+gst_base_video_parse_get_state (GstBaseVideoParse * base_video_parse)
+{
+  return &base_video_parse->state;
+}
+
+void
+gst_base_video_parse_set_state (GstBaseVideoParse * base_video_parse,
+    GstVideoState * state)
+{
+  GST_DEBUG ("set_state");
+
+  memcpy (&base_video_parse->state, state, sizeof (GstVideoState));
+
+  /* FIXME set caps */
+
+}
+
+
+gboolean
+gst_base_video_parse_set_src_caps (GstBaseVideoParse * base_video_parse,
+    GstCaps * caps)
+{
+  g_return_val_if_fail (GST_IS_BASE_VIDEO_PARSE (base_video_parse), FALSE);
+
+  GST_DEBUG ("set_src_caps");
+
+  return gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+      caps);
+}
+
+void
+gst_base_video_parse_lost_sync (GstBaseVideoParse * base_video_parse)
+{
+  g_return_if_fail (GST_IS_BASE_VIDEO_PARSE (base_video_parse));
+
+  GST_DEBUG ("lost_sync");
+
+  if (gst_adapter_available (base_video_parse->input_adapter) >= 1) {
+    gst_adapter_flush (base_video_parse->input_adapter, 1);
+  }
+
+  base_video_parse->have_sync = FALSE;
+}
+
+GstVideoFrame *
+gst_base_video_parse_get_frame (GstBaseVideoParse * base_video_parse)
+{
+  g_return_val_if_fail (GST_IS_BASE_VIDEO_PARSE (base_video_parse), NULL);
+
+  return base_video_parse->current_frame;
+}
+
+void
+gst_base_video_parse_add_to_frame (GstBaseVideoParse * base_video_parse,
+    int n_bytes)
+{
+  GstBuffer *buf;
+
+  GST_DEBUG ("add_to_frame");
+
+  buf = gst_adapter_take_buffer (base_video_parse->input_adapter, n_bytes);
+
+  gst_adapter_push (base_video_parse->output_adapter, buf);
+}
+
+GstFlowReturn
+gst_base_video_parse_finish_frame (GstBaseVideoParse * base_video_parse)
+{
+  GstVideoFrame *frame = base_video_parse->current_frame;
+  GstBuffer *buffer;
+  GstBaseVideoParseClass *base_video_parse_class;
+  GstFlowReturn ret;
+
+  GST_DEBUG ("finish_frame");
+
+  base_video_parse_class = GST_BASE_VIDEO_PARSE_GET_CLASS (base_video_parse);
+
+  buffer = gst_adapter_take_buffer (base_video_parse->output_adapter,
+      gst_adapter_available (base_video_parse->output_adapter));
+
+  if (frame->is_sync_point) {
+    base_video_parse->timestamp_offset = base_video_parse->last_timestamp -
+        gst_util_uint64_scale (frame->presentation_frame_number,
+        base_video_parse->state.fps_d * GST_SECOND,
+        base_video_parse->state.fps_n);
+    base_video_parse->distance_from_sync = 0;
+  }
+
+  frame->distance_from_sync = base_video_parse->distance_from_sync;
+  base_video_parse->distance_from_sync++;
+
+  frame->presentation_timestamp =
+      gst_base_video_parse_get_timestamp (base_video_parse,
+      frame->presentation_frame_number);
+  frame->presentation_duration =
+      gst_base_video_parse_get_timestamp (base_video_parse,
+      frame->presentation_frame_number + 1) - frame->presentation_timestamp;
+  frame->decode_timestamp =
+      gst_base_video_parse_get_timestamp (base_video_parse,
+      frame->decode_frame_number);
+
+  GST_BUFFER_TIMESTAMP (buffer) = frame->presentation_timestamp;
+  GST_BUFFER_DURATION (buffer) = frame->presentation_duration;
+  if (frame->decode_frame_number < 0) {
+    GST_BUFFER_OFFSET (buffer) = 0;
+  } else {
+    GST_BUFFER_OFFSET (buffer) = frame->decode_timestamp;
+  }
+  GST_BUFFER_OFFSET_END (buffer) = GST_CLOCK_TIME_NONE;
+
+  GST_DEBUG ("pts %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (frame->presentation_timestamp));
+  GST_DEBUG ("dts %" GST_TIME_FORMAT, GST_TIME_ARGS (frame->decode_timestamp));
+  GST_DEBUG ("dist %d", frame->distance_from_sync);
+
+  if (frame->is_sync_point) {
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+
+  frame->src_buffer = buffer;
+  ret = base_video_parse_class->shape_output (base_video_parse, frame);
+
+  gst_base_video_parse_free_frame (base_video_parse->current_frame);
+
+  /* create new frame */
+  base_video_parse->current_frame =
+      gst_base_video_parse_new_frame (base_video_parse);
+
+  return ret;
+}
+
+static void
+gst_base_video_parse_free_frame (GstVideoFrame * frame)
+{
+  if (frame->sink_buffer) {
+    gst_buffer_unref (frame->sink_buffer);
+  }
+#if 0
+  if (frame->src_buffer) {
+    gst_buffer_unref (frame->src_buffer);
+  }
+#endif
+
+  g_free (frame);
+}
+
+static GstVideoFrame *
+gst_base_video_parse_new_frame (GstBaseVideoParse * base_video_parse)
+{
+  GstVideoFrame *frame;
+
+  frame = g_malloc0 (sizeof (GstVideoFrame));
+
+  frame->system_frame_number = base_video_parse->system_frame_number;
+  base_video_parse->system_frame_number++;
+
+  frame->decode_frame_number = frame->system_frame_number -
+      base_video_parse->reorder_depth;
+
+  return frame;
+}
+
+void
+gst_base_video_parse_set_sync_point (GstBaseVideoParse * base_video_parse)
+{
+  GST_DEBUG ("set_sync_point");
+
+  base_video_parse->current_frame->is_sync_point = TRUE;
+
+  base_video_parse->distance_from_sync = 0;
+}
+
+GstFlowReturn
+gst_base_video_parse_push (GstBaseVideoParse * base_video_parse,
+    GstBuffer * buffer)
+{
+  GstBaseVideoParseClass *base_video_parse_class;
+
+  base_video_parse_class = GST_BASE_VIDEO_PARSE_GET_CLASS (base_video_parse);
+
+  if (base_video_parse->caps == NULL) {
+    gboolean ret;
+
+    base_video_parse->caps =
+        base_video_parse_class->get_caps (base_video_parse);
+
+    ret = gst_pad_set_caps (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse),
+        base_video_parse->caps);
+
+    if (!ret) {
+      GST_WARNING ("pad didn't accept caps");
+      return GST_FLOW_ERROR;
+    }
+  }
+  gst_buffer_set_caps (buffer, base_video_parse->caps);
+
+  GST_DEBUG ("pushing ts=%lld dur=%lld off=%lld off_end=%lld",
+      GST_BUFFER_TIMESTAMP (buffer),
+      GST_BUFFER_DURATION (buffer),
+      GST_BUFFER_OFFSET (buffer), GST_BUFFER_OFFSET_END (buffer));
+
+  if (base_video_parse->discont) {
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+    base_video_parse->discont = FALSE;
+  } else {
+    GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DISCONT);
+  }
+
+  return gst_pad_push (GST_BASE_VIDEO_CODEC_SRC_PAD (base_video_parse), buffer);
+}
diff -Naur gst-libs/gst/video/gstbasevideoparse.h gst-libs/gst/video/gstbasevideoparse.h
--- gst-libs/gst/video/gstbasevideoparse.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideoparse.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,136 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_PARSE_H_
+#define _GST_BASE_VIDEO_PARSE_H_
+
+#include <gst/video/gstbasevideocodec.h>
+#include <gst/video/gstbasevideoutils.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_BASE_VIDEO_PARSE \
+  (gst_base_video_parse_get_type())
+#define GST_BASE_VIDEO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_VIDEO_PARSE,GstBaseVideoParse))
+#define GST_BASE_VIDEO_PARSE_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_VIDEO_PARSE,GstBaseVideoParseClass))
+#define GST_BASE_VIDEO_PARSE_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_BASE_VIDEO_PARSE,GstBaseVideoParseClass))
+#define GST_IS_BASE_VIDEO_PARSE(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_VIDEO_PARSE))
+#define GST_IS_BASE_VIDEO_PARSE_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_VIDEO_PARSE))
+
+/**
+ * GST_BASE_VIDEO_PARSE_SINK_NAME:
+ *
+ * The name of the templates for the sink pad.
+ */
+#define GST_BASE_VIDEO_PARSE_SINK_NAME    "sink"
+/**
+ * GST_BASE_VIDEO_PARSE_SRC_NAME:
+ *
+ * The name of the templates for the source pad.
+ */
+#define GST_BASE_VIDEO_PARSE_SRC_NAME     "src"
+
+/**
+ * GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA:
+ *
+ */
+#define GST_BASE_VIDEO_PARSE_FLOW_NEED_DATA GST_FLOW_CUSTOM_SUCCESS
+
+typedef struct _GstBaseVideoParse GstBaseVideoParse;
+typedef struct _GstBaseVideoParseClass GstBaseVideoParseClass;
+
+struct _GstBaseVideoParse
+{
+  GstBaseVideoCodec base_video_codec;
+
+  /*< private >*/
+  GstAdapter *input_adapter;
+  GstAdapter *output_adapter;
+
+  int reorder_depth;
+
+  gboolean have_sync;
+  gboolean discont;
+  gboolean started;
+
+  GstVideoFrame *current_frame;
+  GstVideoState state;
+  int distance_from_sync;
+
+  gboolean sink_clipping;
+
+  guint64 presentation_frame_number;
+  guint64 system_frame_number;
+
+  GstCaps *caps;
+  gboolean set_output_caps;
+
+  GstClockTime last_timestamp;
+
+  gint64 timestamp_offset;
+};
+
+struct _GstBaseVideoParseClass
+{
+  GstBaseVideoCodecClass base_video_codec_class;
+
+  gboolean (*start) (GstBaseVideoParse *parse);
+  gboolean (*stop) (GstBaseVideoParse *parse);
+  gboolean (*reset) (GstBaseVideoParse *parse);
+  GstFlowReturn (*parse_data) (GstBaseVideoParse *parse, gboolean at_eos);
+  int (*scan_for_sync) (GstAdapter *adapter, gboolean at_eos,
+      int offset, int n);
+  GstFlowReturn (*shape_output) (GstBaseVideoParse *parse, GstVideoFrame *frame);
+  GstCaps *(*get_caps) (GstBaseVideoParse *parse);
+
+};
+
+GType gst_base_video_parse_get_type (void);
+
+int gst_base_video_parse_get_width (GstBaseVideoParse *parse);
+int gst_base_video_parse_get_height (GstBaseVideoParse *parse);
+GstVideoState *gst_base_video_parse_get_state (GstBaseVideoParse *parse);
+void gst_base_video_parse_set_state (GstBaseVideoParse *parse,
+    GstVideoState *state);
+
+guint64 gst_base_video_parse_get_timestamp_offset (GstBaseVideoParse *parse);
+
+gboolean gst_base_video_parse_set_src_caps (GstBaseVideoParse *base_video_parse, GstCaps *caps);
+
+GstFlowReturn gst_base_video_parse_end_of_stream (GstBaseVideoParse *base_video_parse,
+    GstBuffer *buffer);
+
+void gst_base_video_parse_lost_sync (GstBaseVideoParse *base_video_parse);
+
+GstVideoFrame * gst_base_video_parse_get_frame (GstBaseVideoParse *base_video_parse);
+void gst_base_video_parse_add_to_frame (GstBaseVideoParse *base_video_parse, int n_bytes);
+GstFlowReturn gst_base_video_parse_finish_frame (GstBaseVideoParse *base_video_parse);
+void gst_base_video_parse_set_sync_point (GstBaseVideoParse *base_video_parse);
+GstFlowReturn gst_base_video_parse_push (GstBaseVideoParse *base_video_parse,
+    GstBuffer *buffer);
+
+G_END_DECLS
+
+#endif
+
diff -Naur gst-libs/gst/video/gstbasevideoutils.c gst-libs/gst/video/gstbasevideoutils.c
--- gst-libs/gst/video/gstbasevideoutils.c	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideoutils.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,276 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstbasevideoutils.h"
+
+#include <string.h>
+
+GST_DEBUG_CATEGORY_EXTERN (basevideo_debug);
+#define GST_CAT_DEFAULT basevideo_debug
+
+
+guint64
+gst_base_video_convert_bytes_to_frames (GstVideoState * state, guint64 bytes)
+{
+  return gst_util_uint64_scale_int (bytes, 1, state->bytes_per_picture);
+}
+
+guint64
+gst_base_video_convert_frames_to_bytes (GstVideoState * state, guint64 frames)
+{
+  return frames * state->bytes_per_picture;
+}
+
+
+gboolean
+gst_base_video_rawvideo_convert (GstVideoState * state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = FALSE;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  if (src_format == GST_FORMAT_BYTES &&
+      *dest_format == GST_FORMAT_DEFAULT && state->bytes_per_picture != 0) {
+    /* convert bytes to frames */
+    *dest_value = gst_util_uint64_scale_int (src_value, 1,
+        state->bytes_per_picture);
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_DEFAULT &&
+      *dest_format == GST_FORMAT_BYTES && state->bytes_per_picture != 0) {
+    /* convert bytes to frames */
+    *dest_value = src_value * state->bytes_per_picture;
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_DEFAULT &&
+      *dest_format == GST_FORMAT_TIME && state->fps_n != 0) {
+    /* convert frames to time */
+    /* FIXME add segment time? */
+    *dest_value = gst_util_uint64_scale (src_value,
+        GST_SECOND * state->fps_d, state->fps_n);
+    res = TRUE;
+  } else if (src_format == GST_FORMAT_TIME &&
+      *dest_format == GST_FORMAT_DEFAULT && state->fps_d != 0) {
+    /* convert time to frames */
+    /* FIXME subtract segment time? */
+    *dest_value = gst_util_uint64_scale (src_value, state->fps_n,
+        GST_SECOND * state->fps_d);
+    res = TRUE;
+  }
+
+  /* FIXME add bytes <--> time */
+
+  return res;
+}
+
+gboolean
+gst_base_video_encoded_video_convert (GstVideoState * state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 * dest_value)
+{
+  gboolean res = FALSE;
+
+  if (src_format == *dest_format) {
+    *dest_value = src_value;
+    return TRUE;
+  }
+
+  GST_DEBUG ("src convert");
+
+#if 0
+  if (src_format == GST_FORMAT_DEFAULT && *dest_format == GST_FORMAT_TIME) {
+    if (dec->fps_d != 0) {
+      *dest_value = gst_util_uint64_scale (granulepos_to_frame (src_value),
+          dec->fps_d * GST_SECOND, dec->fps_n);
+      res = TRUE;
+    } else {
+      res = FALSE;
+    }
+  } else {
+    GST_WARNING ("unhandled conversion from %d to %d", src_format,
+        *dest_format);
+    res = FALSE;
+  }
+#endif
+
+  return res;
+}
+
+gboolean
+gst_base_video_state_from_caps (GstVideoState * state, GstCaps * caps)
+{
+
+  gst_video_format_parse_caps (caps, &state->format,
+      &state->width, &state->height);
+
+  gst_video_parse_caps_framerate (caps, &state->fps_n, &state->fps_d);
+
+  state->par_n = 1;
+  state->par_d = 1;
+  gst_video_parse_caps_pixel_aspect_ratio (caps, &state->par_n, &state->par_d);
+
+  {
+    GstStructure *structure = gst_caps_get_structure (caps, 0);
+    state->interlaced = FALSE;
+    gst_structure_get_boolean (structure, "interlaced", &state->interlaced);
+  }
+
+  state->clean_width = state->width;
+  state->clean_height = state->height;
+  state->clean_offset_left = 0;
+  state->clean_offset_top = 0;
+
+  /* FIXME need better error handling */
+  return TRUE;
+}
+
+GstClockTime
+gst_video_state_get_timestamp (const GstVideoState * state, int frame_number)
+{
+  if (frame_number < 0) {
+    return state->segment.start -
+        (gint64) gst_util_uint64_scale (-frame_number,
+        state->fps_d * GST_SECOND, state->fps_n);
+  } else {
+    return state->segment.start +
+        gst_util_uint64_scale (frame_number,
+        state->fps_d * GST_SECOND, state->fps_n);
+  }
+}
+
+/* gst adapter */
+
+static GSList *
+get_chunk (GstAdapter * adapter, int offset, int *skip)
+{
+  GSList *g;
+
+#if 1
+  if (skip)
+    *skip = 0;
+#endif
+
+  g_return_val_if_fail (offset >= 0, NULL);
+  g_return_val_if_fail (offset < adapter->size, NULL);
+
+  offset += adapter->skip;
+  g = adapter->buflist;
+  while (g) {
+    if (offset < GST_BUFFER_SIZE (GST_BUFFER (g->data))) {
+      if (skip)
+        *skip = offset;
+      return g;
+    }
+    offset -= GST_BUFFER_SIZE (GST_BUFFER (g->data));
+    g = g->next;
+  }
+
+  g_assert_not_reached ();
+}
+
+static int
+scan_fast (guint8 * data, guint32 pattern, guint32 mask, int n)
+{
+  int i;
+
+  pattern &= mask;
+  for (i = 0; i < n; i++) {
+    if ((GST_READ_UINT32_BE (data + i) & mask) == pattern) {
+      return i;
+    }
+  }
+  return n;
+}
+
+static gboolean
+scan_slow (GstAdapter * adapter, GSList * g, int skip, guint32 pattern,
+    guint32 mask)
+{
+  guint8 tmp[4];
+  int j;
+
+  pattern &= mask;
+  for (j = 0; j < 4; j++) {
+    tmp[j] = ((guint8 *) GST_BUFFER_DATA (GST_BUFFER (g->data)))[skip];
+    skip++;
+    if (skip >= GST_BUFFER_SIZE (GST_BUFFER (g->data))) {
+      g = g->next;
+      skip = 0;
+    }
+  }
+
+  return ((GST_READ_UINT32_BE (tmp) & mask) == pattern);
+}
+
+
+int
+gst_adapter_masked_scan_uint32 (GstAdapter * adapter,
+    guint32 pattern, guint32 mask, int offset, int n)
+{
+  GSList *g;
+  int j;
+  int k;
+  int skip;
+  int m;
+
+  g_return_val_if_fail (n >= 0, 0);
+  g_return_val_if_fail (offset >= 0, 0);
+  g_return_val_if_fail (offset + n + 4 <= adapter->size, 0);
+
+  g = get_chunk (adapter, offset, &skip);
+  j = 0;
+  while (j < n) {
+    m = MIN (GST_BUFFER_SIZE (GST_BUFFER (g->data)) - skip - 4, 0);
+    if (m > 0) {
+      k = scan_fast (GST_BUFFER_DATA (GST_BUFFER (g->data)) + skip,
+          pattern, mask, m);
+      if (k < m) {
+        return offset + j + k;
+      }
+      j += m;
+      skip += m;
+    } else {
+      if (scan_slow (adapter, g, skip, pattern, mask)) {
+        return offset + j;
+      }
+      j++;
+      skip++;
+    }
+    if (skip >= GST_BUFFER_SIZE (GST_BUFFER (g->data))) {
+      g = g->next;
+      skip = 0;
+    }
+  }
+
+  return n;
+}
+
+GstBuffer *
+gst_adapter_get_buffer (GstAdapter * adapter)
+{
+  return gst_buffer_ref (GST_BUFFER (adapter->buflist->data));
+
+}
diff -Naur gst-libs/gst/video/gstbasevideoutils.h gst-libs/gst/video/gstbasevideoutils.h
--- gst-libs/gst/video/gstbasevideoutils.h	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/gstbasevideoutils.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,94 @@
+/* GStreamer
+ * Copyright (C) 2008 David Schleef <ds@schleef.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _GST_BASE_VIDEO_UTILS_H_
+#define _GST_BASE_VIDEO_UTILS_H_
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/base/gstadapter.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstVideoState GstVideoState;
+typedef struct _GstVideoFrame GstVideoFrame;
+
+struct _GstVideoState
+{
+  GstVideoFormat format;
+  int width, height;
+  int fps_n, fps_d;
+  int par_n, par_d;
+  gboolean interlaced;
+  gboolean top_field_first;
+
+  int clean_width, clean_height;
+  int clean_offset_left, clean_offset_top;
+
+  int bytes_per_picture;
+
+  GstSegment segment;
+
+  int picture_number;
+};
+
+struct _GstVideoFrame
+{
+  guint64 decode_timestamp;
+  guint64 presentation_timestamp;
+  guint64 presentation_duration;
+
+  gint system_frame_number;
+  gint decode_frame_number;
+  gint presentation_frame_number;
+
+  int distance_from_sync;
+  gboolean is_sync_point;
+  gboolean is_eos;
+
+  GstBuffer *sink_buffer;
+  GstBuffer *src_buffer;
+
+  int field_index;
+  int n_fields;
+
+  void *coder_hook;
+};
+
+gboolean gst_base_video_rawvideo_convert (GstVideoState *state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 *dest_value);
+gboolean gst_base_video_encoded_video_convert (GstVideoState *state,
+    GstFormat src_format, gint64 src_value,
+    GstFormat * dest_format, gint64 *dest_value);
+
+gboolean gst_base_video_state_from_caps (GstVideoState *state,
+    GstCaps *caps);
+
+GstClockTime gst_video_state_get_timestamp (const GstVideoState *state,
+    int frame_number);
+
+int gst_adapter_masked_scan_uint32 (GstAdapter *adapter,
+    guint32 pattern, guint32 mask, int offset, int n);
+GstBuffer *gst_adapter_get_buffer (GstAdapter *adapter);
+
+G_END_DECLS
+
+#endif
+
diff -Naur gst-libs/gst/video/Makefile.am gst-libs/gst/video/Makefile.am
--- gst-libs/gst/video/Makefile.am	2009-01-21 11:36:13.000000000 +0100
+++ gst-libs/gst/video/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -12,11 +12,23 @@
 
 CLEANFILES = $(BUILT_SOURCES)
 
-libgstvideo_@GST_MAJORMINOR@_la_SOURCES = video.c gstvideosink.c gstvideofilter.c
+libgstvideo_@GST_MAJORMINOR@_la_SOURCES = \
+	video.c gstvideosink.c gstvideofilter.c \
+	gstbasevideoutils.c \
+	gstbasevideocodec.c \
+	gstbasevideodecoder.c \
+	gstbasevideoencoder.c \
+	gstbasevideoparse.c
 nodist_libgstvideo_@GST_MAJORMINOR@_la_SOURCES = $(BUILT_SOURCES)
 
 libgstvideo_@GST_MAJORMINOR@includedir = $(includedir)/gstreamer-@GST_MAJORMINOR@/gst/video
-libgstvideo_@GST_MAJORMINOR@include_HEADERS = video.h gstvideosink.h gstvideofilter.h
+libgstvideo_@GST_MAJORMINOR@include_HEADERS = \
+	video.h gstvideosink.h gstvideofilter.h \
+	gstbasevideoutils.h \
+	gstbasevideocodec.h \
+	gstbasevideodecoder.h \
+	gstbasevideoencoder.h \
+	gstbasevideoparse.h
 nodist_libgstvideo_@GST_MAJORMINOR@include_HEADERS = $(built_headers)
 
 libgstvideo_@GST_MAJORMINOR@_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
diff -Naur gst-libs/gst/video/video.c gst-libs/gst/video/video.c
--- gst-libs/gst/video/video.c	2009-04-15 21:18:27.000000000 +0200
+++ gst-libs/gst/video/video.c	2009-05-19 18:44:45.000000000 +0200
@@ -580,6 +580,12 @@
       return GST_VIDEO_FORMAT_Y41B;
     case GST_MAKE_FOURCC ('Y', '4', '2', 'B'):
       return GST_VIDEO_FORMAT_Y42B;
+    case GST_MAKE_FOURCC ('Y', '4', '4', '4'):
+      return GST_VIDEO_FORMAT_Y444;
+    case GST_MAKE_FOURCC ('v', '2', '1', '0'):
+      return GST_VIDEO_FORMAT_v210;
+    case GST_MAKE_FOURCC ('v', '2', '1', '6'):
+      return GST_VIDEO_FORMAT_v216;
     default:
       return GST_VIDEO_FORMAT_UNKNOWN;
   }
@@ -619,6 +625,12 @@
       return GST_MAKE_FOURCC ('Y', '4', '1', 'B');
     case GST_VIDEO_FORMAT_Y42B:
       return GST_MAKE_FOURCC ('Y', '4', '2', 'B');
+    case GST_VIDEO_FORMAT_Y444:
+      return GST_MAKE_FOURCC ('Y', '4', '4', '4');
+    case GST_VIDEO_FORMAT_v210:
+      return GST_MAKE_FOURCC ('v', '2', '1', '0');
+    case GST_VIDEO_FORMAT_v216:
+      return GST_MAKE_FOURCC ('v', '2', '1', '6');
     default:
       return 0;
   }
@@ -719,6 +731,9 @@
     case GST_VIDEO_FORMAT_AYUV:
     case GST_VIDEO_FORMAT_Y41B:
     case GST_VIDEO_FORMAT_Y42B:
+    case GST_VIDEO_FORMAT_Y444:
+    case GST_VIDEO_FORMAT_v210:
+    case GST_VIDEO_FORMAT_v216:
       return FALSE;
     case GST_VIDEO_FORMAT_RGBx:
     case GST_VIDEO_FORMAT_BGRx:
@@ -758,6 +773,9 @@
     case GST_VIDEO_FORMAT_AYUV:
     case GST_VIDEO_FORMAT_Y41B:
     case GST_VIDEO_FORMAT_Y42B:
+    case GST_VIDEO_FORMAT_Y444:
+    case GST_VIDEO_FORMAT_v210:
+    case GST_VIDEO_FORMAT_v216:
       return TRUE;
     case GST_VIDEO_FORMAT_RGBx:
     case GST_VIDEO_FORMAT_BGRx:
@@ -797,6 +815,9 @@
     case GST_VIDEO_FORMAT_UYVY:
     case GST_VIDEO_FORMAT_Y41B:
     case GST_VIDEO_FORMAT_Y42B:
+    case GST_VIDEO_FORMAT_Y444:
+    case GST_VIDEO_FORMAT_v210:
+    case GST_VIDEO_FORMAT_v216:
       return FALSE;
     case GST_VIDEO_FORMAT_AYUV:
     case GST_VIDEO_FORMAT_RGBA:
@@ -879,6 +900,12 @@
       } else {
         return GST_ROUND_UP_8 (width) / 2;
       }
+    case GST_VIDEO_FORMAT_Y444:
+      return GST_ROUND_UP_4 (width);
+    case GST_VIDEO_FORMAT_v210:
+      return ((width + 47) / 48) * 128;
+    case GST_VIDEO_FORMAT_v216:
+      return GST_ROUND_UP_8 (width * 4);
     default:
       return 0;
   }
@@ -909,6 +936,7 @@
     case GST_VIDEO_FORMAT_YV12:
     case GST_VIDEO_FORMAT_Y41B:
     case GST_VIDEO_FORMAT_Y42B:
+    case GST_VIDEO_FORMAT_Y444:
       return 1;
     case GST_VIDEO_FORMAT_YUY2:
     case GST_VIDEO_FORMAT_YVYU:
@@ -931,6 +959,15 @@
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
       return 3;
+    case GST_VIDEO_FORMAT_v210:
+      /* v210 is packed at the bit level, so pixel stride doesn't make sense */
+      return 0;
+    case GST_VIDEO_FORMAT_v216:
+      if (component == 0) {
+        return 4;
+      } else {
+        return 8;
+      }
     default:
       return 0;
   }
@@ -964,22 +1001,19 @@
     case GST_VIDEO_FORMAT_YUY2:
     case GST_VIDEO_FORMAT_YVYU:
     case GST_VIDEO_FORMAT_UYVY:
+    case GST_VIDEO_FORMAT_Y42B:
+    case GST_VIDEO_FORMAT_v210:
+    case GST_VIDEO_FORMAT_v216:
       if (component == 0) {
         return width;
       } else {
         return GST_ROUND_UP_2 (width) / 2;
       }
-    case GST_VIDEO_FORMAT_Y41B:        /* CHECKME: component_width for Y41B */
-      if (component == 0) {
-        return width;
-      } else {
-        return GST_ROUND_UP_8 (width) / 4;
-      }
-    case GST_VIDEO_FORMAT_Y42B:        /* CHECKME: component_width for Y42B */
+    case GST_VIDEO_FORMAT_Y41B:
       if (component == 0) {
         return width;
       } else {
-        return GST_ROUND_UP_8 (width) / 2;
+        return GST_ROUND_UP_4 (width) / 4;
       }
     case GST_VIDEO_FORMAT_AYUV:
     case GST_VIDEO_FORMAT_RGBx:
@@ -992,6 +1026,7 @@
     case GST_VIDEO_FORMAT_ABGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_Y444:
       return width;
     default:
       return 0;
@@ -1044,6 +1079,9 @@
     case GST_VIDEO_FORMAT_ABGR:
     case GST_VIDEO_FORMAT_RGB:
     case GST_VIDEO_FORMAT_BGR:
+    case GST_VIDEO_FORMAT_Y444:
+    case GST_VIDEO_FORMAT_v210:
+    case GST_VIDEO_FORMAT_v216:
       return height;
     default:
       return 0;
@@ -1209,6 +1247,19 @@
       if (component == 2)
         return (GST_ROUND_UP_4 (width) + (GST_ROUND_UP_8 (width) / 2)) * height;
       return 0;
+    case GST_VIDEO_FORMAT_Y444:
+      return GST_ROUND_UP_4 (width) * height * component;
+    case GST_VIDEO_FORMAT_v210:
+      /* v210 is bit-packed, so this doesn't make sense */
+      return 0;
+    case GST_VIDEO_FORMAT_v216:
+      if (component == 0)
+        return 0;
+      if (component == 1)
+        return 2;
+      if (component == 2)
+        return 6;
+      return 0;
     default:
       return 0;
   }
@@ -1265,6 +1316,12 @@
     case GST_VIDEO_FORMAT_Y42B:
       /* simplification of ROUNDUP4(w)*h + 2*(ROUNDUP8(w)/2)*h: */
       return (GST_ROUND_UP_4 (width) + GST_ROUND_UP_8 (width)) * height;
+    case GST_VIDEO_FORMAT_Y444:
+      return GST_ROUND_UP_4 (width) * height * 3;
+    case GST_VIDEO_FORMAT_v210:
+      return ((width + 47) / 48) * 128 * height;
+    case GST_VIDEO_FORMAT_v216:
+      return GST_ROUND_UP_8 (width * 4) * height;
     default:
       return 0;
   }
diff -Naur gst-libs/gst/video/video.h gst-libs/gst/video/video.h
--- gst-libs/gst/video/video.h	2009-04-15 21:18:27.000000000 +0200
+++ gst-libs/gst/video/video.h	2009-05-19 18:44:45.000000000 +0200
@@ -48,6 +48,9 @@
  * @GST_VIDEO_FORMAT_Y41B: planar 4:1:1 YUV (Since: 0.10.18)
  * @GST_VIDEO_FORMAT_Y42B: planar 4:2:2 YUV (Since: 0.10.18)
  * @GST_VIDEO_FORMAT_YVYU: packed 4:2:2 YUV (Y0-V0-Y1-U0 Y2-V2-Y3-U2 Y4 ...) (Since: 0.10.23)
+ * @GST_VIDEO_FORMAT_Y444: planar 4:4:4 YUV (Since: 0.10.24)
+ * @GST_VIDEO_FORMAT_v210: packed 4:2:2 10-bit YUV, complex format (Since: 0.10.24)
+ * @GST_VIDEO_FORMAT_v216: packed 4:2:2 16-bit YUV, Y0-U0-Y1-V1 order (Since: 0.10.24)
  *
  * Enum value describing the most common video formats.
  */
@@ -70,7 +73,10 @@
   GST_VIDEO_FORMAT_BGR,
   GST_VIDEO_FORMAT_Y41B,
   GST_VIDEO_FORMAT_Y42B,
-  GST_VIDEO_FORMAT_YVYU
+  GST_VIDEO_FORMAT_YVYU,
+  GST_VIDEO_FORMAT_Y444,
+  GST_VIDEO_FORMAT_v210,
+  GST_VIDEO_FORMAT_v216
 } GstVideoFormat;
 
 #define GST_VIDEO_BYTE1_MASK_32  "0xFF000000"
diff -Naur gst-libs/gst/video/video.vcproj gst-libs/gst/video/video.vcproj
--- gst-libs/gst/video/video.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ gst-libs/gst/video/video.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,150 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="video"
+	ProjectGUID="{979C216F-0ACF-4956-AE00-055A42D6789D}"
+	RootNamespace="video"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="../../../win32/Debug"
+			IntermediateDirectory="../../../win32/Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideo.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Debug;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/video.pdb"
+				SubSystem="2"
+				OptimizeReferences="2"
+				ImportLibrary="$(OutDir)/gstvideo.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="../../../win32/Release"
+			IntermediateDirectory="../../../win32/Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../../gstreamer/win32;../../../../gstreamer;../../../../gstreamer/libs;../../../../glib;../../../../glib/glib;../../../../glib/gmodule;&quot;../../../gst-libs&quot;;../../../../popt/include;../../../../libxml2/include/libxml2"
+				PreprocessorDefinitions="WIN32;NDEBUG;GST_DISABLE_GST_DEBUG;_WINDOWS;_USRDLL;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="glib-2.0.lib gmodule-2.0.lib gthread-2.0.lib gobject-2.0.lib libgstreamer.lib gstbytestream.lib iconv.lib intl.lib"
+				OutputFile="$(OutDir)/gstvideo.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../../gstreamer/win32/Release;../../../../glib/glib;../../../../glib/gmodule;../../../../glib/gthread;../../../../glib/gobject;../../../../gettext/lib;../../../../libiconv/lib"
+				ModuleDefinitionFile=""
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/gstvideo.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /Y $(TargetPath) c:\gstreamer\plugins"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath=".\gstvideosink.c">
+			</File>
+			<File
+				RelativePath=".\video.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath=".\video.h">
+			</File>
+			<File
+				RelativePath=".\videosink.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur LICENSE_readme LICENSE_readme
--- LICENSE_readme	1970-01-01 01:00:00.000000000 +0100
+++ LICENSE_readme	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,137 @@
+
+Disclaimer:  The GStreamer team makes a real effort to make sure that
+the information in this file is as up-to-date and accurate as possible.
+However, this file may contain errors and omissions.  Some dependant
+libraries change their licensing from version-to-version and some of 
+the libraries listed here as LGPL were under the GPL license in
+older releases.  Distributions which include GStreamer are responsible
+for ensuring that plugins are used in accordance with licensing terms
+and other laws.
+
+GStreamer is developed under the terms of the LGPL (see LICENSE file for details).
+Some of our plugins however rely on libraries which are available under other
+licenses. This means that if you are using an application which has a non-GPL
+compatible license, for instance a closed-source application with GStreamer
+you have to make sure not to use GPL linked or derived plugins.  When using
+GPL linked plugins GStreamer is for all practical reasons under the GPL itself. 
+
+The plugins which use a GPL library are as follows:
+
+a52dec           liba52           (http://liba52.sourceforge.net/)
+aasink           aalib            (http://sourceforge.net/projects/aa-project/)
+cdparanoia       libcdparanoia    (http://www.xiph.org/paranoia/)
+dtsdec           libdts           (http://www.videolan.org/dtsdec.html)
+dvdnavsrc        libdvdnav        (http://dvd.sourceforge.net/)
+dxr3                              (http://dxr3.sourceforge.net/)
+icecastsend      libshout         (http://www.icecast.org)
+mad              libmad           (http://www.mars.org/home/rob/proj/mpeg/)
+mpeg2dec         libmpeg2         (http://libmpeg2.sourceforge.net/)
+mpeg2enc         libmpeg2enc      (http://mjpeg.sourceforge.net/)
+mplex            libmplex         (http://mjpeg.sourceforge.net/)
+siddec           libsidplay 1.36  (http://www.geocities.com/SiliconValley/Lakes/5147/sidplay/,
+                                   http://sourceforge.net/projects/sidplay2/)
+trm              libmusicbrainz   (http://www.musicbrainz.org/)
+xine             libxine          (http://xinehq.de/)
+xvid             libxvidcore      (http://www.xvid.org/)
+
+Plugins derived from GPL code are as follows:
+
+dvdreadsrc       libdvdread       (http://www.dtek.chalmers.se/groups/dvd/)
+jack             libjack          (http://jackit.sourceforge.net/)
+                                   Note libjack is LGPL, but plugin is GPL.
+monoscope        None             (Algorithm by Ralph Loader, Joerg Walter,
+                                   Richard Boulton, and Andy Lo A Foe)
+rtjpeg           None             (Erik Walthinsen's algorithm)
+rtp              None             (http://www.linphone.org/ortp/)
+synaesthesia                      (http://www.logarithmic.net/pfh/synaesthesia)
+system_encode    None             (Algorithm by Chrisoph Moar, Wim Tayman's and
+                                   Erik Walthinsen)
+vbidec           None             (Algorithm by Billy Biggs, Doug Bell, 
+                                   Erik Walthinsen and David I. Lehn)
+
+Plugins which use a LGPL library are as follows:
+
+alsa             alsa             (http://alsa-project.org/)
+artsdsink        aRts             (http://arts-project.org/)
+cacasink         libcaca          (http://sam.zoy.org/projects/libcaca/)
+colorspacelcs    libcolorspace    
+dvdec            libdv            (http://libdv.sourceforge.net/)
+esdmon,esdsink   libesd           (ftp.gnome.org/pub/GNOME/stable/sources/esound/)
+faac             libfaac          (http://www.audiocoding.com/modules/mydownloads/)
+fameenc          libfame          (http://fame.sourceforge.net/)
+ffmpeg           ffmpeg           (http://ffmpeg.sourceforge.net/)
+gdkpixbuf        GTK+             (http://www.gtk.org/)
+gnomevfs         gnome-vfs        (ftp.gnome.org//pub/GNOME/stable/sources/gnome-vfs/)
+gst_arts         aRts             (http://arts-project.org/)
+gst1394          libraw1394       (http://www.linux1394.org/)
+gstaf            libaudiofile     (http://www.68k.org/~michael/audiofile/)
+gstsf            libsndfile       (http://www.mega-nerd.com/libsndfile/)
+hermescolorspace Hermes           (http://www.clanlib.org/hermes/)
+kio              KDE              (http://www.kde.org/)
+ladspa                            (http://www.ladspa.org/)
+lame             libmp3lame       (http://lame.sourceforge.net/)
+libvisual        libvisual        (http://libvisual.sourceforge.net/)
+matroska                          (http://www.matroska.org/)
+mikmod           libmikmod        (http://mikmod.raphnet.net/)
+ossaudio                          (http://www.opensound.com/)
+qcamsrc
+rfbenc           librfb
+sdlvideosink     libsdl           (http://www.libsdl.org/)
+shout2send       libshout2        (http://www.icecast.org)
+smoothwave      
+swfdec                            (http://swfdec.sourceforge.net/)
+tarkin                            (http://svn.xiph.org/trunk/tarkin/)
+textoverlay      pango            (http://www.pango.org/)
+dirac                             (http://www.bbc.co.uk/rd/projects/dirac/)
+effectv (Our ports was relicensed)(http://effectv.sourceforge.net/)
+musepack 			  (http://www.musepack.net/)
+
+Plugins which use a BSD covered library are as follows:
+
+ogg              libogg/libvorbis (http://www.xiph.org/ogg/vorbis/)
+vorbis           libogg/libvorbis (http://www.xiph.org/ogg/vorbis/)
+gsttheora        libtheora        (http://www.theora.org/)
+speex                             (http://www.speex.org/)
+flac             libFLAC          (http://flac.sourceforge.net/)
+
+Plugins based on libraries with other free licenses:
+
+ximagesink       libXv
+xvimagesink      libXv            
+ - license:      MIT X11 / X Consortium license
+
+gsm              libgsm           
+ - license       MIT license http://kbs.cs.tu-berlin.de/~jutta/toast.html
+
+festival                          (http://www.cstr.ed.ac.uk/projects/festival/)
+ - license:      http://www.cstr.ed.ac.uk/projects/festival/freecopyright.shtml
+
+jpeg                              (http://www.ijg.org/)
+ - license:      IJG license
+
+nas                               (http://radscan.com/nas.html)
+ - license:      NAS license
+
+snapshot         libpng           (http://www.libpng.org/pub/png/)
+ - license:      PNG license
+
+mngdec/mngenc	libmng	    	(http://gjuyn.xs4all.nl/libmng)
+ - license 	 PNG license
+
+Plugins using non-free libraries:
+divxdec, divxenc                        (http://www.divx.com/)
+osxaudio                                (http://www.apple.com/macosx/)
+sunaudiosink                            (http://www.sun.com/)
+
+Unsure:
+
+faad             libfaad          (http://www.audiocoding.com/)
+faad's license depends on its major version :
+  - for FAAD1 : it is LGPL
+  - for FAAD2 : it is GPL
+look at these pages for more information on licenses :
+http://www.audiocoding.com/modules/wiki/?page=FAAD2
+http://www.audiocoding.com/modules/wiki/?page=FAAC
+
+by default, GStreamer faad plugin would compile against FAAD2 if available.
+it falls back to FAAD1 if not.
diff -Naur MAINTAINERS MAINTAINERS
--- MAINTAINERS	1970-01-01 01:00:00.000000000 +0100
+++ MAINTAINERS	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,13 @@
+GStreamer is currently maintained by the consensus of a number
+of people, including, but not limited to:
+
+  David Schleef <ds@schleef.org>
+  Jan Schmidt <thaytan@noraisin.net>
+  Wim Taymans <wim@fluendo.com>
+  Thomas Vander Stichele <thomas@apestaart.org>
+
+Maintainer-related issues should be addressed to:
+
+  gstreamer-devel@lists.sourceforge.net
+
+
diff -Naur pkgconfig/gstreamer-app-uninstalled.pc.in pkgconfig/gstreamer-app-uninstalled.pc.in
--- pkgconfig/gstreamer-app-uninstalled.pc.in	2009-04-01 13:49:11.000000000 +0200
+++ pkgconfig/gstreamer-app-uninstalled.pc.in	2009-05-19 18:44:45.000000000 +0200
@@ -1,6 +1,6 @@
 prefix=
 exec_prefix=
-libdir=${pcfiledir}/../gst-libs/gst/tag
+libdir=${pcfiledir}/../gst-libs/gst/app
 includedir=${pcfiledir}/../gst-libs
 
 Name: GStreamer Application Library, Uninstalled

diff -Naur sys/v4l/gstv4ljpegsrc.c sys/v4l/gstv4ljpegsrc.c
--- sys/v4l/gstv4ljpegsrc.c	1970-01-01 01:00:00.000000000 +0100
+++ sys/v4l/gstv4ljpegsrc.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,297 @@
+/* GStreamer
+ *
+ * gstv4ljpegsrc.c: V4L source element for JPEG cameras
+ *
+ * Copyright (C) 2004-2005 Jan Schmidt <thaytan@mad.scientist.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ e Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <sys/time.h>
+#include "gstv4ljpegsrc.h"
+#include "v4lsrc_calls.h"
+
+/* elementfactory information */
+static const GstElementDetails gst_v4ljpegsrc_details =
+GST_ELEMENT_DETAILS ("Video (video4linux/raw) Jpeg Source",
+    "Source/Video",
+    "Reads jpeg frames from a video4linux (eg ov519) device",
+    "Jan Schmidt <thaytan@mad.scientist.com>");
+
+GST_DEBUG_CATEGORY_STATIC (v4ljpegsrc_debug);
+#define GST_CAT_DEFAULT v4ljpegsrc_debug
+
+/* init functions */
+static void gst_v4ljpegsrc_base_init (gpointer g_class);
+static void gst_v4ljpegsrc_class_init (GstV4lJpegSrcClass * klass);
+static void gst_v4ljpegsrc_init (GstV4lJpegSrc * v4ljpegsrc);
+
+/* buffer functions */
+static GstPadLinkReturn gst_v4ljpegsrc_src_link (GstPad * pad,
+    const GstCaps * caps);
+static GstCaps *gst_v4ljpegsrc_getcaps (GstPad * pad);
+static GstData *gst_v4ljpegsrc_get (GstPad * pad);
+
+static GstElementClass *parent_class = NULL;
+
+GType
+gst_v4ljpegsrc_get_type (void)
+{
+  static GType v4ljpegsrc_type = 0;
+
+  if (!v4ljpegsrc_type) {
+    static const GTypeInfo v4ljpegsrc_info = {
+      sizeof (GstV4lJpegSrcClass),
+      gst_v4ljpegsrc_base_init,
+      NULL,
+      (GClassInitFunc) gst_v4ljpegsrc_class_init,
+      NULL,
+      NULL,
+      sizeof (GstV4lJpegSrc),
+      0,
+      (GInstanceInitFunc) gst_v4ljpegsrc_init,
+      NULL
+    };
+
+    v4ljpegsrc_type =
+        g_type_register_static (GST_TYPE_V4LSRC, "GstV4lJpegSrc",
+        &v4ljpegsrc_info, 0);
+    GST_DEBUG_CATEGORY_INIT (v4ljpegsrc_debug, "v4ljpegsrc", 0,
+        "V4L JPEG source element");
+  }
+  return v4ljpegsrc_type;
+}
+
+static void
+gst_v4ljpegsrc_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_set_details (gstelement_class, &gst_v4ljpegsrc_details);
+}
+
+static void
+gst_v4ljpegsrc_class_init (GstV4lJpegSrcClass * klass)
+{
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+gst_v4ljpegsrc_init (GstV4lJpegSrc * v4ljpegsrc)
+{
+  GstV4lSrc *v4lsrc = GST_V4LSRC (v4ljpegsrc);
+  GstPad *pad = v4lsrc->srcpad;
+
+  /*
+   * Stash away and then replace the getcaps and get functions on the src pad
+   */
+  v4ljpegsrc->getfn = GST_RPAD_GETFUNC (pad);
+  v4ljpegsrc->getcapsfn = GST_RPAD_GETCAPSFUNC (pad);
+
+  gst_pad_set_get_function (v4lsrc->srcpad, gst_v4ljpegsrc_get);
+  gst_pad_set_getcaps_function (v4lsrc->srcpad, gst_v4ljpegsrc_getcaps);
+  gst_pad_set_link_function (v4lsrc->srcpad, gst_v4ljpegsrc_src_link);
+}
+
+static GstPadLinkReturn
+gst_v4ljpegsrc_src_link (GstPad * pad, const GstCaps * vscapslist)
+{
+  GstV4lJpegSrc *v4ljpegsrc;
+  GstV4lSrc *v4lsrc;
+  gint w, h, palette = -1;
+  const GValue *fps;
+  GstStructure *structure;
+  gboolean was_capturing;
+  struct video_window *vwin;
+
+  v4ljpegsrc = GST_V4LJPEGSRC (gst_pad_get_parent (pad));
+  v4lsrc = GST_V4LSRC (v4ljpegsrc);
+  vwin = &GST_V4LELEMENT (v4lsrc)->vwin;
+  was_capturing = v4lsrc->is_capturing;
+
+  /* in case the buffers are active (which means that we already
+   * did capsnego before and didn't clean up), clean up anyways */
+  if (GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lsrc))) {
+    if (was_capturing) {
+      if (!gst_v4lsrc_capture_stop (v4lsrc))
+        return GST_PAD_LINK_REFUSED;
+    }
+    if (!gst_v4lsrc_capture_deinit (v4lsrc))
+      return GST_PAD_LINK_REFUSED;
+  } else if (!GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lsrc))) {
+    return GST_PAD_LINK_DELAYED;
+  }
+
+  structure = gst_caps_get_structure (vscapslist, 0);
+
+  gst_structure_get_int (structure, "width", &w);
+  gst_structure_get_int (structure, "height", &h);
+  fps = gst_structure_get_value (structure, "framerate");
+
+  GST_DEBUG_OBJECT (v4ljpegsrc, "linking with %dx%d at %d/%d fps", w, h,
+      gst_value_get_fraction_numerator (fps),
+      gst_value_get_fraction_denominator (fps));
+
+  /* set framerate if it's not already correct */
+  if (fps != gst_v4lsrc_get_fps (v4lsrc)) {
+    int fps_index = fps / 15.0 * 16;
+
+    GST_DEBUG_OBJECT (v4ljpegsrc, "Trying to set fps index %d", fps_index);
+    /* set bits 16 to 21 to 0 */
+    vwin->flags &= (0x3F00 - 1);
+    /* set bits 16 to 21 to the index */
+    vwin->flags |= fps_index << 16;
+    if (!gst_v4l_set_window_properties (GST_V4LELEMENT (v4lsrc))) {
+      return GST_PAD_LINK_DELAYED;
+    }
+  }
+
+  /*
+   * Try to set the camera to capture RGB24 
+   */
+  palette = VIDEO_PALETTE_RGB24;
+  v4lsrc->buffer_size = w * h * 3;
+
+  GST_DEBUG_OBJECT (v4ljpegsrc, "trying to set_capture %dx%d, palette %d",
+      w, h, palette);
+  /* this only fills in v4lsrc->mmap values */
+  if (!gst_v4lsrc_set_capture (v4lsrc, w, h, palette)) {
+    GST_WARNING_OBJECT (v4ljpegsrc, "could not set_capture %dx%d, palette %d",
+        w, h, palette);
+    return GST_PAD_LINK_REFUSED;
+  }
+
+  /* first try the negotiated settings using try_capture */
+  if (!gst_v4lsrc_try_capture (v4lsrc, w, h, palette)) {
+    GST_DEBUG_OBJECT (v4ljpegsrc, "failed trying palette %d for %dx%d", palette,
+        w, h);
+    return GST_PAD_LINK_REFUSED;
+  }
+
+  if (!gst_v4lsrc_capture_init (v4lsrc))
+    return GST_PAD_LINK_REFUSED;
+
+  if (was_capturing || GST_STATE (v4lsrc) == GST_STATE_PLAYING) {
+    if (!gst_v4lsrc_capture_start (v4lsrc))
+      return GST_PAD_LINK_REFUSED;
+  }
+
+  return GST_PAD_LINK_OK;
+}
+
+static GstCaps *
+gst_v4ljpegsrc_getcaps (GstPad * pad)
+{
+  GstCaps *list;
+  GstV4lJpegSrc *v4ljpegsrc = GST_V4LJPEGSRC (gst_pad_get_parent (pad));
+  GstV4lSrc *v4lsrc = GST_V4LSRC (v4ljpegsrc);
+  struct video_capability *vcap = &GST_V4LELEMENT (v4lsrc)->vcap;
+  gfloat fps = 0.0;
+
+  if (!GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lsrc))) {
+    return gst_caps_new_any ();
+  }
+  if (!v4lsrc->autoprobe) {
+    /* FIXME: query current caps and return those, with _any appended */
+    return gst_caps_new_any ();
+  }
+
+  list = gst_caps_new_simple ("image/jpeg", NULL);
+  GST_DEBUG_OBJECT (v4ljpegsrc,
+      "Device reports w: %d-%d, h: %d-%d, fps: %f",
+      vcap->minwidth, vcap->maxwidth, vcap->minheight, vcap->maxheight, fps);
+
+  if (vcap->minwidth < vcap->maxwidth) {
+    gst_caps_set_simple (list, "width", GST_TYPE_INT_RANGE, vcap->minwidth,
+        vcap->maxwidth, NULL);
+  } else {
+    gst_caps_set_simple (list, "width", G_TYPE_INT, vcap->minwidth, NULL);
+  }
+  if (vcap->minheight < vcap->maxheight) {
+    gst_caps_set_simple (list, "height", GST_TYPE_INT_RANGE, vcap->minheight,
+        vcap->maxheight, NULL);
+  } else {
+    gst_caps_set_simple (list, "height", G_TYPE_INT, vcap->minheight, NULL);
+  }
+
+  if (v4lsrc->fps_list) {
+    GstStructure *structure = gst_caps_get_structure (list, 0);
+
+    gst_structure_set_value (structure, "framerate", v4lsrc->fps_list);
+  }
+  GST_DEBUG_OBJECT (v4ljpegsrc, "caps: %" GST_PTR_FORMAT, list);
+
+  return list;
+}
+
+static GstData *
+gst_v4ljpegsrc_get (GstPad * pad)
+{
+  GstV4lJpegSrc *v4ljpegsrc;
+  GstV4lSrc *v4lsrc;
+  GstData *data;
+  GstBuffer *buf;
+  GstBuffer *outbuf;
+  int jpeg_size;
+
+  g_return_val_if_fail (pad != NULL, NULL);
+  v4ljpegsrc = GST_V4LJPEGSRC (gst_pad_get_parent (pad));
+  v4lsrc = GST_V4LSRC (v4ljpegsrc);
+
+  /* Fetch from the v4lsrc class get fn.  */
+  data = v4ljpegsrc->getfn (pad);
+
+  /* If not a buffer, return it unchanged */
+  if (!data || (!GST_IS_BUFFER (data)))
+    return data;
+
+  buf = GST_BUFFER (data);
+
+  /* Confirm that the buffer contains jpeg data */
+
+  /* 
+   * Create a new subbuffer from the jpeg data 
+   * The first 2 bytes in the buffer are the size of the jpeg data
+   */
+  if (GST_BUFFER_SIZE (buf) > 2) {
+    jpeg_size = (int) (GST_READ_UINT16_LE (GST_BUFFER_DATA (buf))) * 8;
+  } else
+    jpeg_size = 0;
+
+  /* Check that the size is sensible */
+  if ((jpeg_size <= 0) || (jpeg_size > GST_BUFFER_SIZE (buf) - 2)) {
+    GST_ELEMENT_ERROR (v4ljpegsrc, STREAM, FORMAT, (NULL),
+        ("Invalid non-jpeg frame from camera"));
+    return NULL;
+  }
+
+  GST_DEBUG_OBJECT (v4ljpegsrc, "Creating JPEG subbuffer of size %d",
+      jpeg_size);
+  outbuf = gst_buffer_create_sub (buf, 2, jpeg_size);
+
+  /* Copy timestamps onto the subbuffer */
+  gst_buffer_stamp (outbuf, buf);
+
+  /* Release the main buffer */
+  gst_buffer_unref (buf);
+
+  return GST_DATA (outbuf);
+}
diff -Naur sys/v4l/gstv4lmjpegsink.c sys/v4l/gstv4lmjpegsink.c
--- sys/v4l/gstv4lmjpegsink.c	1970-01-01 01:00:00.000000000 +0100
+++ sys/v4l/gstv4lmjpegsink.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,434 @@
+/* GStreamer
+ *
+ * gstv4lmjpegsink.c: hardware MJPEG video sink plugin
+ *
+ * Copyright (C) 2001-2002 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include "v4lmjpegsink_calls.h"
+
+GST_DEBUG_CATEGORY_STATIC (v4lmjpegsink_debug);
+#define GST_CAT_DEFAULT v4lmjpegsink_debug
+
+/* elementfactory information */
+static const GstElementDetails gst_v4lmjpegsink_details =
+GST_ELEMENT_DETAILS ("Video (video4linux/MJPEG) sink",
+    "Sink/Video",
+    "Writes MJPEG-encoded frames to a zoran MJPEG/video4linux device",
+    "Ronald Bultje <rbultje@ronald.bitfreak.net>");
+
+/* v4lmjpegsink signals and args */
+enum
+{
+  SIGNAL_FRAME_DISPLAYED,
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0,
+  ARG_NUMBUFS,
+  ARG_BUFSIZE,
+  ARG_X_OFFSET,
+  ARG_Y_OFFSET,
+  ARG_FRAMES_DISPLAYED,
+  ARG_FRAME_TIME
+};
+
+
+/* init functions */
+static void gst_v4lmjpegsink_base_init (gpointer g_class);
+static void gst_v4lmjpegsink_class_init (GstV4lMjpegSinkClass * klass);
+static void gst_v4lmjpegsink_init (GstV4lMjpegSink * v4lmjpegsink);
+
+/* the chain of buffers */
+static GstPadLinkReturn gst_v4lmjpegsink_sinkconnect (GstPad * pad,
+    const GstCaps * vscapslist);
+static void gst_v4lmjpegsink_chain (GstPad * pad, GstData * _data);
+
+/* get/set gst object functions */
+static void gst_v4lmjpegsink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_v4lmjpegsink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+static GstStateChangeReturn gst_v4lmjpegsink_change_state (GstElement *
+    element);
+static void gst_v4lmjpegsink_set_clock (GstElement * element, GstClock * clock);
+
+
+static GstElementClass *parent_class = NULL;
+static guint gst_v4lmjpegsink_signals[LAST_SIGNAL] = { 0 };
+
+
+GType
+gst_v4lmjpegsink_get_type (void)
+{
+  static GType v4lmjpegsink_type = 0;
+
+  if (!v4lmjpegsink_type) {
+    static const GTypeInfo v4lmjpegsink_info = {
+      sizeof (GstV4lMjpegSinkClass),
+      gst_v4lmjpegsink_base_init,
+      NULL,
+      (GClassInitFunc) gst_v4lmjpegsink_class_init,
+      NULL,
+      NULL,
+      sizeof (GstV4lMjpegSink),
+      0,
+      (GInstanceInitFunc) gst_v4lmjpegsink_init,
+    };
+
+    v4lmjpegsink_type =
+        g_type_register_static (GST_TYPE_V4LELEMENT, "GstV4lMjpegSink",
+        &v4lmjpegsink_info, 0);
+  }
+  return v4lmjpegsink_type;
+}
+
+static void
+gst_v4lmjpegsink_base_init (gpointer g_class)
+{
+  static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+      GST_PAD_SINK,
+      GST_PAD_ALWAYS,
+      GST_STATIC_CAPS ("image/jpeg, "
+          "width = (int) [ 1, MAX ], "
+          "height = (int) [ 1, MAX ], " "framerate = (fraction) [ 0, MAX ]")
+      );
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_set_details (gstelement_class, &gst_v4lmjpegsink_details);
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&sink_template));
+}
+static void
+gst_v4lmjpegsink_class_init (GstV4lMjpegSinkClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_NUMBUFS,
+      g_param_spec_int ("num-buffers", "num-buffers", "num-buffers",
+          G_MININT, G_MAXINT, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_BUFSIZE,
+      g_param_spec_int ("buffer-size", "buffer-size", "buffer-size",
+          G_MININT, G_MAXINT, 0, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_X_OFFSET,
+      g_param_spec_int ("x-offset", "x-offset", "x-offset",
+          G_MININT, G_MAXINT, 0, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_Y_OFFSET,
+      g_param_spec_int ("y-offset", "y-offset", "y-offset",
+          G_MININT, G_MAXINT, 0, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_FRAMES_DISPLAYED,
+      g_param_spec_int ("frames-displayed", "frames-displayed",
+          "frames-displayed", G_MININT, G_MAXINT, 0,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_FRAME_TIME,
+      g_param_spec_int ("frame-time", "frame-time", "frame-time", G_MININT,
+          G_MAXINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  GST_DEBUG_CATEGORY_INIT (v4lmjpegsink_debug, "v4lmjpegsink", 0,
+      "V4L MJPEG sink element");
+  gobject_class->set_property = gst_v4lmjpegsink_set_property;
+  gobject_class->get_property = gst_v4lmjpegsink_get_property;
+
+  gst_v4lmjpegsink_signals[SIGNAL_FRAME_DISPLAYED] =
+      g_signal_new ("frame-displayed", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstV4lMjpegSinkClass,
+          frame_displayed), NULL, NULL, g_cclosure_marshal_VOID__VOID,
+      G_TYPE_NONE, 0);
+
+  gstelement_class->change_state = gst_v4lmjpegsink_change_state;
+  gstelement_class->set_clock = gst_v4lmjpegsink_set_clock;
+}
+
+
+static void
+gst_v4lmjpegsink_init (GstV4lMjpegSink * v4lmjpegsink)
+{
+  GstElementClass *klass = GST_ELEMENT_GET_CLASS (v4lmjpegsink);
+
+  v4lmjpegsink->sinkpad =
+      gst_pad_new_from_template (gst_element_class_get_pad_template (klass,
+          "sink"), "sink");
+  gst_element_add_pad (GST_ELEMENT (v4lmjpegsink), v4lmjpegsink->sinkpad);
+
+  gst_pad_set_chain_function (v4lmjpegsink->sinkpad, gst_v4lmjpegsink_chain);
+  gst_pad_set_link_function (v4lmjpegsink->sinkpad,
+      gst_v4lmjpegsink_sinkconnect);
+
+  v4lmjpegsink->clock = NULL;
+
+  v4lmjpegsink->width = -1;
+  v4lmjpegsink->height = -1;
+
+  v4lmjpegsink->x_offset = -1;
+  v4lmjpegsink->y_offset = -1;
+
+  v4lmjpegsink->numbufs = 64;
+  v4lmjpegsink->bufsize = 256;
+
+  GST_OBJECT_FLAG_SET (v4lmjpegsink, GST_ELEMENT_THREAD_SUGGESTED);
+}
+
+
+static GstPadLinkReturn
+gst_v4lmjpegsink_sinkconnect (GstPad * pad, const GstCaps * vscapslist)
+{
+  GstV4lMjpegSink *v4lmjpegsink;
+  GstStructure *structure;
+
+  v4lmjpegsink = GST_V4LMJPEGSINK (gst_pad_get_parent (pad));
+
+  /* in case the buffers are active (which means that we already
+   * did capsnego before and didn't clean up), clean up anyways */
+  if (GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsink)))
+    if (!gst_v4lmjpegsink_playback_deinit (v4lmjpegsink))
+      return GST_PAD_LINK_REFUSED;
+
+  structure = gst_caps_get_structure (vscapslist, 0);
+
+  gst_structure_get_int (structure, "width", &v4lmjpegsink->width);
+  gst_structure_get_int (structure, "height", &v4lmjpegsink->height);
+
+  if (!gst_v4lmjpegsink_set_playback (v4lmjpegsink, v4lmjpegsink->width, v4lmjpegsink->height, v4lmjpegsink->x_offset, v4lmjpegsink->y_offset, GST_V4LELEMENT (v4lmjpegsink)->vchan.norm, 0))   /* TODO: interlacing */
+    return GST_PAD_LINK_REFUSED;
+
+  /* set buffer info */
+  if (!gst_v4lmjpegsink_set_buffer (v4lmjpegsink,
+          v4lmjpegsink->numbufs, v4lmjpegsink->bufsize))
+    return GST_PAD_LINK_REFUSED;
+  if (!gst_v4lmjpegsink_playback_init (v4lmjpegsink))
+    return GST_PAD_LINK_REFUSED;
+
+  return GST_PAD_LINK_OK;
+
+}
+
+
+static void
+gst_v4lmjpegsink_set_clock (GstElement * element, GstClock * clock)
+{
+  GstV4lMjpegSink *v4mjpegsink = GST_V4LMJPEGSINK (element);
+
+  v4mjpegsink->clock = clock;
+}
+
+
+static void
+gst_v4lmjpegsink_chain (GstPad * pad, GstData * _data)
+{
+  GstBuffer *buf = GST_BUFFER (_data);
+  GstV4lMjpegSink *v4lmjpegsink;
+  gint num;
+
+  g_return_if_fail (pad != NULL);
+  g_return_if_fail (GST_IS_PAD (pad));
+  g_return_if_fail (buf != NULL);
+
+  v4lmjpegsink = GST_V4LMJPEGSINK (gst_pad_get_parent (pad));
+
+  if (v4lmjpegsink->clock) {
+    GST_DEBUG ("videosink: clock wait: %" G_GUINT64_FORMAT,
+        GST_BUFFER_TIMESTAMP (buf));
+
+    gst_element_wait (GST_ELEMENT (v4lmjpegsink), GST_BUFFER_TIMESTAMP (buf));
+  }
+#if 0
+  if (GST_BUFFER_POOL (buf) == v4lmjpegsink->bufferpool) {
+    num = GPOINTER_TO_INT (GST_BUFFER_POOL_PRIVATE (buf));
+    gst_v4lmjpegsink_play_frame (v4lmjpegsink, num);
+  } else {
+#endif
+    /* check size */
+    if (GST_BUFFER_SIZE (buf) > v4lmjpegsink->breq.size) {
+      GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, WRITE, (NULL),
+          ("Buffer too big (%d KB), max. buffersize is %ld KB",
+              GST_BUFFER_SIZE (buf) / 1024, v4lmjpegsink->breq.size / 1024));
+      return;
+    }
+
+    /* put JPEG data to the device */
+    gst_v4lmjpegsink_wait_frame (v4lmjpegsink, &num);
+    memcpy (gst_v4lmjpegsink_get_buffer (v4lmjpegsink, num),
+        GST_BUFFER_DATA (buf), GST_BUFFER_SIZE (buf));
+    gst_v4lmjpegsink_play_frame (v4lmjpegsink, num);
+#if 0
+  }
+#endif
+
+  g_signal_emit (G_OBJECT (v4lmjpegsink),
+      gst_v4lmjpegsink_signals[SIGNAL_FRAME_DISPLAYED], 0);
+
+  gst_buffer_unref (buf);
+}
+
+
+#if 0
+static GstBuffer *
+gst_v4lmjpegsink_buffer_new (GstBufferPool * pool,
+    guint64 offset, guint size, gpointer user_data)
+{
+  GstV4lMjpegSink *v4lmjpegsink = GST_V4LMJPEGSINK (user_data);
+  GstBuffer *buffer = NULL;
+  guint8 *data;
+  gint num;
+
+  if (!GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsink)))
+    return NULL;
+  if (v4lmjpegsink->breq.size < size) {
+    GST_DEBUG ("Requested buffer size is too large (%d > %ld)",
+        size, v4lmjpegsink->breq.size);
+    return NULL;
+  }
+  if (!gst_v4lmjpegsink_wait_frame (v4lmjpegsink, &num))
+    return NULL;
+  data = gst_v4lmjpegsink_get_buffer (v4lmjpegsink, num);
+  if (!data)
+    return NULL;
+  buffer = gst_buffer_new ();
+  GST_BUFFER_DATA (buffer) = data;
+  GST_BUFFER_MAXSIZE (buffer) = v4lmjpegsink->breq.size;
+  GST_BUFFER_SIZE (buffer) = size;
+  GST_BUFFER_POOL (buffer) = pool;
+  GST_BUFFER_POOL_PRIVATE (buffer) = GINT_TO_POINTER (num);
+
+  /* with this flag set, we don't need our own buffer_free() function */
+  GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_DONTFREE);
+
+  return buffer;
+}
+#endif
+
+
+static void
+gst_v4lmjpegsink_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstV4lMjpegSink *v4lmjpegsink;
+
+  g_return_if_fail (GST_IS_V4LMJPEGSINK (object));
+
+  v4lmjpegsink = GST_V4LMJPEGSINK (object);
+
+  switch (prop_id) {
+    case ARG_NUMBUFS:
+      v4lmjpegsink->numbufs = g_value_get_int (value);
+      break;
+    case ARG_BUFSIZE:
+      v4lmjpegsink->bufsize = g_value_get_int (value);
+      break;
+    case ARG_X_OFFSET:
+      v4lmjpegsink->x_offset = g_value_get_int (value);
+      break;
+    case ARG_Y_OFFSET:
+      v4lmjpegsink->y_offset = g_value_get_int (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+
+static void
+gst_v4lmjpegsink_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstV4lMjpegSink *v4lmjpegsink;
+
+  v4lmjpegsink = GST_V4LMJPEGSINK (object);
+
+  switch (prop_id) {
+    case ARG_FRAMES_DISPLAYED:
+      g_value_set_int (value, v4lmjpegsink->frames_displayed);
+      break;
+    case ARG_FRAME_TIME:
+      g_value_set_int (value, v4lmjpegsink->frame_time / 1000000);
+      break;
+    case ARG_NUMBUFS:
+      g_value_set_int (value, v4lmjpegsink->numbufs);
+      break;
+    case ARG_BUFSIZE:
+      g_value_set_int (value, v4lmjpegsink->bufsize);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+
+static GstStateChangeReturn
+gst_v4lmjpegsink_change_state (GstElement * element, GstStateChange transition)
+{
+  GstV4lMjpegSink *v4lmjpegsink;
+  GstStateChangeReturn parent_value;
+
+  g_return_val_if_fail (GST_IS_V4LMJPEGSINK (element),
+      GST_STATE_CHANGE_FAILURE);
+  v4lmjpegsink = GST_V4LMJPEGSINK (element);
+
+  /* set up change state */
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      /* we used to do buffer setup here, but that's now done
+       * right after capsnego */
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      /* start */
+      if (!gst_v4lmjpegsink_playback_start (v4lmjpegsink))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      /* de-queue all queued buffers */
+      if (!gst_v4lmjpegsink_playback_stop (v4lmjpegsink))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      /* stop playback, unmap all buffers */
+      if (!gst_v4lmjpegsink_playback_deinit (v4lmjpegsink))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+  }
+
+  if (GST_ELEMENT_CLASS (parent_class)->change_state) {
+    parent_value =
+        GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+  } else {
+    parent_value = GST_STATE_CHANGE_FAILURE;
+  }
+
+  if (GST_ELEMENT_CLASS (parent_class)->change_state)
+    return parent_value;
+
+  return GST_STATE_CHANGE_SUCCESS;
+}
diff -Naur sys/v4l/gstv4lmjpegsrc.c sys/v4l/gstv4lmjpegsrc.c
--- sys/v4l/gstv4lmjpegsrc.c	1970-01-01 01:00:00.000000000 +0100
+++ sys/v4l/gstv4lmjpegsrc.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,871 @@
+/* GStreamer
+ *
+ * gstv4lmjpegsrc.c: hardware MJPEG video source plugin
+ *
+ * Copyright (C) 2001-2002 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include "v4lmjpegsrc_calls.h"
+
+GST_DEBUG_CATEGORY (v4lmjpegsrc_debug);
+#define GST_CAT_DEFAULT v4lmjpegsrc_debug
+
+/* elementfactory information */
+static const GstElementDetails gst_v4lmjpegsrc_details =
+GST_ELEMENT_DETAILS ("Video (video4linux/MJPEG) Source",
+    "Source/Video",
+    "Reads MJPEG-encoded frames from a zoran MJPEG/video4linux device",
+    "Ronald Bultje <rbultje@ronald.bitfreak.net>");
+
+/* V4lMjpegSrc signals and args */
+enum
+{
+  SIGNAL_FRAME_CAPTURE,
+  SIGNAL_FRAME_DROP,
+  SIGNAL_FRAME_INSERT,
+  SIGNAL_FRAME_LOST,
+  LAST_SIGNAL
+};
+
+/* arguments */
+enum
+{
+  ARG_0,
+#if 0
+  ARG_X_OFFSET,
+  ARG_Y_OFFSET,
+  ARG_F_WIDTH,
+  ARG_F_HEIGHT,
+  /* normally, we would want to use subframe capture, however,
+   * for the time being it's easier if we disable it first */
+#endif
+  ARG_QUALITY,
+  ARG_NUMBUFS,
+  ARG_BUFSIZE,
+  ARG_USE_FIXED_FPS
+};
+
+GST_FORMATS_FUNCTION (GstPad *, gst_v4lmjpegsrc_get_formats,
+    GST_FORMAT_TIME, GST_FORMAT_DEFAULT);
+GST_QUERY_TYPE_FUNCTION (GstPad *, gst_v4lmjpegsrc_get_query_types,
+    GST_QUERY_POSITION);
+
+/* init functions */
+static void gst_v4lmjpegsrc_base_init (gpointer g_class);
+static void gst_v4lmjpegsrc_class_init (GstV4lMjpegSrcClass * klass);
+static void gst_v4lmjpegsrc_init (GstV4lMjpegSrc * v4lmjpegsrc);
+
+/* pad/info functions */
+static gboolean gst_v4lmjpegsrc_src_convert (GstPad * pad,
+    GstFormat src_format,
+    gint64 src_value, GstFormat * dest_format, gint64 * dest_value);
+static gboolean gst_v4lmjpegsrc_src_query (GstPad * pad,
+    GstQueryType type, GstFormat * format, gint64 * value);
+
+/* buffer functions */
+static GstPadLinkReturn gst_v4lmjpegsrc_srcconnect (GstPad * pad,
+    const GstCaps * caps);
+static GstData *gst_v4lmjpegsrc_get (GstPad * pad);
+static GstCaps *gst_v4lmjpegsrc_getcaps (GstPad * pad);
+
+/* get/set params */
+static void gst_v4lmjpegsrc_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_v4lmjpegsrc_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+
+/* set_clock function for A/V sync */
+static void gst_v4lmjpegsrc_set_clock (GstElement * element, GstClock * clock);
+
+/* state handling */
+static GstStateChangeReturn gst_v4lmjpegsrc_change_state (GstElement * element);
+
+/* requeue buffer after use */
+static void gst_v4lmjpegsrc_buffer_free (GstBuffer * buffer);
+
+static GstElementClass *parent_class = NULL;
+static guint gst_v4lmjpegsrc_signals[LAST_SIGNAL] = { 0 };
+
+
+GType
+gst_v4lmjpegsrc_get_type (void)
+{
+  static GType v4lmjpegsrc_type = 0;
+
+  if (!v4lmjpegsrc_type) {
+    static const GTypeInfo v4lmjpegsrc_info = {
+      sizeof (GstV4lMjpegSrcClass),
+      gst_v4lmjpegsrc_base_init,
+      NULL,
+      (GClassInitFunc) gst_v4lmjpegsrc_class_init,
+      NULL,
+      NULL,
+      sizeof (GstV4lMjpegSrc),
+      0,
+      (GInstanceInitFunc) gst_v4lmjpegsrc_init,
+      NULL
+    };
+
+    v4lmjpegsrc_type =
+        g_type_register_static (GST_TYPE_V4LELEMENT, "GstV4lMjpegSrc",
+        &v4lmjpegsrc_info, 0);
+  }
+  return v4lmjpegsrc_type;
+}
+
+
+static void
+gst_v4lmjpegsrc_base_init (gpointer g_class)
+{
+  static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+      GST_PAD_SRC,
+      GST_PAD_ALWAYS,
+      GST_STATIC_CAPS ("image/jpeg, "
+          "width = (int) [ 0, MAX ], "
+          "height = (int) [ 0, MAX ], " "framerate = (fraction) [ 0, MAX ]")
+      );
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_set_details (gstelement_class, &gst_v4lmjpegsrc_details);
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&src_template));
+}
+static void
+gst_v4lmjpegsrc_class_init (GstV4lMjpegSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  parent_class = g_type_class_peek_parent (klass);
+
+#if 0
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_X_OFFSET,
+      g_param_spec_int ("x-offset", "x_offset", "x_offset",
+          G_MININT, G_MAXINT, 0, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_Y_OFFSET,
+      g_param_spec_int ("y-offset", "y_offset", "y_offset",
+          G_MININT, G_MAXINT, 0, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_F_WIDTH,
+      g_param_spec_int ("frame-width", "frame_width", "frame_width",
+          G_MININT, G_MAXINT, 0, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_F_HEIGHT,
+      g_param_spec_int ("frame-height", "frame_height", "frame_height",
+          G_MININT, G_MAXINT, 0, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+#endif
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_QUALITY,
+      g_param_spec_int ("quality", "Quality", "JPEG frame quality",
+          1, 100, 50, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_NUMBUFS,
+      g_param_spec_int ("num-buffers", "Num Buffers", "Number of Buffers",
+          1, 256, 64, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_BUFSIZE,
+      g_param_spec_int ("buffer-size", "Buffer Size", "Size of buffers",
+          0, 512 * 1024, 128 * 1024,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (G_OBJECT_CLASS (klass), ARG_USE_FIXED_FPS,
+      g_param_spec_boolean ("use-fixed-fps", "Use Fixed FPS",
+          "Drop/Insert frames to reach a certain FPS (TRUE) "
+          "or adapt FPS to suit the number of grabbed frames",
+          TRUE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /* signals */
+  gst_v4lmjpegsrc_signals[SIGNAL_FRAME_CAPTURE] =
+      g_signal_new ("frame-capture", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstV4lMjpegSrcClass, frame_capture),
+      NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+  gst_v4lmjpegsrc_signals[SIGNAL_FRAME_DROP] =
+      g_signal_new ("frame-drop", G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
+      G_STRUCT_OFFSET (GstV4lMjpegSrcClass, frame_drop), NULL, NULL,
+      g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+  gst_v4lmjpegsrc_signals[SIGNAL_FRAME_INSERT] =
+      g_signal_new ("frame-insert", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstV4lMjpegSrcClass, frame_insert),
+      NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+  gst_v4lmjpegsrc_signals[SIGNAL_FRAME_LOST] =
+      g_signal_new ("frame-lost", G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
+      G_STRUCT_OFFSET (GstV4lMjpegSrcClass, frame_lost), NULL, NULL,
+      g_cclosure_marshal_VOID__INT, G_TYPE_NONE, 1, G_TYPE_INT);
+
+  GST_DEBUG_CATEGORY_INIT (v4lmjpegsrc_debug, "v4lmjpegsrc", 0,
+      "V4L MJPEG source element");
+  gobject_class->set_property = gst_v4lmjpegsrc_set_property;
+  gobject_class->get_property = gst_v4lmjpegsrc_get_property;
+
+  gstelement_class->change_state = gst_v4lmjpegsrc_change_state;
+
+  gstelement_class->set_clock = gst_v4lmjpegsrc_set_clock;
+}
+
+
+static void
+gst_v4lmjpegsrc_init (GstV4lMjpegSrc * v4lmjpegsrc)
+{
+  GstElementClass *klass = GST_ELEMENT_GET_CLASS (v4lmjpegsrc);
+
+  GST_OBJECT_FLAG_SET (GST_ELEMENT (v4lmjpegsrc), GST_ELEMENT_THREAD_SUGGESTED);
+
+  v4lmjpegsrc->srcpad =
+      gst_pad_new_from_template (gst_element_class_get_pad_template (klass,
+          "src"), "src");
+  gst_element_add_pad (GST_ELEMENT (v4lmjpegsrc), v4lmjpegsrc->srcpad);
+
+  gst_pad_set_get_function (v4lmjpegsrc->srcpad, gst_v4lmjpegsrc_get);
+  gst_pad_set_getcaps_function (v4lmjpegsrc->srcpad, gst_v4lmjpegsrc_getcaps);
+  gst_pad_set_link_function (v4lmjpegsrc->srcpad, gst_v4lmjpegsrc_srcconnect);
+  gst_pad_set_convert_function (v4lmjpegsrc->srcpad,
+      gst_v4lmjpegsrc_src_convert);
+  gst_pad_set_formats_function (v4lmjpegsrc->srcpad,
+      gst_v4lmjpegsrc_get_formats);
+  gst_pad_set_query_function (v4lmjpegsrc->srcpad, gst_v4lmjpegsrc_src_query);
+  gst_pad_set_query_type_function (v4lmjpegsrc->srcpad,
+      gst_v4lmjpegsrc_get_query_types);
+
+#if 0
+  v4lmjpegsrc->frame_width = 0;
+  v4lmjpegsrc->frame_height = 0;
+  v4lmjpegsrc->x_offset = -1;
+  v4lmjpegsrc->y_offset = -1;
+#endif
+
+  v4lmjpegsrc->quality = 50;
+
+  v4lmjpegsrc->numbufs = 64;
+
+  /* no clock */
+  v4lmjpegsrc->clock = NULL;
+
+  /* fps */
+  v4lmjpegsrc->use_fixed_fps = TRUE;
+
+  v4lmjpegsrc->is_capturing = FALSE;
+}
+
+
+static gboolean
+gst_v4lmjpegsrc_get_fps (GstV4lMjpegSrc * v4lmjpegsrc, GValue * fps)
+{
+  gint norm;
+
+  g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (fps), FALSE);
+
+  if (!v4lmjpegsrc->use_fixed_fps &&
+      v4lmjpegsrc->clock != NULL && v4lmjpegsrc->handled > 0) {
+    /* try to get time from clock master and calculate fps */
+    GstClockTime time =
+        gst_clock_get_time (v4lmjpegsrc->clock) - v4lmjpegsrc->substract_time;
+    return v4lmjpegsrc->handled * GST_SECOND / time;
+  }
+
+  /* if that failed ... */
+
+  if (!GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lmjpegsrc)))
+    return FALSE;
+
+  if (!gst_v4l_get_chan_norm (GST_V4LELEMENT (v4lmjpegsrc), NULL, &norm))
+    return FALSE;
+
+  if (norm == VIDEO_MODE_NTSC)
+    gst_value_set_fraction (fps, 30000, 1001);
+  else
+    gst_value_set_fraction (fps, 25, 1);
+
+  return TRUE;
+}
+
+static gboolean
+gst_v4lmjpegsrc_src_convert (GstPad * pad,
+    GstFormat src_format,
+    gint64 src_value, GstFormat * dest_format, gint64 * dest_value)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc;
+  GValue fps = { 0 };
+  gboolean result = TRUE;
+
+  v4lmjpegsrc = GST_V4LMJPEGSRC (gst_pad_get_parent (pad));
+
+  g_value_init (&fps, GST_VALUE_FRACTION);
+  if (!gst_v4lmjpegsrc_get_fps (v4lmjpegsrc, &fps))
+    return FALSE;
+
+  switch (src_format) {
+    case GST_FORMAT_TIME:
+      switch (*dest_format) {
+        case GST_FORMAT_DEFAULT:
+          *dest_value = gst_util_uint64_scale (src_value,
+              gst_value_get_fraction_numerator (&fps),
+              gst_value_get_fraction_denominator (&fps) * GST_SECOND);
+          break;
+        default:
+          result = FALSE;
+      }
+      break;
+
+    case GST_FORMAT_DEFAULT:
+      switch (*dest_format) {
+        case GST_FORMAT_TIME:
+          *dest_value = src_value * gst_util_uint64_scale_int (GST_SECOND,
+              gst_value_get_fraction_denominator (&fps),
+              gst_value_get_fraction_numerator (&fps));
+          break;
+        default:
+          result = FALSE;
+      }
+      break;
+
+    default:
+      result = FALSE;
+  }
+
+  g_value_unset (&fps);
+  return result;
+}
+
+static gboolean
+gst_v4lmjpegsrc_src_query (GstPad * pad,
+    GstQueryType type, GstFormat * format, gint64 * value)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc = GST_V4LMJPEGSRC (gst_pad_get_parent (pad));
+  gboolean res = TRUE;
+  GValue fps = { 0 };
+
+  g_value_init (&fps, GST_VALUE_FRACTION);
+  if (!gst_v4lmjpegsrc_get_fps (v4lmjpegsrc, &fps))
+    return FALSE;
+
+  switch (type) {
+    case GST_QUERY_POSITION:
+      switch (*format) {
+        case GST_FORMAT_TIME:
+          *value = v4lmjpegsrc->handled * gst_util_uint64_scale_int (GST_SECOND,
+              gst_value_get_fraction_denominator (&fps),
+              gst_value_get_fraction_numerator (&fps));
+          break;
+        case GST_FORMAT_DEFAULT:
+          *value = v4lmjpegsrc->handled;
+          break;
+        default:
+          res = FALSE;
+          break;
+      }
+      break;
+    default:
+      res = FALSE;
+      break;
+  }
+
+  g_value_unset (&fps);
+  return res;
+}
+
+static inline gulong
+calc_bufsize (int hor_dec, int ver_dec)
+{
+  guint8 div = hor_dec * ver_dec;
+  guint32 num = (1024 * 512) / (div);
+  guint32 result = 2;
+
+  num--;
+  while (num) {
+    num >>= 1;
+    result <<= 1;
+  }
+
+  if (result > (512 * 1024))
+    return (512 * 1024);
+  if (result < 8192)
+    return 8192;
+  return result;
+}
+
+static GstPadLinkReturn
+gst_v4lmjpegsrc_srcconnect (GstPad * pad, const GstCaps * caps)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc = GST_V4LMJPEGSRC (gst_pad_get_parent (pad));
+  gint hor_dec, ver_dec;
+  gint w, h;
+  gint max_w = GST_V4LELEMENT (v4lmjpegsrc)->vcap.maxwidth,
+      max_h = GST_V4LELEMENT (v4lmjpegsrc)->vcap.maxheight;
+  gulong bufsize;
+  GstStructure *structure;
+  gboolean was_capturing;
+
+  /* in case the buffers are active (which means that we already
+   * did capsnego before and didn't clean up), clean up anyways */
+  if ((was_capturing = v4lmjpegsrc->is_capturing)) {
+    if (!gst_v4lmjpegsrc_capture_stop (v4lmjpegsrc))
+      return GST_PAD_LINK_REFUSED;
+  }
+  if (GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc))) {
+    if (!gst_v4lmjpegsrc_capture_deinit (v4lmjpegsrc))
+      return GST_PAD_LINK_REFUSED;
+  } else if (!GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lmjpegsrc))) {
+    return GST_PAD_LINK_DELAYED;
+  }
+
+  /* Note: basically, we don't give a damn about the opposite caps here.
+   * that might seem odd, but it isn't. we know that the opposite caps is
+   * either NULL or has mime type image/jpeg, and in both cases, we'll set
+   * our own mime type back and it'll work. Other properties are to be set
+   * by the src, not by the opposite caps */
+
+  structure = gst_caps_get_structure (caps, 0);
+  gst_structure_get_int (structure, "width", &w);
+  gst_structure_get_int (structure, "height", &h);
+
+  /* figure out decimation */
+  if (w >= max_w) {
+    hor_dec = 1;
+  } else if (w * 2 >= max_w) {
+    hor_dec = 2;
+  } else {
+    hor_dec = 4;
+  }
+  if (h >= max_h) {
+    ver_dec = 1;
+  } else if (h * 2 >= max_h) {
+    ver_dec = 2;
+  } else {
+    ver_dec = 4;
+  }
+
+  /* calculate bufsize */
+  bufsize = calc_bufsize (hor_dec, ver_dec);
+
+  /* set buffer info */
+  if (!gst_v4lmjpegsrc_set_buffer (v4lmjpegsrc, v4lmjpegsrc->numbufs, bufsize)) {
+    return GST_PAD_LINK_REFUSED;
+  }
+
+  /* set capture parameters and mmap the buffers */
+  if (hor_dec == ver_dec) {
+    if (!gst_v4lmjpegsrc_set_capture (v4lmjpegsrc,
+            hor_dec, v4lmjpegsrc->quality)) {
+      return GST_PAD_LINK_REFUSED;
+    }
+  } else {
+    if (!gst_v4lmjpegsrc_set_capture_m (v4lmjpegsrc,
+            0, 0, max_w, max_h, hor_dec, ver_dec, v4lmjpegsrc->quality)) {
+      return GST_PAD_LINK_REFUSED;
+    }
+  }
+#if 0
+  if (!v4lmjpegsrc->frame_width && !v4lmjpegsrc->frame_height &&
+      v4lmjpegsrc->x_offset < 0 && v4lmjpegsrc->y_offset < 0 &&
+      v4lmjpegsrc->horizontal_decimation == v4lmjpegsrc->vertical_decimation) {
+    if (!gst_v4lmjpegsrc_set_capture (v4lmjpegsrc,
+            v4lmjpegsrc->horizontal_decimation, v4lmjpegsrc->quality))
+      return GST_PAD_LINK_REFUSED;
+  } else {
+    if (!gst_v4lmjpegsrc_set_capture_m (v4lmjpegsrc,
+            v4lmjpegsrc->x_offset, v4lmjpegsrc->y_offset,
+            v4lmjpegsrc->frame_width, v4lmjpegsrc->frame_height,
+            v4lmjpegsrc->horizontal_decimation,
+            v4lmjpegsrc->vertical_decimation, v4lmjpegsrc->quality))
+      return GST_PAD_LINK_REFUSED;
+  }
+#endif
+
+  if (!gst_v4lmjpegsrc_capture_init (v4lmjpegsrc))
+    return GST_PAD_LINK_REFUSED;
+
+  if (was_capturing || GST_STATE (v4lmjpegsrc) == GST_STATE_PLAYING)
+    if (!gst_v4lmjpegsrc_capture_start (v4lmjpegsrc))
+      return GST_PAD_LINK_REFUSED;
+
+  return GST_PAD_LINK_OK;
+}
+
+
+static GstData *
+gst_v4lmjpegsrc_get (GstPad * pad)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc;
+  GstBuffer *buf;
+  gint num;
+  GValue fps = { 0 };
+  GstClockTime duration;
+  GstClockTime cur_frame_time;
+
+  g_return_val_if_fail (pad != NULL, NULL);
+
+  v4lmjpegsrc = GST_V4LMJPEGSRC (gst_pad_get_parent (pad));
+
+  if (v4lmjpegsrc->use_fixed_fps) {
+    g_value_init (&fps, GST_VALUE_FRACTION);
+    duration = gst_util_uint64_scale_int (GST_SECOND,
+        gst_value_get_fraction_denominator (&fps),
+        gst_value_get_fraction_numerator (&fps));
+    cur_frame_time =
+        gst_util_uint64_scale_int (v4lmjpegsrc->handled * GST_SECOND,
+        gst_value_get_fraction_denominator (&fps),
+        gst_value_get_fraction_numerator (&fps));
+
+
+    if (!gst_v4lmjpegsrc_get_fps (v4lmjpegsrc, &fps)) {
+      g_value_unset (&fps);
+      return NULL;
+    }
+  }
+
+  if (v4lmjpegsrc->need_writes > 0) {
+    /* use last frame */
+    num = v4lmjpegsrc->last_frame;
+    v4lmjpegsrc->need_writes--;
+  } else if (v4lmjpegsrc->clock && v4lmjpegsrc->use_fixed_fps) {
+    GstClockTime time;
+    gboolean have_frame = FALSE;
+
+    do {
+      /* by default, we use the frame once */
+      v4lmjpegsrc->need_writes = 1;
+
+      /* grab a frame from the device */
+      if (!gst_v4lmjpegsrc_grab_frame (v4lmjpegsrc, &num,
+              &v4lmjpegsrc->last_size))
+        return NULL;
+
+      v4lmjpegsrc->last_frame = num;
+      time = GST_TIMEVAL_TO_TIME (v4lmjpegsrc->bsync.timestamp) -
+          v4lmjpegsrc->substract_time;
+
+      /* first check whether we lost any frames according to the device */
+      if (v4lmjpegsrc->last_seq != 0) {
+        if (v4lmjpegsrc->bsync.seq - v4lmjpegsrc->last_seq > 1) {
+          v4lmjpegsrc->need_writes =
+              v4lmjpegsrc->bsync.seq - v4lmjpegsrc->last_seq;
+          g_signal_emit (G_OBJECT (v4lmjpegsrc),
+              gst_v4lmjpegsrc_signals[SIGNAL_FRAME_LOST], 0,
+              v4lmjpegsrc->bsync.seq - v4lmjpegsrc->last_seq - 1);
+        }
+      }
+      v4lmjpegsrc->last_seq = v4lmjpegsrc->bsync.seq;
+
+      /* decide how often we're going to write the frame - set
+       * v4lmjpegsrc->need_writes to (that-1) and have_frame to TRUE
+       * if we're going to write it - else, just continue.
+       * 
+       * time is generally the system or audio clock. Let's
+       * say that we've written one second of audio, then we want
+       * to have written one second of video too, within the same
+       * timeframe. This means that if time - begin_time = X sec,
+       * we want to have written X*fps frames. If we've written
+       * more - drop, if we've written less - dup... */
+      if (cur_frame_time - time > 1.5 * duration) {
+        /* yo dude, we've got too many frames here! Drop! DROP! */
+        v4lmjpegsrc->need_writes--;     /* -= (v4lmjpegsrc->handled - (time / fps)); */
+        g_signal_emit (G_OBJECT (v4lmjpegsrc),
+            gst_v4lmjpegsrc_signals[SIGNAL_FRAME_DROP], 0);
+      } else if (cur_frame_time - time < -1.5 * duration) {
+        /* this means we're lagging far behind */
+        v4lmjpegsrc->need_writes++;     /* += ((time / fps) - v4lmjpegsrc->handled); */
+        g_signal_emit (G_OBJECT (v4lmjpegsrc),
+            gst_v4lmjpegsrc_signals[SIGNAL_FRAME_INSERT], 0);
+      }
+
+      if (v4lmjpegsrc->need_writes > 0) {
+        have_frame = TRUE;
+        v4lmjpegsrc->use_num_times[num] = v4lmjpegsrc->need_writes;
+        v4lmjpegsrc->need_writes--;
+      } else {
+        gst_v4lmjpegsrc_requeue_frame (v4lmjpegsrc, num);
+      }
+    } while (!have_frame);
+  } else {
+    /* grab a frame from the device */
+    if (!gst_v4lmjpegsrc_grab_frame (v4lmjpegsrc, &num,
+            &v4lmjpegsrc->last_size))
+      return NULL;
+
+    v4lmjpegsrc->use_num_times[num] = 1;
+  }
+
+  buf = gst_buffer_new ();
+  GST_BUFFER_FREE_DATA_FUNC (buf) = gst_v4lmjpegsrc_buffer_free;
+  GST_BUFFER_PRIVATE (buf) = v4lmjpegsrc;
+  GST_BUFFER_DATA (buf) = gst_v4lmjpegsrc_get_buffer (v4lmjpegsrc, num);
+  GST_BUFFER_SIZE (buf) = v4lmjpegsrc->last_size;
+  GST_BUFFER_MAXSIZE (buf) = v4lmjpegsrc->breq.size;
+  GST_BUFFER_FLAG_SET (buf, GST_BUFFER_READONLY);
+  GST_BUFFER_FLAG_SET (buf, GST_BUFFER_DONTFREE);
+  if (v4lmjpegsrc->use_fixed_fps)
+    GST_BUFFER_TIMESTAMP (buf) = cur_frame_time;
+  else                          /* calculate time based on our own clock */
+    GST_BUFFER_TIMESTAMP (buf) =
+        GST_TIMEVAL_TO_TIME (v4lmjpegsrc->bsync.timestamp) -
+        v4lmjpegsrc->substract_time;
+
+  v4lmjpegsrc->handled++;
+  g_signal_emit (G_OBJECT (v4lmjpegsrc),
+      gst_v4lmjpegsrc_signals[SIGNAL_FRAME_CAPTURE], 0);
+
+  return GST_DATA (buf);
+}
+
+
+static GstCaps *
+gst_v4lmjpegsrc_getcaps (GstPad * pad)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc = GST_V4LMJPEGSRC (gst_pad_get_parent (pad));
+  struct video_capability *vcap = &GST_V4LELEMENT (v4lmjpegsrc)->vcap;
+  GstCaps *caps;
+  GstStructure *str;
+  gint i;
+  GValue w = { 0 }, h = {
+  0}, w1 = {
+  0}, h1 = {
+  0}, fps = {
+  0};
+
+  if (!GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lmjpegsrc))) {
+    return gst_caps_copy (gst_pad_get_pad_template_caps (pad));
+  }
+
+  g_value_init (&fps, GST_TYPE_FRACTION);
+  gst_return_val_if_fail (gst_v4lmjpegsrc_get_fps (v4lmjpegsrc, &fps), NULL);
+
+  caps = gst_caps_new_simple ("image/jpeg", NULL);
+  str = gst_caps_get_structure (caps, 0);
+  gst_structure_set_value (str, "framerate", &fps);
+  g_value_unset (&fps);
+
+  g_value_init (&w, GST_TYPE_LIST);
+  g_value_init (&h, GST_TYPE_LIST);
+  g_value_init (&w1, G_TYPE_INT);
+  g_value_init (&h1, G_TYPE_INT);
+  for (i = 0; i <= 2; i++) {
+    g_value_set_int (&w1, vcap->maxwidth / (1 << i));
+    g_value_set_int (&h1, vcap->maxheight / (1 << i));
+    gst_value_list_append_value (&w, &w1);
+    gst_value_list_append_value (&h, &h1);
+  }
+  g_value_unset (&h1);
+  g_value_unset (&w1);
+  gst_structure_set_value (str, "width", &w);
+  gst_structure_set_value (str, "height", &h);
+  g_value_unset (&w);
+  g_value_unset (&h);
+
+  return caps;
+}
+
+
+static void
+gst_v4lmjpegsrc_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc;
+
+  g_return_if_fail (GST_IS_V4LMJPEGSRC (object));
+  v4lmjpegsrc = GST_V4LMJPEGSRC (object);
+
+  switch (prop_id) {
+#if 0
+    case ARG_X_OFFSET:
+      v4lmjpegsrc->x_offset = g_value_get_int (value);
+      break;
+    case ARG_Y_OFFSET:
+      v4lmjpegsrc->y_offset = g_value_get_int (value);
+      break;
+    case ARG_F_WIDTH:
+      v4lmjpegsrc->frame_width = g_value_get_int (value);
+      break;
+    case ARG_F_HEIGHT:
+      v4lmjpegsrc->frame_height = g_value_get_int (value);
+      break;
+#endif
+    case ARG_QUALITY:
+      v4lmjpegsrc->quality = g_value_get_int (value);
+      break;
+    case ARG_NUMBUFS:
+      v4lmjpegsrc->numbufs = g_value_get_int (value);
+      break;
+    case ARG_USE_FIXED_FPS:
+      if (!GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc))) {
+        v4lmjpegsrc->use_fixed_fps = g_value_get_boolean (value);
+      }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+
+static void
+gst_v4lmjpegsrc_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc;
+
+  g_return_if_fail (GST_IS_V4LMJPEGSRC (object));
+  v4lmjpegsrc = GST_V4LMJPEGSRC (object);
+
+  switch (prop_id) {
+#if 0
+    case ARG_X_OFFSET:
+      g_value_set_int (value, v4lmjpegsrc->x_offset);
+      break;
+    case ARG_Y_OFFSET:
+      g_value_set_int (value, v4lmjpegsrc->y_offset);
+      break;
+    case ARG_F_WIDTH:
+      g_value_set_int (value, v4lmjpegsrc->frame_width);
+      break;
+    case ARG_F_HEIGHT:
+      g_value_set_int (value, v4lmjpegsrc->frame_height);
+      break;
+#endif
+    case ARG_QUALITY:
+      g_value_set_int (value, v4lmjpegsrc->quality);
+      break;
+    case ARG_NUMBUFS:
+      if (GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc)))
+        g_value_set_int (value, v4lmjpegsrc->breq.count);
+      else
+        g_value_set_int (value, v4lmjpegsrc->numbufs);
+      break;
+    case ARG_BUFSIZE:
+      g_value_set_int (value, v4lmjpegsrc->breq.size);
+      break;
+    case ARG_USE_FIXED_FPS:
+      g_value_set_boolean (value, v4lmjpegsrc->use_fixed_fps);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+
+static GstStateChangeReturn
+gst_v4lmjpegsrc_change_state (GstElement * element, GstStateChange transition)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc;
+  GTimeVal time;
+
+  g_return_val_if_fail (GST_IS_V4LMJPEGSRC (element), GST_STATE_CHANGE_FAILURE);
+
+  v4lmjpegsrc = GST_V4LMJPEGSRC (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      /* actual buffer set-up used to be done here - but I moved
+       * it to capsnego itself */
+      v4lmjpegsrc->handled = 0;
+      v4lmjpegsrc->need_writes = 0;
+      v4lmjpegsrc->last_frame = 0;
+      v4lmjpegsrc->substract_time = 0;
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      /* queue all buffer, start streaming capture */
+      if (GST_V4LELEMENT (v4lmjpegsrc)->buffer &&
+          !gst_v4lmjpegsrc_capture_start (v4lmjpegsrc))
+        return GST_STATE_CHANGE_FAILURE;
+      g_get_current_time (&time);
+      v4lmjpegsrc->substract_time = GST_TIMEVAL_TO_TIME (time) -
+          v4lmjpegsrc->substract_time;
+      v4lmjpegsrc->last_seq = 0;
+      break;
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      g_get_current_time (&time);
+      v4lmjpegsrc->substract_time = GST_TIMEVAL_TO_TIME (time) -
+          v4lmjpegsrc->substract_time;
+      /* de-queue all queued buffers */
+      if (v4lmjpegsrc->is_capturing &&
+          !gst_v4lmjpegsrc_capture_stop (v4lmjpegsrc))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      /* stop capturing, unmap all buffers */
+      if (GST_V4LELEMENT (v4lmjpegsrc)->buffer &&
+          !gst_v4lmjpegsrc_capture_deinit (v4lmjpegsrc))
+        return GST_STATE_CHANGE_FAILURE;
+      break;
+  }
+
+  if (GST_ELEMENT_CLASS (parent_class)->change_state)
+    return GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return GST_STATE_CHANGE_SUCCESS;
+}
+
+
+static void
+gst_v4lmjpegsrc_set_clock (GstElement * element, GstClock * clock)
+{
+  GST_V4LMJPEGSRC (element)->clock = clock;
+}
+
+
+#if 0
+static GstBuffer *
+gst_v4lmjpegsrc_buffer_new (GstBufferPool * pool,
+    guint64 offset, guint size, gpointer user_data)
+{
+  GstBuffer *buffer;
+  GstV4lMjpegSrc *v4lmjpegsrc = GST_V4LMJPEGSRC (user_data);
+
+  if (!GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc)))
+    return NULL;
+
+  buffer = gst_buffer_new ();
+  if (!buffer)
+    return NULL;
+
+  /* TODO: add interlacing info to buffer as metadata */
+  GST_BUFFER_MAXSIZE (buffer) = v4lmjpegsrc->breq.size;
+  GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_DONTFREE);
+
+  return buffer;
+}
+#endif
+
+static void
+gst_v4lmjpegsrc_buffer_free (GstBuffer * buf)
+{
+  GstV4lMjpegSrc *v4lmjpegsrc = GST_V4LMJPEGSRC (GST_BUFFER_PRIVATE (buf));
+  int n;
+
+  if (gst_element_get_state (GST_ELEMENT (v4lmjpegsrc)) != GST_STATE_PLAYING)
+    return;                     /* we've already cleaned up ourselves */
+
+  for (n = 0; n < v4lmjpegsrc->breq.count; n++)
+    if (GST_BUFFER_DATA (buf) == gst_v4lmjpegsrc_get_buffer (v4lmjpegsrc, n)) {
+      v4lmjpegsrc->use_num_times[n]--;
+      if (v4lmjpegsrc->use_num_times[n] <= 0) {
+        gst_v4lmjpegsrc_requeue_frame (v4lmjpegsrc, n);
+      }
+      break;
+    }
+
+  if (n == v4lmjpegsrc->breq.count)
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, TOO_LAZY, (NULL),
+        ("Couldn't find the buffer"));
+}
diff -Naur sys/v4l/v4lmjpegsink_calls.c sys/v4l/v4lmjpegsink_calls.c
--- sys/v4l/v4lmjpegsink_calls.c	1970-01-01 01:00:00.000000000 +0100
+++ sys/v4l/v4lmjpegsink_calls.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,525 @@
+/* GStreamer
+ *
+ * v4lmjpegsink_calls.c: functions for hardware MJPEG video sink
+ *
+ * Copyright (C) 2001-2002 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <errno.h>
+#include "v4lmjpegsink_calls.h"
+
+/* On some systems MAP_FAILED seems to be missing */
+#ifndef MAP_FAILED
+#define MAP_FAILED ( (caddr_t) -1 )
+#endif
+
+GST_DEBUG_CATEGORY_EXTERN (v4lmjpegsink_debug);
+#define GST_CAT_DEFAULT v4lmjpegsink_debug
+
+/******************************************************
+ * gst_v4lmjpegsink_sync_thread()
+ *   thread keeps track of played frames
+ ******************************************************/
+
+static void *
+gst_v4lmjpegsink_sync_thread (void *arg)
+{
+  GstV4lMjpegSink *v4lmjpegsink = GST_V4LMJPEGSINK (arg);
+  gint frame = 0;               /* frame that we're currently syncing on */
+
+  GST_DEBUG_OBJECT (v4lmjpegsink, "starting sync thread");
+
+#if 0
+  /* Allow easy shutting down by other processes... */
+  pthread_setcancelstate (PTHREAD_CANCEL_ENABLE, NULL);
+  pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
+#endif
+
+  while (1) {
+    g_mutex_lock (v4lmjpegsink->mutex_queued_frames);
+    if (!v4lmjpegsink->isqueued_queued_frames[frame]) {
+      g_cond_wait (v4lmjpegsink->cond_queued_frames[frame],
+          v4lmjpegsink->mutex_queued_frames);
+    }
+    if (v4lmjpegsink->isqueued_queued_frames[frame] != 1) {
+      g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+      goto end;
+    }
+    g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+
+    GST_DEBUG_OBJECT (v4lmjpegsink, "thread-syncing on next frame");
+    if (ioctl (GST_V4LELEMENT (v4lmjpegsink)->video_fd, MJPIOC_SYNC,
+            &(v4lmjpegsink->bsync)) < 0) {
+      GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, SYNC, (NULL),
+          ("Failed to sync on frame %d: %s", frame, g_strerror (errno)));
+      g_mutex_lock (v4lmjpegsink->mutex_queued_frames);
+      v4lmjpegsink->isqueued_queued_frames[frame] = -1;
+      g_cond_broadcast (v4lmjpegsink->cond_queued_frames[frame]);
+      g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+      goto end;
+    } else {
+      /* be sure that we're not confusing */
+      if (frame != v4lmjpegsink->bsync.frame) {
+        GST_ELEMENT_ERROR (v4lmjpegsink, CORE, TOO_LAZY, (NULL),
+            ("Internal error: frame number confusion"));
+        goto end;
+      }
+      g_mutex_lock (v4lmjpegsink->mutex_queued_frames);
+      v4lmjpegsink->isqueued_queued_frames[frame] = 0;
+      g_cond_broadcast (v4lmjpegsink->cond_queued_frames[frame]);
+      g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+    }
+
+    frame = (frame + 1) % v4lmjpegsink->breq.count;
+  }
+
+end:
+  GST_DEBUG_OBJECT (v4lmjpegsink, "Sync thread got signalled to exit");
+  g_thread_exit (NULL);
+  return NULL;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_queue_frame()
+ *   queue a frame for playback
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+static gboolean
+gst_v4lmjpegsink_queue_frame (GstV4lMjpegSink * v4lmjpegsink, gint num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsink, "queueing frame %d", num);
+
+  /* queue on this frame */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsink)->video_fd, MJPIOC_QBUF_PLAY,
+          &num) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, WRITE, (NULL),
+        ("Failed to queue frame %d: %s", num, g_strerror (errno)));
+    return FALSE;
+  }
+
+  g_mutex_lock (v4lmjpegsink->mutex_queued_frames);
+  v4lmjpegsink->isqueued_queued_frames[num] = 1;
+  g_cond_broadcast (v4lmjpegsink->cond_queued_frames[num]);
+  g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_sync_frame()
+ *   wait for a frame to be finished playing
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+static gboolean
+gst_v4lmjpegsink_sync_frame (GstV4lMjpegSink * v4lmjpegsink, gint * num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsink, "syncing on next frame");
+
+  /* calculate next frame */
+  v4lmjpegsink->current_frame =
+      (v4lmjpegsink->current_frame + 1) % v4lmjpegsink->breq.count;
+  *num = v4lmjpegsink->current_frame;
+
+  g_mutex_lock (v4lmjpegsink->mutex_queued_frames);
+  if (v4lmjpegsink->isqueued_queued_frames[*num] == 1) {
+    g_cond_wait (v4lmjpegsink->cond_queued_frames[*num],
+        v4lmjpegsink->mutex_queued_frames);
+  }
+  if (v4lmjpegsink->isqueued_queued_frames[*num] != 0) {
+    g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+    return FALSE;
+  } else
+    g_mutex_unlock (v4lmjpegsink->mutex_queued_frames);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_set_buffer()
+ *   set buffer options
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_set_buffer (GstV4lMjpegSink * v4lmjpegsink,
+    gint numbufs, gint bufsize)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsink,
+      "setting buffer info to numbufs = %d, bufsize = %d KB", numbufs, bufsize);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_NOT_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  v4lmjpegsink->breq.size = bufsize * 1024;
+  v4lmjpegsink->breq.count = numbufs;
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_set_playback()
+ *   set playback options (video, interlacing, etc.)
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_set_playback (GstV4lMjpegSink * v4lmjpegsink,
+    gint width,
+    gint height, gint x_offset, gint y_offset, gint norm, gint interlacing)
+{
+  gint mw, mh;
+  struct mjpeg_params bparm;
+
+  GST_DEBUG_OBJECT (v4lmjpegsink,
+      "setting size=%dx%d, X/Y offsets=%d/%d, norm=%d, interlacing=%d\n",
+      width, height, x_offset, y_offset, norm, interlacing);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  /*GST_V4L_CHECK_NOT_ACTIVE(GST_V4LELEMENT(v4lmjpegsink)); */
+
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsink)->video_fd, MJPIOC_G_PARAMS,
+          &bparm) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, SETTINGS, (NULL),
+        GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  bparm.input = 0;
+  bparm.norm = norm;
+  bparm.decimation = 0;         /* we'll set proper values later on */
+
+  /* maxwidth is broken on marvel cards */
+  mw = GST_V4LELEMENT (v4lmjpegsink)->vcap.maxwidth;
+  if (mw != 768 && mw != 640)
+    mw = 720;
+  mh = (norm == VIDEO_MODE_NTSC ? 480 : 576);
+
+  if (width > mw || height > mh) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, TOO_LAZY, (NULL),
+        ("Video dimensions (%dx%d) are larger than device max (%dx%d)",
+            width, height, mw, mh));
+    return FALSE;
+  }
+
+  if (width <= mw / 4)
+    bparm.HorDcm = 4;
+  else if (width <= mw / 2)
+    bparm.HorDcm = 2;
+  else
+    bparm.HorDcm = 1;
+
+  /* TODO: add proper interlacing handling */
+#if 0
+  if (interlacing != INTERLACING_NOT_INTERLACED) {
+    bparm.field_per_buff = 2;
+    bparm.TmpDcm = 1;
+
+    if (height <= mh / 2)
+      bparm.VerDcm = 2;
+    else
+      bparm.VerDcm = 1;
+  } else
+#endif
+  {
+    if (height > mh / 2) {
+      GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, TOO_LAZY, (NULL),
+          ("Video dimensions (%dx%d) too large for non-interlaced playback (%dx%d)",
+              width, height, mw, mh / 2));
+      return FALSE;
+    }
+
+    bparm.field_per_buff = 1;
+    bparm.TmpDcm = 2;
+
+    if (height <= mh / 4)
+      bparm.VerDcm = 2;
+    else
+      bparm.VerDcm = 1;
+  }
+
+  /* TODO: add proper interlacing handling */
+#if 0
+  bparm.odd_even = (interlacing == INTERLACING_TOP_FIRST);
+#endif
+
+  bparm.quality = 100;
+  bparm.img_width = bparm.HorDcm * width;
+  bparm.img_height = bparm.VerDcm * height / bparm.field_per_buff;
+
+  /* image X/Y offset on device */
+  if (x_offset < 0)
+    bparm.img_x = (mw - bparm.img_width) / 2;
+  else {
+    if (x_offset + bparm.img_width > mw)
+      bparm.img_x = mw - bparm.img_width;
+    else
+      bparm.img_x = x_offset;
+  }
+
+  if (y_offset < 0)
+    bparm.img_y = (mh / 2 - bparm.img_height) / 2;
+  else {
+    if (y_offset + bparm.img_height * 2 > mh)
+      bparm.img_y = mh / 2 - bparm.img_height;
+    else
+      bparm.img_y = y_offset / 2;
+  }
+
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsink)->video_fd, MJPIOC_S_PARAMS,
+          &bparm) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, SETTINGS, (NULL),
+        GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_playback_init()
+ *   initialize playback system, set up buffer, etc.
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_playback_init (GstV4lMjpegSink * v4lmjpegsink)
+{
+  gint n;
+
+  GST_DEBUG_OBJECT (v4lmjpegsink, "initting playback subsystem");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_NOT_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  /* Request buffers */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsink)->video_fd, MJPIOC_REQBUFS,
+          &(v4lmjpegsink->breq)) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, READ, (NULL), GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  GST_INFO_OBJECT (v4lmjpegsink, "Got %ld buffers of size %ld KB",
+      v4lmjpegsink->breq.count, v4lmjpegsink->breq.size / 1024);
+
+  /* Map the buffers */
+  GST_V4LELEMENT (v4lmjpegsink)->buffer = mmap (0,
+      v4lmjpegsink->breq.count * v4lmjpegsink->breq.size,
+      PROT_READ | PROT_WRITE, MAP_SHARED,
+      GST_V4LELEMENT (v4lmjpegsink)->video_fd, 0);
+  if (GST_V4LELEMENT (v4lmjpegsink)->buffer == MAP_FAILED) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, TOO_LAZY, (NULL),
+        ("Error mapping video buffers: %s", g_strerror (errno)));
+    GST_V4LELEMENT (v4lmjpegsink)->buffer = NULL;
+    return FALSE;
+  }
+
+  /* allocate/init the GThread thingies */
+  v4lmjpegsink->mutex_queued_frames = g_mutex_new ();
+  v4lmjpegsink->isqueued_queued_frames = (gint8 *)
+      malloc (sizeof (gint8) * v4lmjpegsink->breq.count);
+  if (!v4lmjpegsink->isqueued_queued_frames) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, TOO_LAZY, (NULL),
+        ("Failed to create queue tracker: %s", g_strerror (errno)));
+    return FALSE;
+  }
+  v4lmjpegsink->cond_queued_frames = (GCond **)
+      malloc (sizeof (GCond *) * v4lmjpegsink->breq.count);
+  if (!v4lmjpegsink->cond_queued_frames) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, TOO_LAZY, (NULL),
+        ("Failed to create queue condition holders: %s", g_strerror (errno)));
+    return FALSE;
+  }
+  for (n = 0; n < v4lmjpegsink->breq.count; n++)
+    v4lmjpegsink->cond_queued_frames[n] = g_cond_new ();
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_playback_start()
+ *   start playback system
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_playback_start (GstV4lMjpegSink * v4lmjpegsink)
+{
+  GError *error;
+  gint n;
+
+  GST_DEBUG_OBJECT (v4lmjpegsink, "starting playback");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  /* mark all buffers as unqueued */
+  for (n = 0; n < v4lmjpegsink->breq.count; n++)
+    v4lmjpegsink->isqueued_queued_frames[n] = 0;
+
+  v4lmjpegsink->current_frame = -1;
+
+  /* create sync() thread */
+  v4lmjpegsink->thread_queued_frames =
+      g_thread_create (gst_v4lmjpegsink_sync_thread, (void *) v4lmjpegsink,
+      TRUE, &error);
+  if (!v4lmjpegsink->thread_queued_frames) {
+    GST_ELEMENT_ERROR (v4lmjpegsink, RESOURCE, TOO_LAZY, (NULL),
+        ("Failed to create sync thread: %s", error->message));
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_get_buffer()
+ *   get address of a buffer
+ * return value: buffer's address or NULL
+ ******************************************************/
+
+guint8 *
+gst_v4lmjpegsink_get_buffer (GstV4lMjpegSink * v4lmjpegsink, gint num)
+{
+  /*GST_DEBUG_OBJECT (v4lmjpegsink, gst_v4lmjpegsink_get_buffer(), num = %d", num); */
+
+  if (!GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsink)) ||
+      !GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lmjpegsink)))
+    return NULL;
+
+  if (num < 0 || num >= v4lmjpegsink->breq.count)
+    return NULL;
+
+  return GST_V4LELEMENT (v4lmjpegsink)->buffer +
+      (v4lmjpegsink->breq.size * num);
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_play_frame()
+ *   queue a new buffer
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_play_frame (GstV4lMjpegSink * v4lmjpegsink, gint num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsink, "playing frame %d", num);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  if (!gst_v4lmjpegsink_queue_frame (v4lmjpegsink, num))
+    return FALSE;
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_wait_frame()
+ *   wait for buffer to be actually played
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_wait_frame (GstV4lMjpegSink * v4lmjpegsink, gint * num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsink,
+      "waiting for next frame to be finished playing");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  if (!gst_v4lmjpegsink_sync_frame (v4lmjpegsink, num))
+    return FALSE;
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_playback_stop()
+ *   stop playback system and sync on remaining frames
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_playback_stop (GstV4lMjpegSink * v4lmjpegsink)
+{
+  gint num;
+
+  GST_DEBUG_OBJECT (v4lmjpegsink, "stopping playback");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  /* mark next buffer as wrong */
+  if (!gst_v4lmjpegsink_sync_frame (v4lmjpegsink, &num) ||
+      !gst_v4lmjpegsink_queue_frame (v4lmjpegsink, num)) {
+    return FALSE;
+  }
+
+  /* .. and wait for all buffers to be queued on */
+  g_thread_join (v4lmjpegsink->thread_queued_frames);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsink_playback_deinit()
+ *   deinitialize the playback system and unmap buffer
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsink_playback_deinit (GstV4lMjpegSink * v4lmjpegsink)
+{
+  int n;
+
+  GST_DEBUG_OBJECT (v4lmjpegsink, "quitting playback subsystem");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsink));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsink));
+
+  /* free GThread thingies */
+  g_mutex_free (v4lmjpegsink->mutex_queued_frames);
+  for (n = 0; n < v4lmjpegsink->breq.count; n++)
+    g_cond_free (v4lmjpegsink->cond_queued_frames[n]);
+  free (v4lmjpegsink->cond_queued_frames);
+  free (v4lmjpegsink->isqueued_queued_frames);
+
+  /* unmap the buffer */
+  munmap (GST_V4LELEMENT (v4lmjpegsink)->buffer,
+      v4lmjpegsink->breq.size * v4lmjpegsink->breq.count);
+  GST_V4LELEMENT (v4lmjpegsink)->buffer = NULL;
+
+  return TRUE;
+}
diff -Naur sys/v4l/v4lmjpegsrc_calls.c sys/v4l/v4lmjpegsrc_calls.c
--- sys/v4l/v4lmjpegsrc_calls.c	1970-01-01 01:00:00.000000000 +0100
+++ sys/v4l/v4lmjpegsrc_calls.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,577 @@
+/* GStreamer
+ *
+ * v4lmjpegsrc_calls.c: functions for hardware MJPEG video source
+ *
+ * Copyright (C) 2001-2002 Ronald Bultje <rbultje@ronald.bitfreak.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <string.h>
+#include <errno.h>
+#include "v4lmjpegsrc_calls.h"
+
+/* On some systems MAP_FAILED seems to be missing */
+#ifndef MAP_FAILED
+#define MAP_FAILED ( (caddr_t) -1 )
+#endif
+
+#define MIN_BUFFERS_QUEUED 2
+
+GST_DEBUG_CATEGORY_EXTERN (v4lmjpegsrc_debug);
+#define GST_CAT_DEFAULT v4lmjpegsrc_debug
+
+enum
+{
+  QUEUE_STATE_ERROR = -1,
+  QUEUE_STATE_READY_FOR_QUEUE,
+  QUEUE_STATE_QUEUED,
+  QUEUE_STATE_SYNCED,
+};
+
+/******************************************************
+ * gst_v4lmjpegsrc_queue_frame():
+ *   queue a frame for capturing
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+static gboolean
+gst_v4lmjpegsrc_queue_frame (GstV4lMjpegSrc * v4lmjpegsrc, gint num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "queueing frame %d", num);
+
+  if (v4lmjpegsrc->frame_queue_state[num] != QUEUE_STATE_READY_FOR_QUEUE) {
+    return FALSE;
+  }
+
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd, MJPIOC_QBUF_CAPT,
+          &num) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, READ, (NULL),
+        ("Error queueing a buffer (%d): %s", num, g_strerror (errno)));
+    return FALSE;
+  }
+
+  v4lmjpegsrc->frame_queue_state[num] = QUEUE_STATE_QUEUED;
+  v4lmjpegsrc->num_queued++;
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_sync_next_frame():
+ *   sync on the next frame for capturing
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+static gboolean
+gst_v4lmjpegsrc_sync_next_frame (GstV4lMjpegSrc * v4lmjpegsrc, gint * num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "syncing on next frame");
+
+  if (v4lmjpegsrc->num_queued <= 0) {
+    return FALSE;
+  }
+
+  while (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd,
+          MJPIOC_SYNC, &(v4lmjpegsrc->bsync)) < 0) {
+    if (errno != EINTR) {
+      GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, SYNC, (NULL), GST_ERROR_SYSTEM);
+      return FALSE;
+    }
+    GST_DEBUG_OBJECT (v4lmjpegsrc, "Sync got interrupted");
+  }
+
+  *num = v4lmjpegsrc->bsync.frame;
+
+  v4lmjpegsrc->frame_queue_state[*num] = QUEUE_STATE_SYNCED;
+  v4lmjpegsrc->num_queued--;
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_set_buffer():
+ *   set buffer parameters (size/count)
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_set_buffer (GstV4lMjpegSrc * v4lmjpegsrc,
+    gint numbufs, gint bufsize)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc,
+      "setting buffer info to numbufs = %d, bufsize = %d KB", numbufs, bufsize);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_NOT_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  v4lmjpegsrc->breq.size = bufsize * 1024;
+  v4lmjpegsrc->breq.count = numbufs;
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_set_capture():
+ *   set capture parameters (simple)
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_set_capture (GstV4lMjpegSrc * v4lmjpegsrc,
+    gint decimation, gint quality)
+{
+  int norm, input, mw;
+  struct mjpeg_params bparm;
+
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "setting decimation = %d, quality = %d",
+      decimation, quality);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_NOT_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  gst_v4l_get_chan_norm (GST_V4LELEMENT (v4lmjpegsrc), &input, &norm);
+
+  /* Query params for capture */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd, MJPIOC_G_PARAMS,
+          &bparm) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, SETTINGS, (NULL),
+        GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  bparm.decimation = decimation;
+  bparm.quality = quality;
+  bparm.norm = norm;
+  bparm.input = input;
+  bparm.APP_len = 0;            /* no JPEG markers - TODO: this is definately not right for decimation==1 */
+
+  mw = GST_V4LELEMENT (v4lmjpegsrc)->vcap.maxwidth;
+  if (mw != 768 && mw != 640) {
+    if (decimation == 1)
+      mw = 720;
+    else
+      mw = 704;
+  }
+  v4lmjpegsrc->end_width = mw / decimation;
+  v4lmjpegsrc->end_height = (norm == VIDEO_MODE_NTSC ? 480 : 576) / decimation;
+
+  /* TODO: interlacing */
+
+  /* Set params for capture */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd, MJPIOC_S_PARAMS,
+          &bparm) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, SETTINGS, (NULL),
+        GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_set_capture_m():
+ *   set capture parameters (advanced)
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_set_capture_m (GstV4lMjpegSrc * v4lmjpegsrc,
+    gint x_offset,
+    gint y_offset,
+    gint width, gint height, gint h_decimation, gint v_decimation, gint quality)
+{
+  gint norm, input;
+  gint maxwidth;
+  struct mjpeg_params bparm;
+
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "setting x_offset = %d, y_offset = %d, "
+      "width = %d, height = %d, h_decimation = %d, v_decimation = %d, quality = %d\n",
+      x_offset, y_offset, width, height, h_decimation, v_decimation, quality);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_NOT_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  gst_v4l_get_chan_norm (GST_V4LELEMENT (v4lmjpegsrc), &input, &norm);
+
+  if (GST_V4LELEMENT (v4lmjpegsrc)->vcap.maxwidth != 768 &&
+      GST_V4LELEMENT (v4lmjpegsrc)->vcap.maxwidth != 640)
+    maxwidth = 720;
+  else
+    maxwidth = GST_V4LELEMENT (v4lmjpegsrc)->vcap.maxwidth;
+
+  /* Query params for capture */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd, MJPIOC_G_PARAMS,
+          &bparm) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, SETTINGS, (NULL),
+        GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  bparm.decimation = 0;
+  bparm.quality = quality;
+  bparm.norm = norm;
+  bparm.input = input;
+  bparm.APP_len = 0;            /* no JPEG markers - TODO: this is definately
+                                 * not right for decimation==1 */
+
+  if (width <= 0) {
+    if (x_offset < 0)
+      x_offset = 0;
+    width = (maxwidth == 720
+        && h_decimation != 1) ? 704 : maxwidth - 2 * x_offset;
+  } else {
+    if (x_offset < 0)
+      x_offset = (maxwidth - width) / 2;
+  }
+
+  if (height <= 0) {
+    if (y_offset < 0)
+      y_offset = 0;
+    height = (norm == VIDEO_MODE_NTSC) ? 480 : 576 - 2 * y_offset;
+  } else {
+    if (y_offset < 0)
+      y_offset = ((norm == VIDEO_MODE_NTSC) ? 480 : 576 - height) / 2;
+  }
+
+  if (width + x_offset > maxwidth) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, TOO_LAZY, (NULL),
+        ("Image width+offset (%d) bigger than maximum (%d)",
+            width + x_offset, maxwidth));
+    return FALSE;
+  }
+  if ((width % (bparm.HorDcm * 16)) != 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, STREAM, FORMAT, (NULL),
+        ("Image width (%d) not multiple of %d (required for JPEG)",
+            width, bparm.HorDcm * 16));
+    return FALSE;
+  }
+  if (height + y_offset > (norm == VIDEO_MODE_NTSC ? 480 : 576)) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, TOO_LAZY, (NULL),
+        ("Image height+offset (%d) bigger than maximum (%d)",
+            height + y_offset, (norm == VIDEO_MODE_NTSC ? 480 : 576)));
+    return FALSE;
+  }
+  /* RJ: Image height must only be a multiple of 8, but geom_height
+   * is double the field height
+   */
+  if ((height % (bparm.VerDcm * 16)) != 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, STREAM, FORMAT, (NULL),
+        ("Image height (%d) not multiple of %d (required for JPEG)",
+            height, bparm.VerDcm * 16));
+    return FALSE;
+  }
+
+  bparm.img_x = x_offset;
+  bparm.img_width = width;
+  bparm.img_y = y_offset;
+  bparm.img_height = height;
+  bparm.HorDcm = h_decimation;
+  bparm.VerDcm = (v_decimation == 4) ? 2 : 1;
+  bparm.TmpDcm = (v_decimation == 1) ? 1 : 2;
+  bparm.field_per_buff = (v_decimation == 1) ? 2 : 1;
+
+  v4lmjpegsrc->end_width = width / h_decimation;
+  v4lmjpegsrc->end_width = height / v_decimation;
+
+  /* TODO: interlacing */
+
+  /* Set params for capture */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd, MJPIOC_S_PARAMS,
+          &bparm) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, SETTINGS, (NULL),
+        GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_capture_init():
+ *   initialize the capture system
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_capture_init (GstV4lMjpegSrc * v4lmjpegsrc)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "initting capture subsystem");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_NOT_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  /* Request buffers */
+  if (ioctl (GST_V4LELEMENT (v4lmjpegsrc)->video_fd,
+          MJPIOC_REQBUFS, &(v4lmjpegsrc->breq)) < 0) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, READ, (NULL), GST_ERROR_SYSTEM);
+    return FALSE;
+  }
+
+  if (v4lmjpegsrc->breq.count < MIN_BUFFERS_QUEUED) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, READ, (NULL),
+        ("Too little buffers. We got %ld, we want at least %d",
+            v4lmjpegsrc->breq.count, MIN_BUFFERS_QUEUED));
+    return FALSE;
+  }
+
+  GST_INFO_OBJECT (v4lmjpegsrc, "Got %ld buffers of size %ld KB",
+      v4lmjpegsrc->breq.count, v4lmjpegsrc->breq.size / 1024);
+
+  /* keep track of queued buffers */
+  v4lmjpegsrc->frame_queue_state = (gint8 *)
+      g_malloc (sizeof (gint8) * v4lmjpegsrc->breq.count);
+
+  /* track how often to use each frame */
+  v4lmjpegsrc->use_num_times = (gint *)
+      g_malloc (sizeof (gint) * v4lmjpegsrc->breq.count);
+
+  /* lock for the frame_state */
+  v4lmjpegsrc->mutex_queue_state = g_mutex_new ();
+  v4lmjpegsrc->cond_queue_state = g_cond_new ();
+
+  /* Map the buffers */
+  GST_V4LELEMENT (v4lmjpegsrc)->buffer = mmap (0,
+      v4lmjpegsrc->breq.count * v4lmjpegsrc->breq.size,
+      PROT_READ | PROT_WRITE, MAP_SHARED,
+      GST_V4LELEMENT (v4lmjpegsrc)->video_fd, 0);
+  if (GST_V4LELEMENT (v4lmjpegsrc)->buffer == MAP_FAILED) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, TOO_LAZY, (NULL),
+        ("Error mapping video buffers: %s", g_strerror (errno)));
+    GST_V4LELEMENT (v4lmjpegsrc)->buffer = NULL;
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_capture_start():
+ *   start streaming capture
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_capture_start (GstV4lMjpegSrc * v4lmjpegsrc)
+{
+  int n;
+
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "starting capture");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  g_mutex_lock (v4lmjpegsrc->mutex_queue_state);
+
+  v4lmjpegsrc->quit = FALSE;
+  v4lmjpegsrc->num_queued = 0;
+  v4lmjpegsrc->queue_frame = 0;
+
+  /* set all buffers ready to queue , this starts streaming capture */
+  for (n = 0; n < v4lmjpegsrc->breq.count; n++) {
+    v4lmjpegsrc->frame_queue_state[n] = QUEUE_STATE_READY_FOR_QUEUE;
+    if (!gst_v4lmjpegsrc_queue_frame (v4lmjpegsrc, n)) {
+      g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+      gst_v4lmjpegsrc_capture_stop (v4lmjpegsrc);
+      return FALSE;
+    }
+  }
+
+  v4lmjpegsrc->is_capturing = TRUE;
+  g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_grab_frame():
+ *   grab one frame during streaming capture
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_grab_frame (GstV4lMjpegSrc * v4lmjpegsrc,
+    gint * num, gint * size)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "grabbing frame");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  g_mutex_lock (v4lmjpegsrc->mutex_queue_state);
+
+  /* do we have enough frames? */
+  while (v4lmjpegsrc->num_queued < MIN_BUFFERS_QUEUED ||
+      v4lmjpegsrc->frame_queue_state[v4lmjpegsrc->queue_frame] ==
+      QUEUE_STATE_READY_FOR_QUEUE) {
+    while (v4lmjpegsrc->frame_queue_state[v4lmjpegsrc->queue_frame] !=
+        QUEUE_STATE_READY_FOR_QUEUE && !v4lmjpegsrc->quit) {
+      GST_DEBUG_OBJECT (v4lmjpegsrc,
+          "Waiting for frames to become available (%d < %d)",
+          v4lmjpegsrc->num_queued, MIN_BUFFERS_QUEUED);
+      g_cond_wait (v4lmjpegsrc->cond_queue_state,
+          v4lmjpegsrc->mutex_queue_state);
+    }
+    if (v4lmjpegsrc->quit) {
+      g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+      return TRUE;              /* it won't get through anyway */
+    }
+    if (!gst_v4lmjpegsrc_queue_frame (v4lmjpegsrc, v4lmjpegsrc->queue_frame)) {
+      g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+      return FALSE;
+    }
+    v4lmjpegsrc->queue_frame =
+        (v4lmjpegsrc->queue_frame + 1) % v4lmjpegsrc->breq.count;
+  }
+
+  /* syncing on the buffer grabs it */
+  if (!gst_v4lmjpegsrc_sync_next_frame (v4lmjpegsrc, num)) {
+    return FALSE;
+  }
+
+  *size = v4lmjpegsrc->bsync.length;
+
+  g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_get_buffer():
+ *   get the memory address of a single buffer
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+guint8 *
+gst_v4lmjpegsrc_get_buffer (GstV4lMjpegSrc * v4lmjpegsrc, gint num)
+{
+  /*DEBUG("gst_v4lmjpegsrc_get_buffer(), num = %d", num); */
+
+  if (!GST_V4L_IS_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc)) ||
+      !GST_V4L_IS_OPEN (GST_V4LELEMENT (v4lmjpegsrc)))
+    return NULL;
+
+  if (num < 0 || num >= v4lmjpegsrc->breq.count)
+    return NULL;
+
+  return GST_V4LELEMENT (v4lmjpegsrc)->buffer + (v4lmjpegsrc->breq.size * num);
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_requeue_frame():
+ *   requeue a frame for capturing
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_requeue_frame (GstV4lMjpegSrc * v4lmjpegsrc, gint num)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "requeueing frame %d", num);
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  /* mark frame as 'ready to requeue' */
+  g_mutex_lock (v4lmjpegsrc->mutex_queue_state);
+
+  if (v4lmjpegsrc->frame_queue_state[num] != QUEUE_STATE_SYNCED) {
+    GST_ELEMENT_ERROR (v4lmjpegsrc, RESOURCE, TOO_LAZY, (NULL),
+        ("Invalid state %d (expected %d), can't requeue",
+            v4lmjpegsrc->frame_queue_state[num], QUEUE_STATE_SYNCED));
+    return FALSE;
+  }
+
+  v4lmjpegsrc->frame_queue_state[num] = QUEUE_STATE_READY_FOR_QUEUE;
+
+  /* let an optional wait know */
+  g_cond_broadcast (v4lmjpegsrc->cond_queue_state);
+
+  g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_capture_stop():
+ *   stop streaming capture
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_capture_stop (GstV4lMjpegSrc * v4lmjpegsrc)
+{
+  int n;
+
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "stopping capture");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  g_mutex_lock (v4lmjpegsrc->mutex_queue_state);
+
+  /* make an optional pending wait stop */
+  v4lmjpegsrc->quit = TRUE;
+  g_cond_broadcast (v4lmjpegsrc->cond_queue_state);
+
+  /* sync on remaining frames */
+  while (v4lmjpegsrc->num_queued > 0) {
+    gst_v4lmjpegsrc_sync_next_frame (v4lmjpegsrc, &n);
+  }
+
+  v4lmjpegsrc->is_capturing = FALSE;
+  g_mutex_unlock (v4lmjpegsrc->mutex_queue_state);
+
+  return TRUE;
+}
+
+
+/******************************************************
+ * gst_v4lmjpegsrc_capture_deinit():
+ *   deinitialize the capture system
+ * return value: TRUE on success, FALSE on error
+ ******************************************************/
+
+gboolean
+gst_v4lmjpegsrc_capture_deinit (GstV4lMjpegSrc * v4lmjpegsrc)
+{
+  GST_DEBUG_OBJECT (v4lmjpegsrc, "quitting capture subsystem");
+  GST_V4L_CHECK_OPEN (GST_V4LELEMENT (v4lmjpegsrc));
+  GST_V4L_CHECK_ACTIVE (GST_V4LELEMENT (v4lmjpegsrc));
+
+  /* unmap the buffer */
+  munmap (GST_V4LELEMENT (v4lmjpegsrc)->buffer,
+      v4lmjpegsrc->breq.size * v4lmjpegsrc->breq.count);
+  GST_V4LELEMENT (v4lmjpegsrc)->buffer = NULL;
+
+  /* free buffer tracker */
+  g_mutex_free (v4lmjpegsrc->mutex_queue_state);
+  g_cond_free (v4lmjpegsrc->cond_queue_state);
+  g_free (v4lmjpegsrc->frame_queue_state);
+  g_free (v4lmjpegsrc->use_num_times);
+
+  return TRUE;
+}
diff -Naur tests/check/elements/audioresample.c tests/check/elements/audioresample.c
--- tests/check/elements/audioresample.c	2009-04-15 21:18:28.000000000 +0200
+++ tests/check/elements/audioresample.c	2009-05-19 18:44:45.000000000 +0200
@@ -689,7 +689,7 @@
 
   pipeline = gst_parse_launch ("audiotestsrc num-buffers=1 name=src ! "
       "audioresample ! audio/x-raw-int,channels=1,width=16,depth=16,"
-      "endianness=1234,signed=true,rate=8000 ! "
+      "endianness=BYTE_ORDER,signed=true,rate=8000 ! "
       "fakesink can-activate-pull=false", &error);
   fail_unless (pipeline != NULL, "Error parsing pipeline: %s",
       error ? error->message : "(invalid error)");
diff -Naur tests/examples/seek/seek.c tests/examples/seek/seek.c
--- tests/examples/seek/seek.c	2009-04-15 21:18:28.000000000 +0200
+++ tests/examples/seek/seek.c	2009-05-19 18:44:45.000000000 +0200
@@ -638,29 +638,32 @@
 make_mp3_pipeline (const gchar * location)
 {
   GstElement *pipeline;
-  GstElement *src, *decoder, *osssink, *queue;
+  GstElement *src, *parser, *decoder, *audiosink, *queue;
   GstPad *seekable;
 
   pipeline = gst_pipeline_new ("app");
 
   src = gst_element_factory_make_or_warn (SOURCE, "src");
+  parser = gst_element_factory_make_or_warn ("mp3parse", "parse");
   decoder = gst_element_factory_make_or_warn ("mad", "dec");
   queue = gst_element_factory_make_or_warn ("queue", "queue");
-  osssink = gst_element_factory_make_or_warn (ASINK, "sink");
+  audiosink = gst_element_factory_make_or_warn (ASINK, "sink");
 
-  seekable_elements = g_list_prepend (seekable_elements, osssink);
+  seekable_elements = g_list_prepend (seekable_elements, audiosink);
 
   g_object_set (G_OBJECT (src), "location", location, NULL);
-  //g_object_set (G_OBJECT (osssink), "fragment", 0x00180008, NULL);
+  //g_object_set (G_OBJECT (audiosink), "fragment", 0x00180008, NULL);
 
   gst_bin_add (GST_BIN (pipeline), src);
+  gst_bin_add (GST_BIN (pipeline), parser);
   gst_bin_add (GST_BIN (pipeline), decoder);
   gst_bin_add (GST_BIN (pipeline), queue);
-  gst_bin_add (GST_BIN (pipeline), osssink);
+  gst_bin_add (GST_BIN (pipeline), audiosink);
 
-  gst_element_link (src, decoder);
+  gst_element_link (src, parser);
+  gst_element_link (parser, decoder);
   gst_element_link (decoder, queue);
-  gst_element_link (queue, osssink);
+  gst_element_link (queue, audiosink);
 
   seekable = gst_element_get_static_pad (queue, "src");
   seekable_pads = g_list_prepend (seekable_pads, seekable);
@@ -2181,6 +2184,17 @@
 }
 #endif
 
+static gboolean
+handle_expose_cb (GtkWidget * widget, GdkEventExpose * event, gpointer data)
+{
+  if (state < GST_STATE_PAUSED) {
+    gdk_draw_rectangle (widget->window, widget->style->black_gc, TRUE,
+        0, 0, widget->allocation.width, widget->allocation.height);
+  }
+  return FALSE;
+}
+
+
 static void
 msg_eos (GstBus * bus, GstMessage * message, GstPipeline * data)
 {
@@ -2295,7 +2309,8 @@
 int
 main (int argc, char **argv)
 {
-  GtkWidget *window, *hbox, *vbox, *panel, *boxes, *flagtable, *boxes2;
+  GtkWidget *window, *hbox, *vbox, *panel, *expander, *pb2vbox, *boxes,
+      *flagtable, *boxes2;
   GtkWidget *play_button, *pause_button, *stop_button, *shot_button;
   GtkWidget *accurate_checkbox, *key_checkbox, *loop_checkbox, *flush_checkbox;
   GtkWidget *scrub_checkbox, *play_scrub_checkbox, *rate_spinbutton;
@@ -2363,6 +2378,8 @@
   tips = gtk_tooltips_new ();
   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
   video_window = gtk_drawing_area_new ();
+  g_signal_connect (G_OBJECT (video_window), "expose-event",
+      G_CALLBACK (handle_expose_cb), NULL);
   gtk_widget_set_double_buffered (video_window, FALSE);
   statusbar = gtk_statusbar_new ();
   status_id = gtk_statusbar_get_context_id (GTK_STATUSBAR (statusbar), "seek");
@@ -2417,6 +2434,7 @@
       GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.00, 100.0, 0.1, 1.0, 1.0));
   hscale = gtk_hscale_new (adjustment);
   gtk_scale_set_digits (GTK_SCALE (hscale), 2);
+  gtk_scale_set_value_pos (GTK_SCALE (hscale), GTK_POS_RIGHT);
 #if GTK_CHECK_VERSION(2,12,0)
   gtk_range_set_show_fill_level (GTK_RANGE (hscale), TRUE);
   gtk_range_set_fill_level (GTK_RANGE (hscale), 100.0);
@@ -2525,9 +2543,13 @@
   gtk_table_attach_defaults (GTK_TABLE (flagtable), rate_spinbutton, 4, 5, 1,
       2);
   if (panel && boxes && boxes2) {
-    gtk_box_pack_start (GTK_BOX (vbox), panel, FALSE, FALSE, 2);
-    gtk_box_pack_start (GTK_BOX (vbox), boxes, FALSE, FALSE, 2);
-    gtk_box_pack_start (GTK_BOX (vbox), boxes2, FALSE, FALSE, 2);
+    expander = gtk_expander_new ("playbin2 options");
+    pb2vbox = gtk_vbox_new (FALSE, 0);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), panel, FALSE, FALSE, 2);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes, FALSE, FALSE, 2);
+    gtk_box_pack_start (GTK_BOX (pb2vbox), boxes2, FALSE, FALSE, 2);
+    gtk_container_add (GTK_CONTAINER (expander), pb2vbox);
+    gtk_box_pack_start (GTK_BOX (vbox), expander, FALSE, FALSE, 2);
   }
   gtk_box_pack_start (GTK_BOX (vbox), hscale, FALSE, FALSE, 2);
   gtk_box_pack_start (GTK_BOX (vbox), statusbar, FALSE, FALSE, 2);
diff -Naur tests/old/examples/capsfilter/capsfilter1.c tests/old/examples/capsfilter/capsfilter1.c
--- tests/old/examples/capsfilter/capsfilter1.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/capsfilter/capsfilter1.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,87 @@
+#include <string.h>
+#include <gst/gst.h>
+
+/* This app uses a filter to connect colorspace and videosink
+ * so that only RGB data can pass the connection, colorspace will use
+ * a converter to convert the I420 data to RGB. Without a filter, this
+ * connection would use the I420 format (assuming Xv is enabled) */
+
+static void
+new_pad_func (GstElement * element, GstPad * newpad, gpointer data)
+{
+  GstElement *pipeline = (GstElement *) data;
+  GstElement *queue = gst_bin_get_by_name (GST_BIN (pipeline), "queue");
+
+  if (!strcmp (gst_pad_get_name (newpad), "video_00")) {
+    gst_element_set_state (pipeline, GST_STATE_PAUSED);
+    gst_pad_link (newpad, gst_element_get_pad (queue, "sink"));
+    gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  }
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  GstElement *pipeline;
+  GstElement *filesrc;
+  GstElement *demux;
+  GstElement *thread;
+  GstElement *queue;
+  GstElement *mpeg2dec;
+  GstElement *colorspace;
+  GstElement *videosink;
+  gboolean res;
+
+  gst_init (&argc, &argv);
+
+  if (argc < 2) {
+    g_print ("usage: %s <mpeg1 system stream>\n", argv[0]);
+    return (-1);
+  }
+
+  pipeline = gst_pipeline_new ("main_pipeline");
+  filesrc = gst_element_factory_make ("filesrc", "filesrc");
+  g_return_val_if_fail (filesrc, -1);
+  g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL);
+  demux = gst_element_factory_make ("mpegdemux", "demux");
+  g_return_val_if_fail (demux, -1);
+  g_signal_connect (G_OBJECT (demux), "new_pad", G_CALLBACK (new_pad_func),
+      pipeline);
+
+  thread = gst_thread_new ("thread");
+  queue = gst_element_factory_make ("queue", "queue");
+  mpeg2dec = gst_element_factory_make ("mpeg2dec", "mpeg2dec");
+  g_return_val_if_fail (mpeg2dec, -1);
+  colorspace = gst_element_factory_make ("ffmpegcolorspace", "colorspace");
+  g_return_val_if_fail (colorspace, -1);
+  videosink = gst_element_factory_make (DEFAULT_VIDEOSINK, "videosink");
+  g_return_val_if_fail (videosink, -1);
+
+  gst_bin_add (GST_BIN (pipeline), filesrc);
+  gst_bin_add (GST_BIN (pipeline), demux);
+
+  gst_bin_add (GST_BIN (thread), queue);
+  gst_bin_add (GST_BIN (thread), mpeg2dec);
+  gst_bin_add (GST_BIN (thread), colorspace);
+  gst_bin_add (GST_BIN (thread), videosink);
+  gst_bin_add (GST_BIN (pipeline), thread);
+
+  gst_element_link_pads (filesrc, "src", demux, "sink");
+  gst_element_link_pads (queue, "src", mpeg2dec, "sink");
+  gst_element_link_pads (mpeg2dec, "src", colorspace, "sink");
+  /* force RGB data passing between colorspace and videosink */
+  res = gst_element_link_pads_filtered (colorspace, "src", videosink, "sink",
+      gst_caps_new_simple ("video/x-raw-rgb", NULL));
+  if (!res) {
+    g_print ("could not connect colorspace and videosink\n");
+    return -1;
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  while (gst_bin_iterate (GST_BIN (pipeline)));
+
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 0;
+}
diff -Naur tests/old/examples/capsfilter/Makefile.am tests/old/examples/capsfilter/Makefile.am
--- tests/old/examples/capsfilter/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/capsfilter/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,6 @@
+noinst_PROGRAMS = capsfilter1
+
+LDADD = $(GST_LIBS)
+AM_CFLAGS = $(GST_CFLAGS)
+
+
diff -Naur tests/old/examples/gob/gst-identity2.gob tests/old/examples/gob/gst-identity2.gob
--- tests/old/examples/gob/gst-identity2.gob	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/gob/gst-identity2.gob	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,139 @@
+
+%header{
+#include <gst/gst.h>
+#include "gst-identity2.h"
+#include "gst-identity2-private.h"
+%}
+
+class Gst:Identity2 from Gst:Element {
+	
+  /* plugin init */
+  private gboolean
+  plugin_init (GModule *module, GstPlugin *plugin)
+  {
+    static GstElementDetails identity2_details =
+    GST_ELEMENT_DETAILS (
+      "GOB Identity",
+      "Filter/Effect",
+      "Does nothing",
+      "Wim Taymans <wim.taymans@chello.be>");
+    GstElementFactory *factory;
+
+    factory = gst_elementfactory_new ("identity2", TYPE_SELF,
+                                      &identity2_details);
+    g_return_val_if_fail (factory != NULL, FALSE);
+
+    gst_plugin_add_feature (plugin, &(factory->feature));
+
+    return TRUE;
+  }
+
+  /* pads FIXME gob oculd be improved here */
+  private GstPad *sinkpad = 
+  {
+    gst_pad_new ("sink", GST_PAD_SINK);
+    gst_element_add_pad (GST_ELEMENT (o), o->_priv->sinkpad);
+    gst_pad_set_chain_function (o->_priv->sinkpad, chain);
+    gst_pad_set_bufferpool_function (o->_priv->sinkpad, get_bufferpool);
+    //gst_pad_set_negotiate_function (o->_priv->sinkpad, negotiate_sink);
+  };
+  private GstPad *srcpad =
+  {
+    gst_pad_new ("src", GST_PAD_SRC);
+    gst_element_add_pad (GST_ELEMENT (o), o->_priv->srcpad);
+    //gst_pad_set_negotiate_function (o->_priv->srcpad, negotiate_src);
+  };
+
+  /* arguments */
+  /*
+  private gboolean loop_based = FALSE; argument BOOL loop_based 
+    get { 
+      ARG = self->_priv->loop_based; 
+    }
+    set { 
+      self->_priv->loop_based = ARG;
+      if (self->_priv->loop_based) {
+        gst_element_set_loop_function (GST_ELEMENT (self), loop);
+        gst_pad_set_chain_function (self->_priv->sinkpad, NULL);
+      }
+      else {
+        gst_pad_set_chain_function (self->_priv->sinkpad, chain);
+        gst_element_set_loop_function (GST_ELEMENT (self), NULL);
+      }
+    };*/
+  private guint sleep_time = 0; argument UINT sleep_time link;
+  private gboolean silent = FALSE; argument BOOL silent link;
+
+  /* signals */
+  private signal last NONE(NONE) void handoff(self);
+
+  /* core code here */
+  private GstBufferPool*
+  get_bufferpool (GstPad *pad (check null))
+  {
+    Self *self = SELF (gst_pad_get_parent (pad));
+    
+    return gst_pad_get_bufferpool (self->_priv->srcpad);
+  }
+
+  /* private GstPadNegotiateReturn
+  negotiate_src (GstPad *pad, GstCaps **caps, gpointer *data)
+  {
+    Self *self = SELF (gst_pad_get_parent (pad));
+
+    return gst_pad_negotiate_proxy (pad, self->_priv->sinkpad, caps);
+  }
+
+  private GstPadNegotiateReturn
+  negotiate_sink (GstPad *pad, GstCaps **caps, gpointer *data)
+  {
+    Self *self = SELF (gst_pad_get_parent (pad));
+
+    return gst_pad_negotiate_proxy (pad, self->_priv->srcpad, caps);
+  } */
+
+  private void
+  chain (GstPad *pad (check null), GstBuffer *buf (check null))
+  {
+    Self *self;
+
+    self = SELF (gst_pad_get_parent (pad));
+
+    if (!self->_priv->silent)
+      g_print("identity2: chain ******* (%s:%s)i \n",GST_DEBUG_PAD_NAME(pad));
+
+      handoff (self);
+      gst_pad_push (self->_priv->srcpad, buf);
+
+    if (self->_priv->sleep_time)
+      usleep (self->_priv->sleep_time);
+  }
+
+  /*private void
+  loop (GstElement *element (check null))
+  {
+    Self *self = SELF (element);
+    GstBuffer *buf;
+
+    do {
+      buf = gst_pad_pull (self->_priv->sinkpad);
+      g_print("identity2: loop ******* (%s:%s)i \n",GST_DEBUG_PAD_NAME(self->_priv->sinkpad));
+
+      handoff (self);
+      gst_pad_push (self->_priv->srcpad, buf);
+
+      if (self->_priv->sleep_time)
+        usleep (self->_priv->sleep_time);
+
+    } while (!GST_ELEMENT_IS_COTHREAD_STOPPING(element));
+  }*/
+}
+
+%{
+GstPluginDesc plugin_desc = {
+  GST_VERSION_MAJOR,
+  GST_VERSION_MINOR,
+  "identity2",
+  gst_identity2_plugin_init
+};
+%}
diff -Naur tests/old/examples/gob/Makefile.am tests/old/examples/gob/Makefile.am
--- tests/old/examples/gob/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/gob/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,19 @@
+
+plugin_LTLIBRARIES = libgstidentity2.la
+
+GOB_FILES_ID = gst-identity2.c gst-identity2.h gst-identity2-private.h
+
+BUILT_SOURCES =                                         \
+	$(GOB_FILES_ID)
+
+libgstidentity2_la_SOURCES = gst-identity2.gob $(GOB_FILES_ID)
+libgstidentity2_la_CFLAGS = $(GST_CFLAGS)
+libgstidentity2_la_LIBADD =
+
+%.c %.h %-private.h: %.gob
+	gob $<
+
+CLEANFILES = $(GOB_FILES_ID)
+
+dist-hook:
+	cd $(distdir); rm -f $(CLEANFILES)
diff -Naur tests/old/examples/indexing/indexmpeg.c tests/old/examples/indexing/indexmpeg.c
--- tests/old/examples/indexing/indexmpeg.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/indexing/indexmpeg.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,321 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <gst/gst.h>
+
+static gboolean verbose = FALSE;
+static gboolean quiet = FALSE;
+
+static void
+entry_added (GstIndex * index, GstIndexEntry * entry)
+{
+  switch (entry->type) {
+    case GST_INDEX_ENTRY_ID:
+      g_print ("id %d describes writer %s\n", entry->id,
+          GST_INDEX_ID_DESCRIPTION (entry));
+      break;
+    case GST_INDEX_ENTRY_FORMAT:
+      g_print ("%d: registered format %d for %s\n", entry->id,
+          GST_INDEX_FORMAT_FORMAT (entry), GST_INDEX_FORMAT_KEY (entry));
+      break;
+    case GST_INDEX_ENTRY_ASSOCIATION:
+    {
+      gint i;
+
+      g_print ("%p, %d: %08x ", entry, entry->id,
+          GST_INDEX_ASSOC_FLAGS (entry));
+      for (i = 0; i < GST_INDEX_NASSOCS (entry); i++) {
+        g_print ("%d %" G_GINT64_FORMAT " ", GST_INDEX_ASSOC_FORMAT (entry, i),
+            GST_INDEX_ASSOC_VALUE (entry, i));
+      }
+      g_print ("\n");
+      break;
+    }
+    default:
+      break;
+  }
+}
+
+typedef struct
+{
+  const gchar *padname;
+  GstPad *target;
+  GstElement *bin;
+  GstElement *pipeline;
+  GstIndex *index;
+}
+dyn_link;
+
+static void
+dynamic_link (GstPadTemplate * templ, GstPad * newpad, gpointer data)
+{
+  dyn_link *link = (dyn_link *) data;
+
+  if (!strcmp (gst_pad_get_name (newpad), link->padname)) {
+    gst_element_set_state (link->pipeline, GST_STATE_PAUSED);
+    gst_bin_add (GST_BIN (link->pipeline), link->bin);
+    gst_pad_link (newpad, link->target);
+    gst_element_set_index (link->bin, link->index);
+    gst_element_set_state (link->pipeline, GST_STATE_PLAYING);
+  }
+}
+
+static void
+setup_dynamic_linking (GstElement * pipeline,
+    GstElement * element,
+    const gchar * padname, GstPad * target, GstElement * bin, GstIndex * index)
+{
+  dyn_link *link;
+
+  link = g_new0 (dyn_link, 1);
+  link->padname = g_strdup (padname);
+  link->target = target;
+  link->bin = bin;
+  link->pipeline = pipeline;
+  link->index = index;
+
+  g_signal_connect (G_OBJECT (element), "new_pad", G_CALLBACK (dynamic_link),
+      link);
+}
+
+static GstElement *
+make_mpeg_systems_pipeline (const gchar * path, GstIndex * index)
+{
+  GstElement *pipeline;
+  GstElement *src, *demux;
+
+  pipeline = gst_pipeline_new ("pipeline");
+
+  src = gst_element_factory_make ("filesrc", "src");
+  g_object_set (G_OBJECT (src), "location", path, NULL);
+
+  demux = gst_element_factory_make ("mpegdemux", "demux");
+
+  gst_bin_add (GST_BIN (pipeline), src);
+  gst_bin_add (GST_BIN (pipeline), demux);
+
+  if (index) {
+    gst_element_set_index (pipeline, index);
+  }
+
+  gst_element_link_pads (src, "src", demux, "sink");
+
+  return pipeline;
+}
+
+static GstElement *
+make_mpeg_decoder_pipeline (const gchar * path, GstIndex * index)
+{
+  GstElement *pipeline;
+  GstElement *src, *demux;
+  GstElement *video_bin, *audio_bin;
+  GstElement *video_decoder, *audio_decoder;
+
+  pipeline = gst_pipeline_new ("pipeline");
+
+  src = gst_element_factory_make ("filesrc", "src");
+  g_object_set (G_OBJECT (src), "location", path, NULL);
+
+  demux = gst_element_factory_make ("mpegdemux", "demux");
+
+  gst_bin_add (GST_BIN (pipeline), src);
+  gst_bin_add (GST_BIN (pipeline), demux);
+
+  gst_element_link_pads (src, "src", demux, "sink");
+
+  video_bin = gst_bin_new ("video_bin");
+  video_decoder = gst_element_factory_make ("mpeg2dec", "video_decoder");
+
+  gst_bin_add (GST_BIN (video_bin), video_decoder);
+
+  setup_dynamic_linking (pipeline, demux, "video_00",
+      gst_element_get_pad (video_decoder, "sink"), video_bin, index);
+
+  audio_bin = gst_bin_new ("audio_bin");
+  audio_decoder = gst_element_factory_make ("mad", "audio_decoder");
+
+  setup_dynamic_linking (pipeline, demux, "audio_00",
+      gst_element_get_pad (audio_decoder, "sink"), audio_bin, index);
+
+  gst_bin_add (GST_BIN (audio_bin), audio_decoder);
+
+  if (index) {
+    gst_element_set_index (pipeline, index);
+  }
+
+  return pipeline;
+}
+
+static void
+print_progress (GstPad * pad)
+{
+  gint i = 0;
+  gchar status[53];
+  GstFormat format;
+  gboolean res;
+  gint64 value;
+  gint percent = 0;
+
+  status[0] = '|';
+
+  format = GST_FORMAT_PERCENT;
+  res = gst_pad_query (pad, GST_QUERY_POSITION, &format, &value);
+  if (res) {
+    percent = value / (2 * GST_FORMAT_PERCENT_SCALE);
+  }
+
+  for (i = 0; i < percent; i++) {
+    status[i + 1] = '=';
+  }
+  for (i = percent; i < 50; i++) {
+    status[i + 1] = ' ';
+  }
+  status[51] = '|';
+  status[52] = 0;
+
+  g_print ("%s\r", status);
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  GstElement *pipeline;
+  GstElement *src;
+  GstPad *pad;
+  GstIndex *index;
+  gint count = 0;
+  GstEvent *event;
+  gboolean res;
+  GstElement *sink;
+  struct poptOption options[] = {
+    {"verbose", 'v', POPT_ARG_NONE | POPT_ARGFLAG_STRIP, &verbose, 0,
+        "Print index entries", NULL},
+    {"quiet", 'q', POPT_ARG_NONE | POPT_ARGFLAG_STRIP, &quiet, 0,
+        "don't print progress bar", NULL},
+    POPT_TABLEEND
+  };
+
+  if (!gst_init_check_with_popt_table (&argc, &argv, options) || argc < 3) {
+    g_print ("usage: %s [-v] <type> <filename>  \n"
+        "  type can be: 0 mpeg_systems\n"
+        "               1 mpeg_decoder\n"
+        "  -v : report added index entries\n"
+        "  -q : don't print progress\n", argv[0]);
+    return -1;
+  }
+
+  /* create index that elements can fill */
+  index = gst_index_factory_make ("memindex");
+  if (index) {
+    if (verbose)
+      g_signal_connect (G_OBJECT (index), "entry_added",
+          G_CALLBACK (entry_added), NULL);
+
+    g_object_set (G_OBJECT (index), "resolver", 1, NULL);
+  }
+
+  /* construct pipeline */
+  switch (atoi (argv[1])) {
+    case 0:
+      pipeline = make_mpeg_systems_pipeline (argv[2], index);
+      break;
+    case 1:
+      pipeline = make_mpeg_decoder_pipeline (argv[2], index);
+      break;
+    default:
+      g_print ("unknown type %d\n", atoi (argv[1]));
+      return -1;
+  }
+
+  /* setup some default info/error handlers */
+  g_signal_connect (G_OBJECT (pipeline), "deep_notify",
+      G_CALLBACK (gst_element_default_deep_notify), NULL);
+  g_signal_connect (G_OBJECT (pipeline), "error",
+      G_CALLBACK (gst_element_default_error), NULL);
+
+  /* get a pad to perform progress reporting on */
+  src = gst_bin_get_by_name (GST_BIN (pipeline), "src");
+  pad = gst_element_get_pad (src, "src");
+
+  /* prepare for iteration */
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  g_print ("indexing %s...\n", argv[2]);
+  /* run through the complete stream to let it generate an index */
+  while (gst_bin_iterate (GST_BIN (pipeline))) {
+    if (!quiet && (count % 1000 == 0)) {
+      print_progress (pad);
+    }
+    count++;
+  }
+  g_print ("\n");
+
+  /* bring to ready to restart the pipeline */
+  gst_element_set_state (pipeline, GST_STATE_READY);
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+
+  if (index)
+    GST_OBJECT_FLAG_UNSET (index, GST_INDEX_WRITABLE);
+
+  src = gst_bin_get_by_name (GST_BIN (pipeline), "video_decoder");
+
+  {
+    gint id;
+    GstIndexEntry *entry;
+    gint64 result;
+    gint total_tm;
+
+    gst_index_get_writer_id (index, GST_OBJECT (src), &id);
+
+    entry = gst_index_get_assoc_entry (index, id, GST_INDEX_LOOKUP_BEFORE, 0,
+        GST_FORMAT_TIME, G_MAXINT64);
+    g_assert (entry);
+    gst_index_entry_assoc_map (entry, GST_FORMAT_TIME, &result);
+    total_tm = result * 60 / GST_SECOND;
+    g_print ("total time = %.2fs\n", total_tm / 60.0);
+  }
+
+  pad = gst_element_get_pad (src, "src");
+  sink = gst_element_factory_make ("fakesink", "sink");
+  gst_element_link_pads (src, "src", sink, "sink");
+  gst_bin_add (GST_BIN (pipeline), sink);
+
+  g_print ("seeking %s...\n", argv[2]);
+  event = gst_event_new_seek (GST_FORMAT_TIME |
+      GST_SEEK_METHOD_SET | GST_SEEK_FLAG_FLUSH, 5 * GST_SECOND);
+
+  res = gst_pad_send_event (pad, event);
+  if (!res) {
+    g_warning ("seek failed");
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  count = 0;
+  while (gst_bin_iterate (GST_BIN (pipeline))) {
+    if (!quiet && (count % 1000 == 0)) {
+      print_progress (pad);
+    }
+    count++;
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 1;
+}
diff -Naur tests/old/examples/indexing/Makefile.am tests/old/examples/indexing/Makefile.am
--- tests/old/examples/indexing/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/indexing/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,7 @@
+examples = indexmpeg
+
+noinst_PROGRAMS = $(examples)
+
+# we have nothing but apps here, we can do this safely
+LIBS = $(GST_LIBS) $(GTK_LIBS)
+AM_CFLAGS = $(GST_CFLAGS) $(GTK_CFLAGS)
diff -Naur tests/old/examples/Makefile.am tests/old/examples/Makefile.am
--- tests/old/examples/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,15 @@
+if HAVE_FT2
+FT2_SUBDIRS=seeking
+else
+FT2_SUBDIRS=
+endif
+
+# if HAVE_GTK
+# GTK_SUBDIRS=dynparams $(FT2_SUBDIRS)
+# else
+GTK_SUBDIRS=
+# endif
+
+SUBDIRS=$(GTK_SUBDIRS)
+#DIST_SUBDIRS=capsfilter seeking indexing switch
+DIST_SUBDIRS=seeking
diff -Naur tests/old/examples/seek/cdparanoia.c tests/old/examples/seek/cdparanoia.c
--- tests/old/examples/seek/cdparanoia.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/seek/cdparanoia.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,215 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdlib.h>
+#include <gst/gst.h>
+#include <string.h>
+
+static void
+get_position_info (GstElement * cdparanoia)
+{
+  GstFormat track_format;
+  const GstFormat *formats;
+  GstPad *pad;
+
+  track_format = gst_format_get_by_nick ("track");
+  g_assert (track_format != 0);
+
+  pad = gst_element_get_pad (cdparanoia, "src");
+  formats = gst_pad_get_formats (pad);
+
+  while (*formats) {
+    const GstFormatDefinition *definition;
+    GstFormat format;
+    gint64 position;
+    gboolean res;
+
+    definition = gst_format_get_details (*formats);
+
+    format = *formats;
+    res = gst_pad_query (pad, GST_QUERY_POSITION, &format, &position);
+
+    if (format == GST_FORMAT_TIME) {
+      position /= GST_SECOND;
+      g_print ("%s: %" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT,
+          definition->nick, position / 60, position % 60);
+    } else {
+      g_print ("%s: %" G_GINT64_FORMAT, definition->nick, position);
+    }
+
+    formats++;
+    if (*formats) {
+      g_print (", ");
+    }
+  }
+  g_print ("\r");
+}
+
+static void
+get_track_info (GstElement * cdparanoia)
+{
+  GstFormat track_format;
+  gint64 total_tracks = 0, total_time = 0;
+  GstPad *pad;
+  const GstFormat *formats;
+  gint i;
+  gint64 time_count = 0;
+
+  track_format = gst_format_get_by_nick ("track");
+  g_assert (track_format != 0);
+
+  pad = gst_element_get_pad (cdparanoia, "src");
+  formats = gst_pad_get_formats (pad);
+
+  /* we loop over all supported formats and report the total
+   * number of them */
+  while (*formats) {
+    const GstFormatDefinition *definition;
+    gint64 total;
+    GstFormat format;
+    gboolean res;
+
+    definition = gst_format_get_details (*formats);
+
+    format = *formats;
+    res = gst_pad_query (pad, GST_QUERY_TOTAL, &format, &total);
+    if (res) {
+      if (format == GST_FORMAT_TIME) {
+        total /= GST_SECOND;
+        g_print ("%s total: %" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT "\n",
+            definition->nick, total / 60, total % 60);
+      } else
+        g_print ("%s total: %" G_GINT64_FORMAT "\n", definition->nick, total);
+
+      if (format == track_format)
+        total_tracks = total;
+      else if (format == GST_FORMAT_TIME)
+        total_time = total;
+    } else
+      g_print ("failed to get %s total\n", definition->nick);
+
+    formats++;
+  }
+
+  /* then we loop over all the tracks to get more info.
+   * since pad_convert always works from 0, the time from track 1 needs
+   * to be substracted from track 2 */
+  for (i = 0; i <= total_tracks; i++) {
+    gint64 time;
+    gboolean res;
+
+    if (i < total_tracks) {
+      GstFormat format;
+
+      format = GST_FORMAT_TIME;
+      res = gst_pad_convert (pad, track_format, i, &format, &time);
+      time /= GST_SECOND;
+    } else {
+      time = total_time;
+      res = TRUE;
+    }
+
+    if (res) {
+      /* for the first track (i==0) we wait until we have the
+       * time of the next track */
+      if (i > 0) {
+        gint64 length = time - time_count;
+
+        g_print ("track %d: %" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT
+            " -> %" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT ", length: %"
+            G_GINT64_FORMAT ":%02" G_GINT64_FORMAT "\n",
+            i - 1,
+            time_count / 60, time_count % 60,
+            time / 60, time % 60, length / 60, length % 60);
+      }
+    } else {
+      g_print ("could not get time for track %d\n", i);
+    }
+
+    time_count = time;
+  }
+}
+
+int
+main (int argc, char **argv)
+{
+  GstElement *pipeline;
+  GstElement *cdparanoia;
+  GstElement *audiosink;
+  GstPad *pad;
+  GstFormat track_format;
+  GstEvent *event;
+  gint count;
+  gboolean res;
+
+  gst_init (&argc, &argv);
+
+  pipeline = gst_pipeline_new ("pipeline");
+
+  cdparanoia = gst_element_factory_make ("cdparanoia", "cdparanoia");
+  g_assert (cdparanoia);
+  g_object_set (G_OBJECT (cdparanoia), "paranoia_mode", 0, NULL);
+
+  audiosink = gst_element_factory_make (DEFAULT_AUDIOSINK, DEFAULT_AUDIOSINK);
+  g_assert (audiosink);
+
+  gst_bin_add (GST_BIN (pipeline), cdparanoia);
+  gst_bin_add (GST_BIN (pipeline), audiosink);
+
+  gst_element_link_pads (cdparanoia, "src", audiosink, "sink");
+
+  g_signal_connect (G_OBJECT (pipeline), "deep_notify",
+      G_CALLBACK (gst_object_default_deep_notify), NULL);
+
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+
+  /* now we go into probe mode */
+  get_track_info (cdparanoia);
+
+  track_format = gst_format_get_by_nick ("track");
+  g_assert (track_format != 0);
+
+  pad = gst_element_get_pad (cdparanoia, "src");
+  g_assert (pad);
+
+  g_print ("playing from track 3\n");
+  /* seek to track3 */
+  event = gst_event_new_seek (track_format |
+      GST_SEEK_METHOD_SET | GST_SEEK_FLAG_FLUSH, 3);
+
+  res = gst_pad_send_event (pad, event);
+  if (!res)
+    g_warning ("seek failed");
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  count = 0;
+  while (count++ < 500) {
+    get_position_info (cdparanoia);
+    g_usleep (G_USEC_PER_SEC / 2);
+  }
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+
+  g_print ("\nplaying from second 25 to second 29\n");
+  /* seek to some seconds */
+  event = gst_event_new_segment_seek (GST_FORMAT_TIME |
+      GST_SEEK_METHOD_SET |
+      GST_SEEK_FLAG_FLUSH, 25 * GST_SECOND, 29 * GST_SECOND);
+  res = gst_pad_send_event (pad, event);
+  if (!res)
+    g_warning ("seek failed");
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  count = 0;
+  while (count++ < 500) {
+    get_position_info (cdparanoia);
+    g_usleep (G_USEC_PER_SEC / 2);
+  }
+  g_print ("\n");
+
+  /* shutdown everything again */
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 0;
+}
diff -Naur tests/old/examples/seek/cdplayer.c tests/old/examples/seek/cdplayer.c
--- tests/old/examples/seek/cdplayer.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/seek/cdplayer.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,292 @@
+#include <stdlib.h>
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <gst/gst.h>
+#include <string.h>
+
+static GList *seekable_elements = NULL;
+
+static GstElement *pipeline;
+static GtkAdjustment *adjustment;
+static gboolean stats = FALSE;
+static guint64 duration;
+
+static guint update_id;
+
+#define UPDATE_INTERVAL 500
+
+static GstElement *
+make_cdaudio_pipeline (void)
+{
+  GstElement *cdaudio;
+
+  cdaudio = gst_element_factory_make ("cdaudio", "cdaudio");
+  g_assert (cdaudio != NULL);
+
+  seekable_elements = g_list_prepend (seekable_elements, cdaudio);
+
+  return cdaudio;
+}
+
+static gchar *
+format_value (GtkScale * scale, gdouble value)
+{
+  gint64 real;
+  gint64 seconds;
+  gint64 subseconds;
+
+  real = value * duration / 100;
+  seconds = (gint64) real / GST_SECOND;
+  subseconds = (gint64) real / (GST_SECOND / 100);
+
+  return g_strdup_printf ("%02" G_GINT64_FORMAT ":%02" G_GINT64_FORMAT ":%02"
+      G_GINT64_FORMAT, seconds / 60, seconds % 60, subseconds % 100);
+}
+
+typedef struct
+{
+  const gchar *name;
+  const GstFormat format;
+}
+seek_format;
+
+static seek_format seek_formats[] = {
+  {"tim", GST_FORMAT_TIME},
+  {"byt", GST_FORMAT_BYTES},
+  {"buf", GST_FORMAT_BUFFERS},
+  {"def", GST_FORMAT_DEFAULT},
+  {NULL, 0},
+};
+
+
+G_GNUC_UNUSED static void
+query_durations ()
+{
+  GList *walk = seekable_elements;
+
+  while (walk) {
+    GstElement *element = GST_ELEMENT (walk->data);
+    gint i = 0;
+
+    g_print ("durations %8.8s: ", GST_ELEMENT_NAME (element));
+    while (seek_formats[i].name) {
+      gboolean res;
+      gint64 value;
+      GstFormat format;
+
+      format = seek_formats[i].format;
+      res = gst_element_query (element, GST_QUERY_TOTAL, &format, &value);
+      if (res) {
+        g_print ("%s %13" G_GINT64_FORMAT " | ", seek_formats[i].name, value);
+      } else {
+        g_print ("%s %13.13s | ", seek_formats[i].name, "*NA*");
+      }
+      i++;
+    }
+    g_print (" %s\n", GST_ELEMENT_NAME (element));
+    walk = g_list_next (walk);
+  }
+}
+
+G_GNUC_UNUSED static void
+query_positions ()
+{
+  GList *walk = seekable_elements;
+
+  while (walk) {
+    GstElement *element = GST_ELEMENT (walk->data);
+    gint i = 0;
+
+    g_print ("positions %8.8s: ", GST_ELEMENT_NAME (element));
+    while (seek_formats[i].name) {
+      gboolean res;
+      gint64 value;
+      GstFormat format;
+
+      format = seek_formats[i].format;
+      res = gst_element_query (element, GST_QUERY_POSITION, &format, &value);
+      if (res) {
+        g_print ("%s %13" G_GINT64_FORMAT " | ", seek_formats[i].name, value);
+      } else {
+        g_print ("%s %13.13s | ", seek_formats[i].name, "*NA*");
+      }
+      i++;
+    }
+    g_print (" %s\n", GST_ELEMENT_NAME (element));
+    walk = g_list_next (walk);
+  }
+}
+
+static gboolean
+update_scale (gpointer data)
+{
+  GstClock *clock;
+  guint64 position = 0;
+  GstFormat format = GST_FORMAT_TIME;
+
+  duration = 0;
+  clock = gst_pipeline_get_clock (GST_PIPELINE (pipeline));
+
+  if (seekable_elements) {
+    GstElement *element = GST_ELEMENT (seekable_elements->data);
+
+    gst_element_query (element, GST_QUERY_TOTAL, &format, &duration);
+    gst_element_query (element, GST_QUERY_POSITION, &format, &position);
+  }
+
+  if (stats) {
+    if (clock)
+      g_print ("clock:                  %13" G_GUINT64_FORMAT "  (%s)\n",
+          position, gst_object_get_name (GST_OBJECT (clock)));
+    query_durations ();
+    query_positions ();
+  }
+  if (duration > 0) {
+    gtk_adjustment_set_value (adjustment, position * 100.0 / duration);
+  }
+
+  return TRUE;
+}
+
+static gboolean
+start_seek (GtkWidget * widget, GdkEventButton * event, gpointer user_data)
+{
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+  gtk_timeout_remove (update_id);
+
+  return FALSE;
+}
+
+static gboolean
+stop_seek (GtkWidget * widget, GdkEventButton * event, gpointer user_data)
+{
+  gint64 real = gtk_range_get_value (GTK_RANGE (widget)) * duration / 100;
+  gboolean res;
+  GstEvent *s_event;
+  GList *walk = seekable_elements;
+
+  while (walk) {
+    GstElement *seekable = GST_ELEMENT (walk->data);
+
+    g_print ("seek to %" G_GINT64_FORMAT " on element %s\n", real,
+        GST_ELEMENT_NAME (seekable));
+    s_event =
+        gst_event_new_seek (GST_FORMAT_TIME | GST_SEEK_METHOD_SET |
+        GST_SEEK_FLAG_FLUSH, real);
+
+    res = gst_element_send_event (seekable, s_event);
+
+    walk = g_list_next (walk);
+  }
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  update_id =
+      gtk_timeout_add (UPDATE_INTERVAL, (GtkFunction) update_scale, pipeline);
+
+  return FALSE;
+}
+
+static void
+play_cb (GtkButton * button, gpointer data)
+{
+  GstState state;
+
+  gst_element_get_state (pipeline, &state, NULL, GST_CLOCK_TIME_NONE);
+  if (state != GST_STATE_PLAYING) {
+    gst_element_set_state (pipeline, GST_STATE_PLAYING);
+    update_id =
+        gtk_timeout_add (UPDATE_INTERVAL, (GtkFunction) update_scale, pipeline);
+  }
+}
+
+static void
+pause_cb (GtkButton * button, gpointer data)
+{
+  GstState state;
+
+  gst_element_get_state (pipeline, &state, NULL, GST_CLOCK_TIME_NONE);
+  if (state != GST_STATE_PAUSED) {
+    gst_element_set_state (pipeline, GST_STATE_PAUSED);
+    gtk_timeout_remove (update_id);
+  }
+}
+
+static void
+stop_cb (GtkButton * button, gpointer data)
+{
+  GstState state;
+
+  gst_element_get_state (pipeline, &state, NULL, GST_CLOCK_TIME_NONE);
+  if (state != GST_STATE_READY) {
+    gst_element_set_state (pipeline, GST_STATE_READY);
+    gtk_timeout_remove (update_id);
+  }
+}
+
+int
+main (int argc, char **argv)
+{
+  GtkWidget *window, *hbox, *vbox,
+      *play_button, *pause_button, *stop_button, *hscale;
+  struct poptOption options[] = {
+    {"stats", 's', POPT_ARG_NONE | POPT_ARGFLAG_STRIP, &stats, 0,
+        "Show element stats", NULL},
+    POPT_TABLEEND
+  };
+
+  gst_init_with_popt_table (&argc, &argv, options);
+  gtk_init (&argc, &argv);
+
+  pipeline = make_cdaudio_pipeline ();
+
+  g_signal_connect (pipeline, "deep_notify",
+      G_CALLBACK (gst_object_default_deep_notify), NULL);
+
+  /* initialize gui elements ... */
+  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  hbox = gtk_hbox_new (FALSE, 0);
+  vbox = gtk_vbox_new (FALSE, 0);
+  play_button = gtk_button_new_with_label ("play");
+  pause_button = gtk_button_new_with_label ("pause");
+  stop_button = gtk_button_new_with_label ("stop");
+
+  adjustment =
+      GTK_ADJUSTMENT (gtk_adjustment_new (0.0, 0.00, 100.0, 0.1, 1.0, 1.0));
+  hscale = gtk_hscale_new (adjustment);
+  gtk_scale_set_digits (GTK_SCALE (hscale), 2);
+  gtk_range_set_update_policy (GTK_RANGE (hscale), GTK_UPDATE_CONTINUOUS);
+
+  gtk_signal_connect (GTK_OBJECT (hscale),
+      "button_press_event", G_CALLBACK (start_seek), pipeline);
+  gtk_signal_connect (GTK_OBJECT (hscale),
+      "button_release_event", G_CALLBACK (stop_seek), pipeline);
+  gtk_signal_connect (GTK_OBJECT (hscale),
+      "format_value", G_CALLBACK (format_value), pipeline);
+
+  /* do the packing stuff ... */
+  gtk_window_set_default_size (GTK_WINDOW (window), 96, 96);
+  gtk_container_add (GTK_CONTAINER (window), vbox);
+  gtk_container_add (GTK_CONTAINER (vbox), hbox);
+  gtk_box_pack_start (GTK_BOX (hbox), play_button, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (hbox), pause_button, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (hbox), stop_button, FALSE, FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), hscale, TRUE, TRUE, 2);
+
+  /* connect things ... */
+  g_signal_connect (G_OBJECT (play_button), "clicked", G_CALLBACK (play_cb),
+      pipeline);
+  g_signal_connect (G_OBJECT (pause_button), "clicked", G_CALLBACK (pause_cb),
+      pipeline);
+  g_signal_connect (G_OBJECT (stop_button), "clicked", G_CALLBACK (stop_cb),
+      pipeline);
+  g_signal_connect (G_OBJECT (window), "delete_event", gtk_main_quit, NULL);
+
+  /* show the gui. */
+  gtk_widget_show_all (window);
+
+  gtk_main ();
+
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 0;
+}
diff -Naur tests/old/examples/seek/chained.c tests/old/examples/seek/chained.c
--- tests/old/examples/seek/chained.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/seek/chained.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,107 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <stdlib.h>
+#include <gst/gst.h>
+#include <string.h>
+
+static GstElement *bin;
+
+static void
+unlinked (GstPad * pad, GstPad * peerpad, GstElement * pipeline)
+{
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+  gst_bin_remove (GST_BIN (pipeline), bin);
+  gst_element_set_state (bin, GST_STATE_READY);
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+}
+
+static void
+new_pad (GstElement * elem, GstPad * newpad, GstElement * pipeline)
+{
+  GstScheduler *sched;
+  GstClock *clock;
+
+  g_print ("new pad %s\n", gst_pad_get_name (newpad));
+
+  gst_element_set_state (pipeline, GST_STATE_PAUSED);
+  gst_bin_add (GST_BIN (pipeline), bin);
+
+  sched = gst_element_get_scheduler (GST_ELEMENT (pipeline));
+  clock = gst_scheduler_get_clock (sched);
+  gst_scheduler_set_clock (sched, clock);
+
+  gst_pad_link (newpad, gst_element_get_pad (bin, "sink"));
+
+  g_signal_connect (G_OBJECT (newpad), "unlinked", G_CALLBACK (unlinked),
+      pipeline);
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+}
+
+int
+main (int argc, char **argv)
+{
+  GstElement *pipeline;
+  GstElement *filesrc;
+  GstElement *oggdemux;
+  GstElement *vorbisdec;
+  GstElement *audioconvert;
+  GstElement *audiosink;
+
+  gst_init (&argc, &argv);
+
+  if (argc < 2) {
+    g_print ("usage: %s <oggfile>\n", argv[0]);
+    return (-1);
+  }
+
+  pipeline = gst_pipeline_new ("pipeline");
+
+  filesrc = gst_element_factory_make ("filesrc", "filesrc");
+  g_assert (filesrc);
+  g_object_set (G_OBJECT (filesrc), "location", argv[1], NULL);
+
+  oggdemux = gst_element_factory_make ("oggdemux", "oggdemux");
+  g_assert (oggdemux);
+
+  gst_bin_add (GST_BIN (pipeline), filesrc);
+  gst_bin_add (GST_BIN (pipeline), oggdemux);
+
+  gst_element_link_pads (filesrc, "src", oggdemux, "sink");
+
+  g_signal_connect (G_OBJECT (oggdemux), "new_pad", G_CALLBACK (new_pad),
+      pipeline);
+
+  bin = gst_bin_new ("bin");
+  vorbisdec = gst_element_factory_make ("vorbisdec", "vorbisdec");
+  g_assert (vorbisdec);
+  audioconvert = gst_element_factory_make ("audioconvert", "audioconvert");
+  g_assert (audioconvert);
+  audiosink = gst_element_factory_make (DEFAULT_AUDIOSINK, DEFAULT_AUDIOSINK);
+  g_assert (audiosink);
+  gst_bin_add (GST_BIN (bin), vorbisdec);
+  gst_bin_add (GST_BIN (bin), audioconvert);
+  gst_bin_add (GST_BIN (bin), audiosink);
+
+  gst_element_link_pads (vorbisdec, "src", audioconvert, "sink");
+  gst_element_link_pads (audioconvert, "src", audiosink, "sink");
+
+  gst_element_add_ghost_pad (bin, gst_element_get_pad (vorbisdec, "sink"),
+      "sink");
+
+  g_object_ref (G_OBJECT (bin));
+
+  g_signal_connect (pipeline, "deep_notify",
+      G_CALLBACK (gst_element_default_deep_notify), NULL);
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  while (gst_bin_iterate (GST_BIN (pipeline)))
+    /* nop */ ;
+
+  /* stop probe */
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  return 0;
+}
diff -Naur tests/old/examples/seek/Makefile.am tests/old/examples/seek/Makefile.am
--- tests/old/examples/seek/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/seek/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,7 @@
+examples = seek scrubby #cdplayer cdparanoia 
+
+noinst_PROGRAMS = $(examples)
+
+# we have nothing but apps here, we can do this safely
+LIBS = $(GST_LIBS) $(GTK_LIBS)
+AM_CFLAGS = $(GST_CFLAGS) $(GTK_CFLAGS)
diff -Naur tests/old/examples/stats/Makefile.am tests/old/examples/stats/Makefile.am
--- tests/old/examples/stats/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/stats/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,6 @@
+noinst_PROGRAMS = mp2ogg
+
+LDADD = $(GST_LIBS)
+AM_CFLAGS = $(GST_CFLAGS)
+
+
diff -Naur tests/old/examples/stats/mp2ogg.c tests/old/examples/stats/mp2ogg.c
--- tests/old/examples/stats/mp2ogg.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/stats/mp2ogg.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,102 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/gst.h>
+
+/* This example app demonstartes the use of pad query and convert to
+ * get useful statistics about a plugin. In this case we monitor the
+ * compression status of mpeg audio to ogg vorbis transcoding.
+ */
+
+gint
+main (gint argc, gchar * argv[])
+{
+  GstElement *pipeline;
+  GError *error = NULL;
+  gchar *description;
+  GstElement *encoder, *decoder;
+  GstPad *dec_sink, *enc_src;
+
+  gst_init (&argc, &argv);
+
+  if (argc < 3) {
+    g_print ("usage: %s <inputfile> <outputfile>\n", argv[0]);
+    return -1;
+  }
+
+  description = g_strdup_printf ("filesrc location=\"%s\" ! mad name=decoder ! "
+      "vorbisenc name=encoder ! filesink location=\"%s\"", argv[1], argv[2]);
+
+  pipeline = GST_ELEMENT (gst_parse_launch (description, &error));
+  if (!pipeline) {
+    if (error)
+      g_print ("ERROR: pipeline could not be constructed: %s\n",
+          error->message);
+    else
+      g_print ("ERROR: pipeline could not be constructed\n");
+    return -1;
+  }
+
+  decoder = gst_bin_get_by_name (GST_BIN (pipeline), "decoder");
+  encoder = gst_bin_get_by_name (GST_BIN (pipeline), "encoder");
+
+  dec_sink = gst_element_get_pad (decoder, "sink");
+  enc_src = gst_element_get_pad (encoder, "src");
+
+  if (gst_element_set_state (pipeline,
+          GST_STATE_PLAYING) != GST_STATE_CHANGE_SUCCESS) {
+    g_print ("pipeline doesn't want to play\n");
+    return -1;
+  }
+
+  while (gst_bin_iterate (GST_BIN (pipeline))) {
+    gint64 position;
+    gint64 duration;
+    gint64 bitrate_enc, bitrate_dec;
+    GstFormat format;
+
+    format = GST_FORMAT_TIME;
+    /* get the position */
+    gst_pad_query (enc_src, GST_QUERY_POSITION, &format, &position);
+
+    /* get the total duration */
+    gst_pad_query (enc_src, GST_QUERY_TOTAL, &format, &duration);
+
+    format = GST_FORMAT_BYTES;
+    /* see how many bytes are genereated per 8 seconds (== bitrate) */
+    gst_pad_convert (enc_src, GST_FORMAT_TIME, 8 * GST_SECOND,
+        &format, &bitrate_enc);
+
+    gst_pad_convert (dec_sink, GST_FORMAT_TIME, 8 * GST_SECOND,
+        &format, &bitrate_dec);
+
+    g_print ("[%2dm %.2ds] of [%2dm %.2ds], "
+        "src avg bitrate: %" G_GINT64_FORMAT ", dest avg birate: %"
+        G_GINT64_FORMAT ", ratio [%02.2f]    \r",
+        (gint) (position / (GST_SECOND * 60)),
+        (gint) (position / (GST_SECOND)) % 60,
+        (gint) (duration / (GST_SECOND * 60)),
+        (gint) (duration / (GST_SECOND)) % 60, bitrate_dec, bitrate_enc,
+        (gfloat) bitrate_dec / bitrate_enc);
+  }
+
+  g_print ("\n");
+
+  return 0;
+}
diff -Naur tests/old/examples/switch/Makefile.am tests/old/examples/switch/Makefile.am
--- tests/old/examples/switch/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/switch/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,7 @@
+
+noinst_PROGRAMS = switcher
+
+switcher_SOURCES = switcher.c
+switcher_CFLAGS = $(GST_CFLAGS)
+switcher_LDFLAGS = $(GST_LIBS)
+
diff -Naur tests/old/examples/switch/switcher.c tests/old/examples/switch/switcher.c
--- tests/old/examples/switch/switcher.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/examples/switch/switcher.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,104 @@
+/* GStreamer
+ * Copyright (C) 2003 Julien Moutte <julien@moutte.net>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+
+static GMainLoop *loop = NULL;
+
+
+
+static void
+got_eos (GstElement * pipeline)
+{
+  g_main_loop_quit (loop);
+}
+
+static gboolean
+idle_iterate (GstElement * pipeline)
+{
+  gst_bin_iterate (GST_BIN (pipeline));
+  return (GST_STATE (GST_ELEMENT (pipeline)) == GST_STATE_PLAYING);
+}
+
+static gboolean
+switch_timer (GstElement * video_switch)
+{
+  gint nb_sources, active_source;
+
+  g_object_get (G_OBJECT (video_switch), "nb_sources", &nb_sources, NULL);
+  g_object_get (G_OBJECT (video_switch), "active_source", &active_source, NULL);
+
+  active_source++;
+
+  if (active_source > nb_sources - 1)
+    active_source = 0;
+
+  g_object_set (G_OBJECT (video_switch), "active_source", active_source, NULL);
+
+  g_message ("current number of sources : %d, active source %d",
+      nb_sources, active_source);
+
+  return (GST_STATE (GST_ELEMENT (video_switch)) == GST_STATE_PLAYING);
+}
+
+int
+main (int argc, char *argv[])
+{
+  GstElement *pipeline, *src1, *src2, *video_switch, *video_sink;
+
+  /* Initing GStreamer library */
+  gst_init (&argc, &argv);
+
+  loop = g_main_loop_new (NULL, FALSE);
+
+  pipeline = gst_pipeline_new ("pipeline");
+  src1 = gst_element_factory_make ("videotestsrc", "src1");
+  g_object_set (G_OBJECT (src1), "pattern", 0, NULL);
+  src2 = gst_element_factory_make ("videotestsrc", "src2");
+  g_object_set (G_OBJECT (src2), "pattern", 1, NULL);
+  video_switch = gst_element_factory_make ("switch", "video_switch");
+  video_sink = gst_element_factory_make (DEFAULT_VIDEOSINK, "video_sink");
+
+  gst_bin_add_many (GST_BIN (pipeline), src1, src2, video_switch,
+      video_sink, NULL);
+
+  gst_element_link (src1, video_switch);
+  gst_element_link (src2, video_switch);
+  gst_element_link (video_switch, video_sink);
+
+  g_signal_connect (G_OBJECT (pipeline), "eos", G_CALLBACK (got_eos), NULL);
+
+  gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_PLAYING);
+
+  g_idle_add ((GSourceFunc) idle_iterate, pipeline);
+  g_timeout_add (2000, (GSourceFunc) switch_timer, video_switch);
+
+  g_main_loop_run (loop);
+
+  gst_element_set_state (GST_ELEMENT (pipeline), GST_STATE_READY);
+
+  /* unref */
+  gst_object_unref (pipeline);
+
+  exit (0);
+}
diff -Naur tests/old/Makefile.am tests/old/Makefile.am
--- tests/old/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,26 @@
+if USE_ALSA
+ALSA_DIR=alsa
+else
+ALSA_DIR=
+endif
+
+# if HAVE_GTK
+# EMBED_DIR=embed
+# else
+# EMBED_DIR=
+# endif
+
+SUBDIRS = \
+	$(ALSA_DIR) #seeking
+DIST_SUBDIRS = \
+	alsa
+
+GST_PLUGIN_PATH=$(shell cd $(top_builddir) && pwd)
+
+#$(TESTS):
+#	@echo -e '\nrunning gst-register...\n'
+#	$(GST_TOOLS_DIR)/gst-register --gst-plugin-path=$(GST_PLUGIN_PATH)
+
+#TESTS=$(GST_TOOLS_DIR)/gst-compprep
+
+.PHONY: $(TESTS)
diff -Naur tests/old/testsuite/alsa/formats.c tests/old/testsuite/alsa/formats.c
--- tests/old/testsuite/alsa/formats.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/alsa/formats.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2003 Benjamin Otte <in7y118@public.uni-hamburg.de>
+ *
+ * formats.c: Tests the different formats on alsasink
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "sinesrc.h"
+
+GstElement *pipeline;
+gint channels = 1;
+gboolean sign = FALSE;
+gint endianness = G_LITTLE_ENDIAN;
+gint depth = 8;
+gint width = 8;
+
+#define NUMBER_OF_INT_TESTS 28
+#define NUMBER_OF_FLOAT_TESTS 2
+#define NUMBER_OF_LAW_TESTS 2
+
+gint last = 0;
+gint counter = 0;
+
+static void create_pipeline (void);
+
+
+static void
+pre_get_func (SineSrc * src)
+{
+  counter++;
+};
+static void
+create_pipeline (void)
+{
+  GstElement *src;
+  SineSrc *sinesrc;
+  GstElement *alsasink;
+
+  pipeline = gst_pipeline_new ("pipeline");
+  src = sinesrc_new ();
+  alsasink = gst_element_factory_make ("alsasink", "alsasink");
+
+  gst_bin_add_many (GST_BIN (pipeline), src, alsasink, NULL);
+  gst_element_link (src, alsasink);
+
+  /* prepare our sinesrc */
+  sinesrc = (SineSrc *) src;
+  sinesrc->pre_get_func = pre_get_func;
+  sinesrc->newcaps = TRUE;
+  /* int tests */
+  if (last < NUMBER_OF_INT_TESTS) {
+    sinesrc->type = SINE_SRC_INT;
+    sinesrc->sign = ((last % 2) == 0) ? TRUE : FALSE;
+    sinesrc->endianness =
+        ((last / 2) % 2 == 0) ? G_LITTLE_ENDIAN : G_BIG_ENDIAN;
+    switch ((last / 4) % 8) {
+      case 0:
+        sinesrc->depth = 8;
+        sinesrc->width = 8;
+        break;
+      case 1:
+        sinesrc->depth = 16;
+        sinesrc->width = 16;
+        break;
+      case 2:
+        sinesrc->depth = 24;
+        sinesrc->width = 32;
+        break;
+      case 3:
+        sinesrc->depth = 32;
+        sinesrc->width = 32;
+        break;
+        /* nomore tests below until i know what 24bit width means to alsa wrt endianness */
+      case 4:
+        sinesrc->depth = 24;
+        sinesrc->width = 24;
+        break;
+      case 5:
+        sinesrc->depth = 20;
+        sinesrc->width = 24;
+        break;
+      case 6:
+        sinesrc->depth = 18;
+        sinesrc->width = 24;
+        break;
+      case 7:
+        /* not used yet */
+        sinesrc->depth = 8;
+        sinesrc->width = 8;
+        break;
+      default:
+        g_assert_not_reached ();
+    }
+
+    g_print ("Setting format to: format:     \"int\"\n"
+        "                   sign:       %s\n"
+        "                   endianness: %d\n"
+        "                   width:      %d\n"
+        "                   depth:      %d\n",
+        sinesrc->sign ? "TRUE" : "FALSE", sinesrc->endianness,
+        sinesrc->width, sinesrc->depth);
+  } else if (last < NUMBER_OF_INT_TESTS + NUMBER_OF_FLOAT_TESTS) {
+    gint temp = last - NUMBER_OF_INT_TESTS;
+
+    sinesrc->type = SINE_SRC_FLOAT;
+    switch (temp) {
+      case 0:
+        sinesrc->width = 32;
+        break;
+      case 1:
+        sinesrc->width = 64;
+        break;
+      default:
+        g_assert_not_reached ();
+    }
+    g_print ("Setting format to float width %d\n", sinesrc->width);
+  } else if (last <
+      NUMBER_OF_INT_TESTS + NUMBER_OF_FLOAT_TESTS + NUMBER_OF_LAW_TESTS) {
+    gint temp = last - NUMBER_OF_INT_TESTS - NUMBER_OF_FLOAT_TESTS;
+    GstElement *law;
+
+    sinesrc->type = SINE_SRC_INT;
+    sinesrc->sign = TRUE;
+    sinesrc->endianness = G_BYTE_ORDER;
+    sinesrc->depth = 16;
+    sinesrc->width = 16;
+
+    if (temp == 0) {
+      law = gst_element_factory_make ("mulawenc", "mulaw");
+    } else {
+      law = gst_element_factory_make ("alawenc", "alaw");
+    }
+    g_assert (law);
+    gst_element_unlink (src, alsasink);
+    gst_bin_add (GST_BIN (pipeline), law);
+    gst_element_link_many (src, law, alsasink, NULL);
+    if (temp == 0) {
+      g_print ("Setting format to: format:     \"MU law\"\n");
+    } else {
+      g_print ("Setting format to: format:     \"A law\"\n");
+    }
+  } else {
+    g_print ("All formats work like a charm.\n");
+    exit (0);
+  }
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  gst_init (&argc, &argv);
+
+  g_print ("\n"
+      "This test will test the various formats ALSA and GStreamer support.\n"
+      "You will hear a short sine tone on your default ALSA soundcard for every\n"
+      "format tested. They should all sound the same (incl. volume).\n" "\n");
+  create_pipeline ();
+
+  while (pipeline) {
+    gst_bin_iterate (GST_BIN (pipeline));
+    if ((counter / 200) > last) {
+      last = counter / 200;
+      gst_object_unref (pipeline);
+      create_pipeline ();
+    }
+  }
+
+  return 0;
+}
diff -Naur tests/old/testsuite/alsa/Makefile.am tests/old/testsuite/alsa/Makefile.am
--- tests/old/testsuite/alsa/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/alsa/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,13 @@
+testprogs = formats state srcstate
+
+noinst_PROGRAMS = $(testprogs)
+
+formats_SOURCES = formats.c sinesrc.c sinesrc.h
+state_SOURCES = state.c sinesrc.c sinesrc.h
+srcstate_SOURCES =srcstate.c
+
+# we have nothing but apps here, we can do this safely
+LIBS = $(GST_LIBS)
+AM_CFLAGS = $(GST_CFLAGS)
+
+noinst_HEADERS = sinesrc.h
diff -Naur tests/old/testsuite/alsa/sinesrc.c tests/old/testsuite/alsa/sinesrc.c
--- tests/old/testsuite/alsa/sinesrc.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/alsa/sinesrc.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2003 Benjamin Otte <in7y118@public.uni-hamburg.de>
+ *
+ * sinesrc.c: An elemnt emitting a sine src in lots of different formats
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "sinesrc.h"
+#include <math.h>
+#include <string.h>             /* memcpy */
+
+#define SAMPLES_PER_WAVE 200
+
+static GstStaticPadTemplate sinesrc_src_factory =
+    GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-raw-int, "
+        "endianness = (int) { LITTLE_ENDIAN, BIG_ENDIAN }, "
+        "signed = (boolean) { FALSE, TRUE }, "
+        "width = (int) [8, 32], "
+        "depth = (int) [8, 32], "
+        "rate = (int) [8000, 192000], "
+        "channels = (int) [1, 16];"
+        "audio/x-raw-float, "
+        "endianness = (int) BYTE_ORDER, "
+        "width = (int) {32, 64}, "
+        "rate = (int) [8000, 192000], " "channels = (int) [1, 16]")
+    );
+
+static GstElementClass *parent_class = NULL;
+
+static void sinesrc_init (SineSrc * src);
+static void sinesrc_class_init (SineSrcClass * klass);
+
+static GstData *sinesrc_get (GstPad * pad);
+static GstStateChangeReturn sinesrc_change_state (GstElement * element,
+    GstStateChange transition);
+
+
+GType
+sinesrc_get_type (void)
+{
+  static GType sinesrc_type = 0;
+
+  if (!sinesrc_type) {
+    static const GTypeInfo sinesrc_info = {
+      sizeof (SineSrcClass), NULL, NULL,
+      (GClassInitFunc) sinesrc_class_init, NULL, NULL,
+      sizeof (SineSrc), 0,
+      (GInstanceInitFunc) sinesrc_init,
+    };
+
+    sinesrc_type = g_type_register_static (GST_TYPE_ELEMENT, "SineSrc",
+        &sinesrc_info, 0);
+  }
+  return sinesrc_type;
+}
+static void
+sinesrc_class_init (SineSrcClass * klass)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+
+  element_class->change_state = sinesrc_change_state;
+
+  parent_class = g_type_class_peek_parent (klass);
+}
+
+static void
+sinesrc_init (SineSrc * src)
+{
+  src->src =
+      gst_pad_new_from_template (gst_static_pad_template_get
+      (&sinesrc_src_factory), "src");
+  gst_element_add_pad (GST_ELEMENT (src), src->src);
+  gst_pad_set_get_function (src->src, sinesrc_get);
+
+  src->width = 16;
+  src->depth = 16;
+  src->sign = TRUE;
+  src->endianness = G_BYTE_ORDER;
+  src->rate = 44100;
+  src->channels = 1;
+  src->type = SINE_SRC_INT;
+  src->newcaps = TRUE;
+
+  src->pre_get_func = NULL;
+
+  GST_OBJECT (src)->name = "sinesrc";
+}
+
+static void
+sinesrc_force_caps (SineSrc * src)
+{
+  GstCaps *caps;
+
+  if (!src->newcaps)
+    return;
+
+  src->newcaps = FALSE;
+
+  switch (src->type) {
+    case SINE_SRC_INT:
+      caps = gst_caps_new_simple ("audio/x-raw-int",
+          "signed", G_TYPE_BOOLEAN, src->sign,
+          "depth", G_TYPE_INT, src->depth, NULL);
+      if (src->width > 8)
+        gst_caps_set_simple (caps,
+            "endianness", G_TYPE_INT, src->endianness, NULL);
+      break;
+    case SINE_SRC_FLOAT:
+      g_assert (src->width == 32 || src->width == 64);
+      caps = gst_caps_new_simple ("audio/x-raw-float",
+          "endianness", G_TYPE_INT, src->endianness, NULL);
+      break;
+    default:
+      caps = NULL;
+      g_assert_not_reached ();
+  }
+  gst_caps_set_simple (caps,
+      "width", G_TYPE_INT, src->width,
+      "rate", G_TYPE_INT, src->rate,
+      "channels", G_TYPE_INT, src->channels, NULL);
+
+  if (gst_pad_try_set_caps (src->src, caps) != GST_PAD_LINK_OK)
+    g_assert_not_reached ();
+}
+
+/* always return 1 wave 
+ * there are 200 waves in 1 second, so the frequency is samplerate/200
+ */
+static guint8
+UIDENTITY (guint8 x)
+{
+  return x;
+};
+static gint8
+IDENTITY (gint8 x)
+{
+  return x;
+};
+
+#define POPULATE(format, be_func, le_func) G_STMT_START {\
+  format val = (format) int_value;\
+  format *p = data;\
+  switch (src->endianness) {\
+    case G_LITTLE_ENDIAN:\
+      val = le_func (val);\
+      break;\
+    case G_BIG_ENDIAN:\
+      val = be_func (val);\
+      break;\
+    default: \
+      g_assert_not_reached ();\
+  };\
+  for (j = 0; j < src->channels; j++) {\
+    *p = val;\
+    p ++;\
+  }\
+  data = p;\
+} G_STMT_END
+
+static GstData *
+sinesrc_get (GstPad * pad)
+{
+  GstBuffer *buf;
+  SineSrc *src;
+
+  void *data;
+  gint i, j;
+  gdouble value;
+
+  g_return_val_if_fail (pad != NULL, NULL);
+  src = SINESRC (gst_pad_get_parent (pad));
+
+  if (src->pre_get_func)
+    src->pre_get_func (src);
+
+  buf = gst_buffer_new_and_alloc ((src->width / 8) * src->channels *
+      SAMPLES_PER_WAVE);
+  g_assert (buf);
+  data = GST_BUFFER_DATA (buf);
+  g_assert (data);
+
+  for (i = 0; i < SAMPLES_PER_WAVE; i++) {
+    value = sin (i * 2 * M_PI / SAMPLES_PER_WAVE);
+    switch (src->type) {
+      case SINE_SRC_INT:{
+        gint64 int_value =
+            (value + (src->sign ? 0 : 1)) * (((guint64) 1) << (src->depth - 1));
+        if (int_value ==
+            (1 + (src->sign ? 0 : 1)) * (((guint64) 1) << (src->depth - 1)))
+          int_value--;
+        switch (src->width) {
+          case 8:
+            if (src->sign)
+              POPULATE (gint8, IDENTITY, IDENTITY);
+            else
+              POPULATE (guint8, UIDENTITY, UIDENTITY);
+            break;
+          case 16:
+            if (src->sign)
+              POPULATE (gint16, GINT16_TO_BE, GINT16_TO_LE);
+            else
+              POPULATE (guint16, GUINT16_TO_BE, GUINT16_TO_LE);
+            break;
+          case 24:
+            if (src->sign) {
+              gpointer p;
+              gint32 val = (gint32) int_value;
+
+              switch (src->endianness) {
+                case G_LITTLE_ENDIAN:
+                  val = GINT32_TO_LE (val);
+                  break;
+                case G_BIG_ENDIAN:
+                  val = GINT32_TO_BE (val);
+                  break;
+                default:
+                  g_assert_not_reached ();
+              };
+              p = &val;
+              if (src->endianness == G_BIG_ENDIAN)
+                p++;
+              for (j = 0; j < src->channels; j++) {
+                memcpy (data, p, 3);
+                data += 3;
+              }
+            } else {
+              gpointer p;
+              guint32 val = (guint32) int_value;
+
+              switch (src->endianness) {
+                case G_LITTLE_ENDIAN:
+                  val = GUINT32_TO_LE (val);
+                  break;
+                case G_BIG_ENDIAN:
+                  val = GUINT32_TO_BE (val);
+                  break;
+                default:
+                  g_assert_not_reached ();
+              };
+              p = &val;
+              if (src->endianness == G_BIG_ENDIAN)
+                p++;
+              for (j = 0; j < src->channels; j++) {
+                memcpy (data, p, 3);
+                data += 3;
+              }
+            }
+            break;
+          case 32:
+            if (src->sign)
+              POPULATE (gint32, GINT32_TO_BE, GINT32_TO_LE);
+            else
+              POPULATE (guint32, GUINT32_TO_BE, GUINT32_TO_LE);
+            break;
+          default:
+            g_assert_not_reached ();
+        }
+        break;
+      }
+      case SINE_SRC_FLOAT:
+        if (src->width == 32) {
+          gfloat *p = (gfloat *) data;
+          gfloat fval = (gfloat) value;
+
+          for (j = 0; j < src->channels; j++) {
+            *p = fval;
+            p++;
+          }
+          data = p;
+          break;
+        }
+        if (src->width == 64) {
+          gdouble *p = (gdouble *) data;
+
+          for (j = 0; j < src->channels; j++) {
+            *p = value;
+            p++;
+          }
+          data = p;
+          break;
+        }
+        g_assert_not_reached ();
+      default:
+        g_assert_not_reached ();
+    }
+  }
+
+  if (src->newcaps) {
+    sinesrc_force_caps (src);
+  }
+  return GST_DATA (buf);
+}
+
+GstElement *
+sinesrc_new (void)
+{
+  return GST_ELEMENT (g_object_new (TYPE_SINESRC, NULL));
+}
+
+void
+sinesrc_set_pre_get_func (SineSrc * src, PreGetFunc func)
+{
+  src->pre_get_func = func;
+}
+
+static GstStateChangeReturn
+sinesrc_change_state (GstElement * element, GstStateChange transition)
+{
+  SineSrc *sinesrc;
+
+  g_return_val_if_fail (element != NULL, FALSE);
+  sinesrc = SINESRC (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+    case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      sinesrc->newcaps = TRUE;
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      g_assert_not_reached ();
+  }
+
+  if (GST_ELEMENT_CLASS (parent_class)->change_state)
+    return GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return GST_STATE_CHANGE_SUCCESS;
+}
diff -Naur tests/old/testsuite/alsa/sinesrc.h tests/old/testsuite/alsa/sinesrc.h
--- tests/old/testsuite/alsa/sinesrc.h	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/alsa/sinesrc.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2003 Benjamin Otte <in7y118@public.uni-hamburg.de>
+ *
+ * sinesrc.h: Header file for sinesrc.c
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __SINESRC_H__
+#define __SINESRC_H__
+
+
+#include <gst/gst.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+  
+
+#define TYPE_SINESRC \
+  (sinesrc_get_type())
+#define SINESRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),TYPE_SINESRC,SineSrc))
+#define SINESRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),TYPE_SINESRC,SineSrcClass))
+#define IS_SINESRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),TYPE_SINESRC))
+#define IS_SINESRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),TYPE_SINESRC))
+
+typedef struct _SineSrc SineSrc;
+typedef struct _SineSrcClass SineSrcClass;
+
+typedef void (*PreGetFunc) (SineSrc *src);
+
+typedef enum {
+  SINE_SRC_INT,
+  SINE_SRC_FLOAT
+} SineSrcAudio;
+
+struct _SineSrc {
+  GstElement element;
+
+  /* pads */
+  GstPad *src;
+
+  /* audio parameters */
+  SineSrcAudio type;
+  gint width; /* int + float */
+  gint depth; /* int */
+  gboolean sign; /* int */
+  gint endianness; /* int */
+  
+  gint rate;
+  gint channels; /* interleaved */
+  
+  gboolean newcaps;
+  
+  /* freaky stuff for testing */
+  PreGetFunc pre_get_func;
+};
+
+struct _SineSrcClass {
+  GstElementClass parent_class;
+};
+
+GType           sinesrc_get_type                (void);
+GstElement *    sinesrc_new                     (void);
+
+void            sinesrc_set_pre_get_func        (SineSrc *src, PreGetFunc func);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __GST_SINESRC_H__ */
diff -Naur tests/old/testsuite/alsa/srcstate.c tests/old/testsuite/alsa/srcstate.c
--- tests/old/testsuite/alsa/srcstate.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/alsa/srcstate.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2003 Benjamin Otte <in7y118@public.uni-hamburg.de>
+ *
+ * srcstate.c: Tests alsasrc for state changes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <gst/gst.h>
+
+GstElement *pipeline;
+
+static void
+set_state (GstState state)
+{
+  GstState old_state = gst_element_get_state (pipeline);
+
+  g_print ("Setting state from %s to %s...",
+      gst_element_state_get_name (old_state),
+      gst_element_state_get_name (state));
+
+  if (!gst_element_set_state (pipeline, state)) {
+    g_print (" ERROR\n");
+    exit (-1);
+  }
+
+  if (state == GST_STATE_PLAYING) {
+    gint i;
+
+    g_print (" DONE - iterating a bit...");
+    for (i = 0; i < 5; i++) {
+      if (!gst_bin_iterate (GST_BIN (pipeline))) {
+        g_print (" ERROR in iteration %d\n", i);
+        exit (-2);
+      }
+    }
+  }
+  g_print (" DONE\n");
+}
+
+static void
+create_pipeline (void)
+{
+  GstElement *alsasrc;
+  GstElement *fakesink;
+
+  pipeline = gst_pipeline_new ("pipeline");
+  alsasrc = gst_element_factory_make ("alsasrc", "alsasrc");
+  fakesink = gst_element_factory_make ("fakesink", "fakesink");
+
+  gst_bin_add_many (GST_BIN (pipeline), alsasrc, fakesink, NULL);
+  gst_element_link (alsasrc, fakesink);
+
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  gst_init (&argc, &argv);
+
+  g_print ("\n" "This test will check if state changes work on the alsasrc.\n");
+  create_pipeline ();
+
+  /* simulate some state changes here */
+  set_state (GST_STATE_READY);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_READY);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_PAUSED);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_PLAYING);
+  set_state (GST_STATE_PAUSED);
+  set_state (GST_STATE_PLAYING);
+  set_state (GST_STATE_READY);
+  set_state (GST_STATE_PLAYING);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_PLAYING);
+
+  g_print ("The alsa plugin mastered another test.\n");
+
+  gst_object_unref (pipeline);
+
+  return 0;
+}
diff -Naur tests/old/testsuite/alsa/state.c tests/old/testsuite/alsa/state.c
--- tests/old/testsuite/alsa/state.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/alsa/state.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2003 Benjamin Otte <in7y118@public.uni-hamburg.de>
+ *
+ * state.c: Tests alsasink for state changes
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "sinesrc.h"
+
+GstElement *pipeline;
+
+static void
+set_state (GstState state)
+{
+  GstState old_state = gst_element_get_state (pipeline);
+
+  g_print ("Setting state from %s to %s...",
+      gst_element_state_get_name (old_state),
+      gst_element_state_get_name (state));
+
+  if (!gst_element_set_state (pipeline, state)) {
+    g_print (" ERROR\n");
+    exit (-1);
+  }
+
+  if (state == GST_STATE_PLAYING) {
+    gint i;
+
+    g_print (" DONE - iterating a bit...");
+    for (i = 0; i < 400; i++) {
+      if (!gst_bin_iterate (GST_BIN (pipeline))) {
+        g_print (" ERROR in iteration %d\n", i);
+        exit (-2);
+      }
+    }
+  }
+  g_print (" DONE\n");
+}
+
+static void
+create_pipeline (void)
+{
+  GstElement *src;
+  SineSrc *sinesrc;
+  GstElement *alsasink;
+
+  pipeline = gst_pipeline_new ("pipeline");
+  src = sinesrc_new ();
+  alsasink = gst_element_factory_make ("alsasink", "alsasink");
+
+  gst_bin_add_many (GST_BIN (pipeline), src, alsasink, NULL);
+  gst_element_link (src, alsasink);
+
+  /* prepare our sinesrc */
+  sinesrc = (SineSrc *) src;
+  sinesrc->newcaps = TRUE;
+  sinesrc->type = SINE_SRC_INT;
+  sinesrc->sign = TRUE;
+  sinesrc->endianness = G_BYTE_ORDER;
+  sinesrc->depth = 16;
+  sinesrc->width = 16;
+}
+
+gint
+main (gint argc, gchar * argv[])
+{
+  gst_init (&argc, &argv);
+
+  g_print ("\n"
+      "This test will check if state changes work on the alsasink.\n"
+      "You will hear some short sine tones on your default ALSA soundcard,\n"
+      "but they are not important in this test.\n" "\n");
+  create_pipeline ();
+
+  /* simulate some state changes here */
+  set_state (GST_STATE_READY);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_READY);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_PAUSED);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_PLAYING);
+  set_state (GST_STATE_PAUSED);
+  set_state (GST_STATE_PLAYING);
+  set_state (GST_STATE_READY);
+  set_state (GST_STATE_PLAYING);
+  set_state (GST_STATE_NULL);
+  set_state (GST_STATE_PLAYING);
+
+  g_print ("The alsa plugin mastered another test.\n");
+
+  gst_object_unref (pipeline);
+
+  return 0;
+}
diff -Naur tests/old/testsuite/embed/embed.c tests/old/testsuite/embed/embed.c
--- tests/old/testsuite/embed/embed.c	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/embed/embed.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * Sample app for element embedding.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <gst/gst.h>
+#include <gst/xoverlay/xoverlay.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+
+static void
+cb_expose (GtkWidget * w, GdkEventExpose * ev, GstElement * e)
+{
+  if (GST_IS_X_OVERLAY (e) &&
+      !GTK_WIDGET_NO_WINDOW (w) && GTK_WIDGET_REALIZED (w)) {
+    gst_x_overlay_set_xwindow_id (GST_X_OVERLAY (e),
+        GDK_WINDOW_XWINDOW (w->window));
+  }
+}
+
+int
+main (int argc, char *argv[])
+{
+  GtkWidget *window, *content;
+  GstElement *testsrc, *csp, *videosink, *pipeline;
+
+  gtk_init (&argc, &argv);
+  gst_init (&argc, &argv);
+
+  pipeline = gst_element_factory_make ("pipeline", NULL);
+  testsrc = gst_element_factory_make ("videotestsrc", NULL);
+  csp = gst_element_factory_make ("ffmpegcolorspace", NULL);
+  videosink = gst_element_factory_make (DEFAULT_VIDEOSINK, NULL);
+
+  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+  gtk_window_set_default_size (GTK_WINDOW (window), 640, 480);
+  gtk_window_set_title (GTK_WINDOW (window), "My application");
+  content = gtk_event_box_new ();
+  gtk_container_add (GTK_CONTAINER (window), content);
+  g_signal_connect (content, "expose-event", G_CALLBACK (cb_expose), videosink);
+  gtk_widget_show_all (window);
+
+  gst_bin_add_many (GST_BIN (pipeline), testsrc, csp, videosink, NULL);
+  gst_element_link_many (testsrc, csp, videosink, NULL);
+
+  g_idle_add ((GSourceFunc) gst_bin_iterate, pipeline);
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+
+  gtk_main ();
+
+  return 0;
+}
diff -Naur tests/old/testsuite/embed/Makefile.am tests/old/testsuite/embed/Makefile.am
--- tests/old/testsuite/embed/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/embed/Makefile.am	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,7 @@
+
+noinst_PROGRAMS = embed
+
+# we have nothing but apps here, we can do this safely
+LIBS = $(GST_LIBS) $(GTK_LIBS) \
+	$(top_builddir)/gst-libs/gst/libgstinterfaces-$(GST_MAJORMINOR).la
+AM_CFLAGS = $(GST_CFLAGS) $(GTK_CFLAGS)
diff -Naur tests/old/testsuite/gst-lint tests/old/testsuite/gst-lint
--- tests/old/testsuite/gst-lint	1970-01-01 01:00:00.000000000 +0100
+++ tests/old/testsuite/gst-lint	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,571 @@
+#!/usr/bin/perl -w 
+# vi: set ts=4:
+#
+
+#
+# GStreamer developers:  please add comments on any tests you think
+# are dumb or have too many false positives.
+#
+
+#
+# Future ideas:
+# - spell check comments
+# - check each function for at least one assertion (?)
+# - check parameters that init/set/get have consistent types
+# - check for gst_caps_set() without check for writeability
+# - check .so files for stray symbols
+#
+
+#
+# Random "other" testing ideas
+# - load each plugin individually
+#
+
+sub check_copyright();
+sub check_license();
+sub check_buffer_alloc();
+sub check_bad_includes();
+sub check_begin_decls();
+sub check_c99_comments();
+sub check_carriage_returns();
+sub check_printf_lld();
+sub check_glibisms();
+sub check_indentation();
+sub check_no_ignore();
+sub check_deprecated();
+sub check_config_h();
+sub check_varargs_functions();
+sub check_debugging();
+sub check_old_typefind();
+sub check_bad_casts();
+sub check_old_plugin();
+sub check_signal_new();
+sub check_gnuc_const();
+sub check_caps();
+sub check_lib_deprecated();
+sub check_typo();
+sub check_explicit_caps();
+sub check_signals();
+sub check_gettext();
+sub check_padtemplate();
+sub check_parent_class();
+
+sub m_check_plugindir();
+sub m_check_interfaces();
+
+open FIND, "find . -name \"*.[ch]\" -print|";
+
+foreach $filename (<FIND>) {
+	chomp $filename;
+	open FILE, "$filename";
+	@lines = <FILE>;
+	close FILE;
+
+	print "I: $filename\n";
+
+	# important stuff
+	check_bad_includes();
+	check_printf_lld();
+	check_no_ignore();
+	check_deprecated();
+	check_config_h();
+	check_old_typefind();
+	check_old_plugin();
+	check_caps();
+	check_lib_deprecated();
+	check_typo();
+	check_glibisms();
+	check_explicit_caps();
+	check_signals();
+	check_gettext();
+	check_padtemplate();
+	check_parent_class();
+
+	# less important stuff
+	check_license();
+
+if (0) {
+	check_copyright();
+
+    check_gnuc_const();
+	check_begin_decls();
+	check_buffer_alloc();
+	check_c99_comments();
+	check_carriage_returns();
+	#check_indentation();
+	check_varargs_functions();
+	check_debugging();
+	check_bad_casts();
+	check_signal_new();
+}
+}
+
+open FIND, "find . -name \"Makefile.am\" -print|";
+
+foreach $filename (<FIND>) {
+	chomp $filename;
+	open FILE, "$filename";
+	@lines = <FILE>;
+	close FILE;
+
+	print "I: $filename\n";
+
+	m_check_plugindir();
+	m_check_interfaces();
+}
+
+#
+# Every source file must have a copyright block
+#
+sub check_copyright()
+{
+	if (! grep { /copyright/i; } @lines) {
+		print "E: no copyright block\n";
+	}
+}
+
+#
+# Every source file should have a license statement
+#
+sub check_license()
+{
+	if (grep { /Lesser General Public License/; } @lines) {
+		print "I: license is LGPL\n";
+	} elsif (grep { /Library General Public License/; } @lines) {
+		print "I: license is LGPL\n";
+		print "W: copyright header uses \"Library\" LGPL\n";
+	} elsif (grep { /General Public License/; } @lines) {
+		print "I: license is GPL\n";
+	} else {
+		print "E: unknown license or no copyright block\n";
+	}
+}
+
+#
+# Suggest usage of gst_buffer_new_and_alloc()
+#
+sub check_buffer_alloc()
+{
+	my $n = 0;
+	my $lineno = 1;
+
+	foreach $line (@lines){
+		if($line =~ /gst_buffer_new/){
+			$n=5;
+		}
+		if($n>0 && $line =~ /malloc/){
+			print "W: ($lineno) gst_buffer_new() followed by malloc(), suggest gst_buffer_new_and_alloc()\n";
+			return;
+		}
+		$n--;
+		$lineno++;
+	}
+}
+
+sub check_bad_includes()
+{
+	#
+	# malloc.h is non-standard (and probably not what is indended)
+	#
+	if (grep { /^#include\s+<malloc.h>/; } @lines) {
+		print "E: bad header: malloc.h\n"
+	}
+}
+
+sub check_begin_decls()
+{
+	#
+	# Prefer "G_BEGIN_DECLS" to 'extern "C" {'
+	#
+	if($filename =~ /\.h$/){
+		if (grep { /extern\s*\"C\"\s*/; } @lines) {
+			print "W: extern \"C\" { should be changed to G_BEGIN_DECLS,G_END_DECLS\n";
+		}elsif (!grep { /G_BEGIN_DECLS/; } @lines) {
+			print "E: header doesn't use G_BEGIN_DECLS\n";
+		}
+	}
+}
+
+#
+# Prefer c89-style comments
+#
+sub check_c99_comments()
+{
+	if (grep { /\/\//; } @lines) {
+		print "W: //-style comments should be converted to /* */\n"
+	}
+}
+
+#
+# DOS end-of-line characters are just wrong
+#
+sub check_carriage_returns()
+{
+	if (grep { /\r/; } @lines) {
+		print "E: source has carriage returns (DOS-style files)\n"
+	}
+}
+
+#
+# Many uses of %lld are wrong.  This could have a lot of false-positives
+#
+sub check_printf_lld()
+{
+	if (grep { /\".*\%\d*ll[du].*\"/; } @lines) {
+		print "W: Possible \%lld or \%llu in printf format\n"
+	}
+}
+
+#
+# Glib functions are preferred
+#
+sub check_glibisms()
+{
+	if (grep { /\bcalloc\s*\(/; } @lines) {
+		print "E: use g_malloc0() instead of calloc()\n"
+	}
+	if (grep { /\bfree\s*\(/; } @lines) {
+		print "E: use g_free() instead of free()\n"
+	}
+	if (grep { /\bmalloc\s*\(/; } @lines) {
+		print "E: use g_malloc() instead of malloc()\n"
+	}
+	if (grep { /\bprintf\s*\(/; } @lines) {
+		print "E: use g_print() instead of printf()\n"
+	}
+	if (grep { /\brealloc\s*\(/; } @lines) {
+		print "E: use g_realloc() instead of realloc()\n"
+	}
+	if (grep { /^#include\s+<ctype.h>/; } @lines) {
+		print "E: ctype.h functions are not locale-independent and don't work in UTF-8 locales.  Use g_ascii_is*()\n"
+	}
+}
+
+#
+# I don't think that indentation necessarily needs to be fixed, since
+# it causes problems with patching and cvs annotate.
+#
+# This takes forever and isn't very useful
+#
+sub check_indentation()
+{
+	my $changed_lines;
+	my $percent;
+
+	`indent -br -bad -cbi0 -cli2 -bls -l80 -ut -ce $filename -o .check_plugin.tmp`;
+	$changed_lines = `diff $filename .check_plugin.tmp | grep '^>' | wc -l`;
+	`rm -f .check_plugin.tmp`;
+
+	$percent = int(100 * $changed_lines / $#lines);
+
+	if($percent < 10){
+		print "I: indent changed $percent % of the lines\n";
+	}elsif($percent <20){
+		print "W: indent changed $percent % of the lines\n";
+	}else{
+		print "E: indent changed $percent % of the lines\n";
+	}
+}
+
+
+#
+# Check (roughly) for functions whose value should not be ignored
+#
+sub check_no_ignore()
+{
+	if (grep { /^\s+gst_buffer_merge\s*\(/; } @lines) {
+		print "E: return value of gst_buffer_merge () possibly ignored\n";
+	}
+	if (grep { /^\s+malloc\s*\(/; } @lines) {
+		print "E: return value of malloc() possibly ignored\n";
+	}
+	if (grep { /^\s+gst_buffer_new\s*\(/; } @lines) {
+		print "E: return value of gst_buffer_new() possibly ignored\n";
+	}
+}
+
+#
+# Check for some deprecated stuff (that _shouldn't_ be around anymore)
+#
+sub check_deprecated()
+{
+	#
+	# Check for old GST_DEBUG() usage
+	# (none found)
+	#
+	if (grep { /GST_DEBUG\s*\(\s+\d/; } @lines) {
+		print "E: old-style GST_DEBUG()\n";
+	}
+	if (grep { /GST_INFO\s*\(\s+\d/; } @lines) {
+		print "E: old-style GST_DEBUG()\n";
+	}
+	if (grep { /GstEventFlags/; } @lines) {
+		print "W: who uses GstEventFlags\n";
+	}
+	if (grep { /g_type_class_ref/ } @lines) {
+		print "W: g_type_class_ref should be changed to g_type_class_peek_parent\n";
+	}
+
+}
+
+#
+# Every .c file should include config.h before any other headers
+# No .h file should include config.h
+#
+sub check_config_h()
+{
+	if($filename =~ /\.c$/){
+		#
+		# config.h should be wrapped
+		#
+		my @includes = grep { /^#include/; } @lines;
+	
+		if (!grep { /^#include\s+["<]config.h[">]/; } @includes) {
+			print "E: #include <config.h> missing\n";
+		}else{
+			if (!($includes[0] =~ /^#include\s+["<]config.h[">]/)){
+				print "E: #include <config.h> is not first include\n";
+			}
+			if(!grep { /^#ifdef HAVE_CONFIG_H/; } @lines) {
+				print "E: #include <config.h> not surrounded by #ifdef HAVE_CONFIG_H\n";
+			}
+		}
+	}
+
+	if($filename =~ /\.h$/){
+		if (grep { /^#include\s+["<]config.h[">]/; } @lines) {
+			print "E: headers should not #include <config.h>\n";
+		}
+	}
+
+}
+  
+#
+# Check for functions that take varargs to make sure they are
+# named correctly
+#
+sub check_varargs_functions()
+{
+	if($filename =~ /\.h$/){
+		if (grep { /varargs/; } @lines) {
+			print "I: has varargs\n";
+		}
+	}
+}
+
+#
+# Debugging checks
+#
+sub check_debugging()
+{
+	if (grep { /\Wg_print\W/ || /\Wprintf\W/ && /\Wfprintf\W/; } @lines) {
+		print "W: friendly libraries don't print to stdio or stderr\n";
+	}
+
+	if (grep { /GST_DEBUG.*\\n"/; } @lines) {
+		print "W: possible newline in GST_DEBUG()\n";
+	}
+
+}
+
+#
+# check for plugindir=
+#
+sub m_check_plugindir()
+{
+	if (grep { /plugindir\s*=/; } @lines) {
+		print "E: plugindir= is no longer necessary\n";
+	}
+}
+
+#
+# check for old typefinding code
+#
+sub check_old_typefind()
+{
+	if (grep { /GstTypeDefinition/ || /GstTypeFactory/ } @lines) {
+		print "E: old typefind interface has been removed\n";
+	}
+}
+
+#
+# check for casts that we've deemed incorrect (fix the prototype)
+#
+sub check_bad_casts()
+{
+	if (grep { /GBaseInitFunc/ || /GBaseFinalizeFunc/ ||
+			/GClassInitFunc/ || /GClassFinalizeFunc/ ||
+			/GInstanceInitFunc/ || /GInterfaceInitFunc/ ||
+			/GInterfaceFinalizeFunc/ } @lines) {
+		print "W: bad casts (fix prototype)\n";
+	}
+	if (grep { /\(\s*Gst[A-Z][A-Za-z]*\s*\*\s*\)/ } @lines ) {
+		print "W: use GST_XXX() instead of (GstXxx *)\n";
+	}
+
+}
+
+#
+# check for old plugin code
+#
+sub check_old_plugin()
+{
+	if (grep { /plugin_init.*GModule.*GstPlugin/ } @lines) {
+		print "E: old plugin interface detected\n";
+	}
+	if (grep { /GstPluginDesc.*plugin_desc/ } @lines) {
+		print "W: should use GST_PLUGIN_DEFINE() instead of GstPluginDesc\n";
+	}
+}
+
+#
+# Check for calls to g_signal_new() with a callback type of G_TYPE_POINTER
+#
+sub check_signal_new()
+{
+	my $n = 0;
+	my $lineno = 1;
+
+	foreach $line (@lines){
+		if($line =~ /g_signal_new/){
+			$n=5;
+		}
+		if($n>0 && $line =~ /G_TYPE_POINTER/){
+			print "W: ($lineno) g_signal_new() with callback type of G_TYPE_POINTER.  Register and use a boxed type instead.\n";
+			return;
+		}
+		$n--;
+		$lineno++;
+	}
+}
+
+#
+# Check that libgstinterfaces is in LDADD
+#
+sub m_check_interfaces()
+{
+	if (grep { /libgstinterfaces.la/ } @lines) {
+		if (! grep { /libgstinterfaces_la/ } @lines) {
+	  		if (! grep { /_LDADD.*libgstinterfaces.la/ } @lines) {
+				print "E: libgstinterfaces.la not in LDADD\n";
+			}
+		}
+	}
+}
+
+#
+# Check that get_type() functions return G_CONST_RETURN GType
+#
+sub check_gnuc_const()
+{
+	my $n = 0;
+	my $lineno = 1;
+
+	foreach $line (@lines){
+	    if($line =~ /GType.*get_type.*/ &&
+	        !($line =~ /GType.*get_type.*G_GNUC_CONST/)) {
+
+			print "E: get_type function does not have G_GNUC_CONST attribute\n";
+		}
+	}
+}
+
+#
+# Check caps usage
+#
+sub check_caps()
+{
+	if (grep { /gst_pad_get_caps/ } @lines) {
+		print "E: elements should not call gst_pad_get_caps(), use gst_pad_get_allowed_caps()\n";
+	}
+}
+
+#
+# Check for use of deprecated functions
+#
+sub check_lib_deprecated()
+{
+	if (grep { /bzero/ } @lines) {
+		print "E: change bzero() to memset()\n";
+	}
+}
+
+#
+# Check for typos
+#
+sub check_typo()
+{
+	if (grep { /;\s*;\s*$/ } @lines) {
+		print "W: typo? \";;\"\n";
+	}
+}
+
+#
+# set_explicit_caps() should preceed pad_add()
+#
+sub check_explicit_caps()
+{
+	my $n = 0;
+	my $lineno = 1;
+
+	foreach $line (@lines){
+		if($line =~ /gst_element_add_pad/){
+			$n=10;
+		}
+		if($n>0 && $line =~ /gst_pad_set_explicit_caps/){
+			print "W: ($lineno) explicit caps should be set before adding pad\n";
+			return;
+		}
+		$n--;
+		$lineno++;
+	}
+}
+
+#
+# Check for - in signal names
+#
+sub check_signals()
+{
+	if (grep { /g_signal_new.*\".*-.*\"/; } @lines) {
+		print "E: g_signal_new() with a signal name with a - in it (we prefer _)\n"
+	}
+}
+
+#
+# Check for things that gettext gets wrong
+#
+sub check_gettext()
+{
+	if (grep { /\b_\(.*G_GU?INT64_FORMAT/ ||
+	           /\b_\(.*GST_TIME_FORMAT/ ||
+	           /\b_\(.*GST_FOURCC_FORMAT/ } @lines) {
+		print "E: gettext doesn't handle format strings that are defines\n"
+	}
+}
+
+#
+# Check that pad templates are statically scoped
+#
+sub check_padtemplate()
+{
+	foreach $line (@lines){
+		if ($line =~ /GstStaticPadTemplate/ && !($line =~ /static/)) {
+			print "W: pad template definitions should be static\n";
+			return;
+		}
+	}
+}
+
+#
+# Check that parent_class is statically scoped
+#
+sub check_parent_class()
+{
+	foreach $line (@lines){
+		if ($line =~ /Gst.*\*\s*parent_class/ && !($line =~ /static/)) {
+			print "E: parent_class definitions should be static\n";
+			return;
+		}
+	}
+}
+
diff -Naur tools/filterstamp.sh tools/filterstamp.sh
--- tools/filterstamp.sh	1970-01-01 01:00:00.000000000 +0100
+++ tools/filterstamp.sh	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,57 @@
+#!/bin/bash
+
+# copies from gstreamer filter boilerplate
+# to new filter
+# changing file names and function references
+
+# thomas@apestaart.org
+
+# modified 23 aug 2001 apwingo@eos.ncsu.edu:
+# conform better to gtk naming conventions (GstFoo->gst_foo in functions, etc)
+
+if [ "$1" = "" ]
+then
+  echo "please specify the filter to copy FROM (e.g. Passthrough)"
+  exit
+fi
+
+if [ "$2" = "" ]
+then
+  echo "please specify the filter to copy TO (e.g. NewFilter)"
+  exit
+fi
+
+FROM=$1
+TO=$2
+FROM_LC=`echo $FROM | tr [A-Z] [a-z]`
+TO_LC=`echo $TO | tr [A-Z] [a-z]`
+FROM_UC=`echo $FROM | tr [a-z] [A-Z]`
+TO_UC=`echo $TO | tr [a-z] [A-Z]`
+FROM_LC_UNDERSCORE=`echo $FROM | perl -n -p -e 's/([a-z])([A-Z])/$1_$2/g; tr/A-Z/a-z/'`
+TO_LC_UNDERSCORE=`echo $TO | perl -n -p -e 's/([a-z])([A-Z])/$1_$2/g; tr/A-Z/a-z/'`
+
+echo "Copying filter boilerplate $FROM to new filter $TO..."
+
+if [ ! -d $FROM_LC ]
+then
+  echo "Filter directory $FROM_LC does not exist !"
+  exit
+fi
+
+if [ -d $TO_LC ]
+then
+  echo "Filter directory $TO_LC already exists !"
+  exit
+fi
+
+cp  -r $FROM_LC $TO_LC
+
+cd $TO_LC
+
+for a in *$FROM_LC*; do mv $a `echo $a | sed s/$FROM_LC/$TO_LC/g`; done
+
+perl -i -p -e "s/$FROM/$TO/g" *
+perl -i -p -e "s/${FROM_LC_UNDERSCORE}_/${TO_LC_UNDERSCORE}_/g" *
+perl -i -p -e "s/$FROM_LC/$TO_LC/g" *
+perl -i -p -e "s/$FROM_UC/$TO_UC/g" *
+
diff -Naur tools/gst-launch-ext.1.in tools/gst-launch-ext.1.in
--- tools/gst-launch-ext.1.in	1970-01-01 01:00:00.000000000 +0100
+++ tools/gst-launch-ext.1.in	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,42 @@
+.TH "GStreamer" "1" "February 2002" "" ""
+.SH "NAME"
+gst\-launch\-ext \- Run a predefined GStreamer pipeline
+.SH "SYNOPSIS"
+\fBgst\-launch\-ext\fR \fIfilename [filename...]\fR
+.SH "DESCRIPTION"
+.LP 
+\fIgst\-launch\-ext\fP is a tool that is used to run a basic predefined 
+\fIGStreamer\fP pipeline.  This application is only used as a quick test to 
+ensure proper working of codecs and GStreamer.  It doesn't handle more advanced
+features like synchronisation.
+
+All supported formats in GStreamer should be playable by simply typing:
+
+ gst\-launch\-ext filename
+
+It will also print out the pipeline it uses, so you can customize it using
+cut and paste.
+
+.SH "CONFIGURATION"
+.LP 
+\fIgst\-launch\-ext\fP can be configured by creating a .gst file in your
+home directory.  This is a perl-style configuration file and can override
+the defaults for audio and video output sinks.
+
+Here is an example .gst file that implements the same defaults as hard-coded
+in the script :
+
+AUDIOSINK = osssink
+VIDEOSINK = ffmpegcolorspace ! xvimagesink
+
+You can change osssink to esdsink or alsasink (if you have
+the plug-in), and you can change xvimagesink to ximagesink, aasink
+or sdlvideosink.
+
+Other plug-ins might be used as well if GStreamer has them.
+
+.SH "SEE ALSO"
+.BR gst\-inspect (1),
+.BR gst\-launch (1),
+.SH "AUTHOR"
+The GStreamer team at http://gstreamer.net/
diff -Naur tools/README.filterstamp tools/README.filterstamp
--- tools/README.filterstamp	1970-01-01 01:00:00.000000000 +0100
+++ tools/README.filterstamp	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,24 @@
+filterstamp.sh is a script to copy a filter and change filenames and all
+occurrences of the old name to the new name.
+
+This is used for writing new audio filters. The best one to copy for now is
+passthrough; it works on raw/audio int or float data.
+
+If your new filter is called StereoPan, for example, then do this :
+
+cd gst
+../tools/filterstamp.sh Passthrough StereoPan
+cd stereopan
+make
+
+(Please note the upper- and lower-case !)
+
+You should also add a line to configure.ac to make sure the Makefiles are built
+correctly. Just search for "passthrough" and add corresponding "stereopan" (or
+whatever your plugin is) lines.
+
+Register it, then try it out.  It shouldn't do anything !
+
+Now edit the filter.func in the new directory; this file contains the body
+of the main processing loop.
+
diff -Naur win32/common/libgstinterfaces.def win32/common/libgstinterfaces.def
--- win32/common/libgstinterfaces.def	2009-04-15 21:18:28.000000000 +0200
+++ win32/common/libgstinterfaces.def	2009-05-19 18:44:45.000000000 +0200
@@ -1,5 +1,6 @@
 EXPORTS
 	gst_color_balance_channel_get_type
+	gst_color_balance_get_balance_type
 	gst_color_balance_get_type
 	gst_color_balance_get_value
 	gst_color_balance_list_channels
@@ -8,6 +9,7 @@
 	gst_color_balance_value_changed
 	gst_mixer_flags_get_type
 	gst_mixer_get_mixer_flags
+	gst_mixer_get_mixer_type
 	gst_mixer_get_option
 	gst_mixer_get_type
 	gst_mixer_get_volume
diff -Naur win32/common/libgstutils.def win32/common/libgstutils.def
--- win32/common/libgstutils.def	1970-01-01 01:00:00.000000000 +0100
+++ win32/common/libgstutils.def	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,8 @@
+EXPORTS
+	gst_pb_utils_init
+	gst_pb_utils_get_source_description
+	gst_is_missing_plugin_message
+	gst_missing_decoder_message_new
+	gst_missing_element_message_new
+	gst_missing_plugin_message_get_installer_detail
+	gst_missing_uri_source_message_new
diff -Naur win32/common/multichannel-enumtypes.c win32/common/multichannel-enumtypes.c
--- win32/common/multichannel-enumtypes.c	1970-01-01 01:00:00.000000000 +0100
+++ win32/common/multichannel-enumtypes.c	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,53 @@
+
+/* Generated data (by glib-mkenums) */
+
+#include "multichannel-enumtypes.h"
+
+#include "multichannel.h"
+
+/* enumerations from "multichannel.h" */
+GType
+gst_audio_channel_position_get_type (void)
+{
+  static GType etype = 0;
+
+  if (etype == 0) {
+    static const GEnumValue values[] = {
+      {GST_AUDIO_CHANNEL_POSITION_INVALID, "GST_AUDIO_CHANNEL_POSITION_INVALID",
+          "invalid"},
+      {GST_AUDIO_CHANNEL_POSITION_FRONT_MONO,
+          "GST_AUDIO_CHANNEL_POSITION_FRONT_MONO", "front-mono"},
+      {GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT,
+          "GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT", "front-left"},
+      {GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT,
+          "GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT", "front-right"},
+      {GST_AUDIO_CHANNEL_POSITION_REAR_CENTER,
+          "GST_AUDIO_CHANNEL_POSITION_REAR_CENTER", "rear-center"},
+      {GST_AUDIO_CHANNEL_POSITION_REAR_LEFT,
+          "GST_AUDIO_CHANNEL_POSITION_REAR_LEFT", "rear-left"},
+      {GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT,
+          "GST_AUDIO_CHANNEL_POSITION_REAR_RIGHT", "rear-right"},
+      {GST_AUDIO_CHANNEL_POSITION_LFE, "GST_AUDIO_CHANNEL_POSITION_LFE", "lfe"},
+      {GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER,
+          "GST_AUDIO_CHANNEL_POSITION_FRONT_CENTER", "front-center"},
+      {GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER,
+            "GST_AUDIO_CHANNEL_POSITION_FRONT_LEFT_OF_CENTER",
+          "front-left-of-center"},
+      {GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER,
+            "GST_AUDIO_CHANNEL_POSITION_FRONT_RIGHT_OF_CENTER",
+          "front-right-of-center"},
+      {GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT,
+          "GST_AUDIO_CHANNEL_POSITION_SIDE_LEFT", "side-left"},
+      {GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT,
+          "GST_AUDIO_CHANNEL_POSITION_SIDE_RIGHT", "side-right"},
+      {GST_AUDIO_CHANNEL_POSITION_NONE, "GST_AUDIO_CHANNEL_POSITION_NONE",
+          "none"},
+      {GST_AUDIO_CHANNEL_POSITION_NUM, "GST_AUDIO_CHANNEL_POSITION_NUM", "num"},
+      {0, NULL, NULL}
+    };
+    etype = g_enum_register_static ("GstAudioChannelPosition", values);
+  }
+  return etype;
+}
+
+/* Generated data ends here */
diff -Naur win32/common/multichannel-enumtypes.h win32/common/multichannel-enumtypes.h
--- win32/common/multichannel-enumtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ win32/common/multichannel-enumtypes.h	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,19 @@
+
+/* Generated data (by glib-mkenums) */
+
+#ifndef __GST_AUDIO_ENUM_TYPES_H__
+#define __GST_AUDIO_ENUM_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/* enumerations from "multichannel.h" */
+GType gst_audio_channel_position_get_type (void);
+#define GST_TYPE_AUDIO_CHANNEL_POSITION (gst_audio_channel_position_get_type())
+G_END_DECLS
+
+#endif /* __GST_AUDIO_ENUM_TYPES_H__ */
+
+/* Generated data ends here */
+
diff -Naur win32/vs6/libgstdirectsound.dsp win32/vs6/libgstdirectsound.dsp
--- win32/vs6/libgstdirectsound.dsp	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs6/libgstdirectsound.dsp	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,125 @@
+# Microsoft Developer Studio Project File - Name="libgstdirectsound" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=libgstdirectsound - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "libgstdirectsound.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "libgstdirectsound.mak" CFG="libgstdirectsound - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "libgstdirectsound - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "libgstdirectsound - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "libgstdirectsound - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTDIRECTSOUND_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /O2 /I "../.." /I "../../gst-libs" /I "../../../gstreamer/win32" /I "../../../gstreamer" /I "../../../gstreamer/win32/common" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTDIRECTSOUND_EXPORTS" /D "HAVE_CONFIG_H" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 libgstreamer-0.10.lib libgstbase-0.10.lib libgsttagedit-0.10.lib libgstaudio-0.10.lib glib-2.0.lib gobject-2.0.lib vorbis.lib ogg.lib dsound.lib /nologo /dll /machine:I386 /libpath:"../../../gstreamer/win32/vs6/release" /libpath:"./release"
+# Begin Special Build Tool
+TargetPath=.\Release\libgstdirectsound.dll
+SOURCE="$(InputPath)"
+PostBuild_Cmds=copy /Y $(TargetPath) c:\gstreamer\lib\gstreamer-0.10
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "libgstdirectsound - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTDIRECTSOUND_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /I "../../gst-libs" /I "../../../gstreamer/win32" /I "../../../gstreamer" /I "../../../gstreamer/win32/common" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTDIRECTSOUND_EXPORTS" /D "HAVE_CONFIG_H" /YX /FD /GZ /c
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 libgstreamer-0.10.lib libgstbase-0.10.lib libgsttagedit-0.10.lib libgstaudio-0.10.lib glib-2.0.lib gobject-2.0.lib vorbis.lib ogg.lib dsound.lib /nologo /dll /debug /machine:I386 /pdbtype:sept /libpath:"../../../gstreamer/win32/vs6/debug" /libpath:"./debug"
+# Begin Special Build Tool
+TargetPath=.\Debug\libgstdirectsound.dll
+SOURCE="$(InputPath)"
+PostBuild_Cmds=copy /Y $(TargetPath) c:\gstreamer\lib\gstreamer-0.10
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "libgstdirectsound - Win32 Release"
+# Name "libgstdirectsound - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\libgstdirectsound\gstdirectsoundplugin.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libgstdirectsound\gstdirectsoundsink.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\libgstdirectsound\gstdirectsoundsink.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# End Target
+# End Project
diff -Naur win32/vs6/libgstutils.dsp win32/vs6/libgstutils.dsp
--- win32/vs6/libgstutils.dsp	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs6/libgstutils.dsp	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,135 @@
+# Microsoft Developer Studio Project File - Name="libgstutils" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=libgstutils - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "libgstutils.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "libgstutils.mak" CFG="libgstutils - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "libgstutils - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "libgstutils - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "libgstutils - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTUTILS_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /O2 /I "../../gst-libs" /I "../../../gstreamer" /I "../common" /I "../../../gstreamer/libs" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTUTILS_EXPORTS" /D "HAVE_CONFIG_H" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib /nologo /dll /machine:I386 /out:"Release/libgstutils-0.10.dll" /libpath:"../../../gstreamer/win32/vs6/release" /libpath:"./release"
+# Begin Special Build Tool
+TargetPath=.\Release\libgstutils-0.10.dll
+SOURCE="$(InputPath)"
+PostBuild_Cmds=copy /Y $(TargetPath) c:\gstreamer\bin
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "libgstutils - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTUTILS_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /ZI /Od /I "../../gst-libs" /I "../../../gstreamer" /I "../common" /I "../../../gstreamer/libs" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "LIBGSTUTILS_EXPORTS" /D "HAVE_CONFIG_H" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0D.lib gobject-2.0D.lib /nologo /dll /debug /machine:I386 /out:"Debug/libgstutils-0.10.dll" /pdbtype:sept /libpath:"../../../gstreamer/win32/vs6/debug" /libpath:"./debug"
+# Begin Special Build Tool
+TargetPath=.\Debug\libgstutils-0.10.dll
+SOURCE="$(InputPath)"
+PostBuild_Cmds=copy /Y $(TargetPath) c:\gstreamer\debug\bin
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "libgstutils - Win32 Release"
+# Name "libgstutils - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE="..\..\gst-libs\gst\utils\base-utils.c"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\gst-libs\gst\utils\descriptions.c"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\gst-libs\gst\utils\install-plugins.c"
+# End Source File
+# Begin Source File
+
+SOURCE=..\common\libgstutils.def
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\gst-libs\gst\utils\missing-plugins.c"
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# End Target
+# End Project
diff -Naur win32/vs7/gst-plugins-base.sln win32/vs7/gst-plugins-base.sln
--- win32/vs7/gst-plugins-base.sln	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/gst-plugins-base.sln	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,199 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstriff", "libgstriff.vcproj", "{3D36330F-1F68-44F6-A712-803E819A3DCD}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstaudio", "libgstaudio.vcproj", "{BD17F145-422C-4EC0-A756-C7675A5626B2}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstadder", "libgstadder.vcproj", "{E54E1872-C90A-4FF8-A4F4-27C3F8750D44}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstaudioconvert", "libgstaudioconvert.vcproj", "{EA99F8DE-660D-42E9-B14D-08F34FA45AD1}"
+	ProjectSection(ProjectDependencies) = postProject
+		{BD17F145-422C-4EC0-A756-C7675A5626B2} = {BD17F145-422C-4EC0-A756-C7675A5626B2}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstaudiorate", "libgstaudiorate.vcproj", "{C51F9363-7DC1-40F7-84D3-C9D4FD67A3CA}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstaudioresample", "libgstaudioresample.vcproj", "{0EE3173E-FCD3-4EC6-A28F-5AE5CE7196AC}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstaudiotestsrc", "libgstaudiotestsrc.vcproj", "{B5CDFF9E-28E0-4915-8C3E-95EDAE2D9DE3}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstffmpegcolorspace", "libgstffmpegcolorspace.vcproj", "{BE2600A9-5BEB-42D9-8F13-FD38FCF5B801}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstplaybin", "libgstplaybin.vcproj", "{7B296C12-D728-4CD8-8CF7-B8D7A433F85C}"
+	ProjectSection(ProjectDependencies) = postProject
+		{F7558C2A-C1BC-453C-8FDE-84F33DB73915} = {F7558C2A-C1BC-453C-8FDE-84F33DB73915}
+		{80270384-C551-471F-86C2-D80FE61D9883} = {80270384-C551-471F-86C2-D80FE61D9883}
+		{EA99F8DE-660D-42E9-B14D-08F34FA45AD1} = {EA99F8DE-660D-42E9-B14D-08F34FA45AD1}
+		{0969BEF1-77F5-468F-9497-8470FDEC615A} = {0969BEF1-77F5-468F-9497-8470FDEC615A}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgsttypefind", "libgsttypefind.vcproj", "{F7558C2A-C1BC-453C-8FDE-84F33DB73915}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstvideorate", "libgstvideorate.vcproj", "{84F3B76C-4733-4032-B51E-F8E71022AFE6}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstvideoscale", "libgstvideoscale.vcproj", "{557CB36F-7F92-4B43-973D-05C6BF0A6414}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstvideotestsrc", "libgstvideotestsrc.vcproj", "{7586DFA1-F847-4BEF-9105-724DD9F12C2A}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstvolume", "libgstvolume.vcproj", "{80270384-C551-471F-86C2-D80FE61D9883}"
+	ProjectSection(ProjectDependencies) = postProject
+		{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4} = {CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstdecodebin", "libgstdecodebin.vcproj", "{0969BEF1-77F5-468F-9497-8470FDEC615A}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstinterfaces", "libgstinterfaces.vcproj", "{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstsubparse", "libgstsubparse.vcproj", "{C41E324E-03FD-4483-92B1-B50F6E3B6B82}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgsttcp", "libgsttcp.vcproj", "{40412A73-43D3-4F1F-9078-DBD76705767D}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstvorbis", "libgstvorbis.vcproj", "{4F2E05FD-F87C-4325-8C2A-C1EEA21A483F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{BD17F145-422C-4EC0-A756-C7675A5626B2} = {BD17F145-422C-4EC0-A756-C7675A5626B2}
+		{626AF6BD-0AAB-4019-929A-2DB5CAD0419E} = {626AF6BD-0AAB-4019-929A-2DB5CAD0419E}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstogg", "libgstogg.vcproj", "{51E1F9C4-091E-43A0-97C1-E1B68700A5AF}"
+	ProjectSection(ProjectDependencies) = postProject
+		{3D36330F-1F68-44F6-A712-803E819A3DCD} = {3D36330F-1F68-44F6-A712-803E819A3DCD}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgsttheora", "libgsttheora.vcproj", "{AB7AD55A-A521-42F2-A953-623E5F059C1A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{626AF6BD-0AAB-4019-929A-2DB5CAD0419E} = {626AF6BD-0AAB-4019-929A-2DB5CAD0419E}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgsttag", "libgsttag.vcproj", "{626AF6BD-0AAB-4019-929A-2DB5CAD0419E}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libgstvideo", "libgstvideo.vcproj", "{1975AEE8-05C5-42DE-8A8B-620168F9C1C9}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{3D36330F-1F68-44F6-A712-803E819A3DCD}.Debug.ActiveCfg = Debug|Win32
+		{3D36330F-1F68-44F6-A712-803E819A3DCD}.Debug.Build.0 = Debug|Win32
+		{3D36330F-1F68-44F6-A712-803E819A3DCD}.Release.ActiveCfg = Release|Win32
+		{3D36330F-1F68-44F6-A712-803E819A3DCD}.Release.Build.0 = Release|Win32
+		{BD17F145-422C-4EC0-A756-C7675A5626B2}.Debug.ActiveCfg = Debug|Win32
+		{BD17F145-422C-4EC0-A756-C7675A5626B2}.Debug.Build.0 = Debug|Win32
+		{BD17F145-422C-4EC0-A756-C7675A5626B2}.Release.ActiveCfg = Release|Win32
+		{BD17F145-422C-4EC0-A756-C7675A5626B2}.Release.Build.0 = Release|Win32
+		{E54E1872-C90A-4FF8-A4F4-27C3F8750D44}.Debug.ActiveCfg = Debug|Win32
+		{E54E1872-C90A-4FF8-A4F4-27C3F8750D44}.Debug.Build.0 = Debug|Win32
+		{E54E1872-C90A-4FF8-A4F4-27C3F8750D44}.Release.ActiveCfg = Release|Win32
+		{E54E1872-C90A-4FF8-A4F4-27C3F8750D44}.Release.Build.0 = Release|Win32
+		{EA99F8DE-660D-42E9-B14D-08F34FA45AD1}.Debug.ActiveCfg = Debug|Win32
+		{EA99F8DE-660D-42E9-B14D-08F34FA45AD1}.Debug.Build.0 = Debug|Win32
+		{EA99F8DE-660D-42E9-B14D-08F34FA45AD1}.Release.ActiveCfg = Release|Win32
+		{EA99F8DE-660D-42E9-B14D-08F34FA45AD1}.Release.Build.0 = Release|Win32
+		{C51F9363-7DC1-40F7-84D3-C9D4FD67A3CA}.Debug.ActiveCfg = Debug|Win32
+		{C51F9363-7DC1-40F7-84D3-C9D4FD67A3CA}.Debug.Build.0 = Debug|Win32
+		{C51F9363-7DC1-40F7-84D3-C9D4FD67A3CA}.Release.ActiveCfg = Release|Win32
+		{C51F9363-7DC1-40F7-84D3-C9D4FD67A3CA}.Release.Build.0 = Release|Win32
+		{0EE3173E-FCD3-4EC6-A28F-5AE5CE7196AC}.Debug.ActiveCfg = Debug|Win32
+		{0EE3173E-FCD3-4EC6-A28F-5AE5CE7196AC}.Release.ActiveCfg = Release|Win32
+		{B5CDFF9E-28E0-4915-8C3E-95EDAE2D9DE3}.Debug.ActiveCfg = Debug|Win32
+		{B5CDFF9E-28E0-4915-8C3E-95EDAE2D9DE3}.Debug.Build.0 = Debug|Win32
+		{B5CDFF9E-28E0-4915-8C3E-95EDAE2D9DE3}.Release.ActiveCfg = Release|Win32
+		{B5CDFF9E-28E0-4915-8C3E-95EDAE2D9DE3}.Release.Build.0 = Release|Win32
+		{BE2600A9-5BEB-42D9-8F13-FD38FCF5B801}.Debug.ActiveCfg = Debug|Win32
+		{BE2600A9-5BEB-42D9-8F13-FD38FCF5B801}.Debug.Build.0 = Debug|Win32
+		{BE2600A9-5BEB-42D9-8F13-FD38FCF5B801}.Release.ActiveCfg = Release|Win32
+		{BE2600A9-5BEB-42D9-8F13-FD38FCF5B801}.Release.Build.0 = Release|Win32
+		{7B296C12-D728-4CD8-8CF7-B8D7A433F85C}.Debug.ActiveCfg = Debug|Win32
+		{7B296C12-D728-4CD8-8CF7-B8D7A433F85C}.Debug.Build.0 = Debug|Win32
+		{7B296C12-D728-4CD8-8CF7-B8D7A433F85C}.Release.ActiveCfg = Release|Win32
+		{7B296C12-D728-4CD8-8CF7-B8D7A433F85C}.Release.Build.0 = Release|Win32
+		{F7558C2A-C1BC-453C-8FDE-84F33DB73915}.Debug.ActiveCfg = Debug|Win32
+		{F7558C2A-C1BC-453C-8FDE-84F33DB73915}.Debug.Build.0 = Debug|Win32
+		{F7558C2A-C1BC-453C-8FDE-84F33DB73915}.Release.ActiveCfg = Release|Win32
+		{F7558C2A-C1BC-453C-8FDE-84F33DB73915}.Release.Build.0 = Release|Win32
+		{84F3B76C-4733-4032-B51E-F8E71022AFE6}.Debug.ActiveCfg = Debug|Win32
+		{84F3B76C-4733-4032-B51E-F8E71022AFE6}.Debug.Build.0 = Debug|Win32
+		{84F3B76C-4733-4032-B51E-F8E71022AFE6}.Release.ActiveCfg = Release|Win32
+		{84F3B76C-4733-4032-B51E-F8E71022AFE6}.Release.Build.0 = Release|Win32
+		{557CB36F-7F92-4B43-973D-05C6BF0A6414}.Debug.ActiveCfg = Debug|Win32
+		{557CB36F-7F92-4B43-973D-05C6BF0A6414}.Debug.Build.0 = Debug|Win32
+		{557CB36F-7F92-4B43-973D-05C6BF0A6414}.Release.ActiveCfg = Release|Win32
+		{557CB36F-7F92-4B43-973D-05C6BF0A6414}.Release.Build.0 = Release|Win32
+		{7586DFA1-F847-4BEF-9105-724DD9F12C2A}.Debug.ActiveCfg = Debug|Win32
+		{7586DFA1-F847-4BEF-9105-724DD9F12C2A}.Release.ActiveCfg = Release|Win32
+		{80270384-C551-471F-86C2-D80FE61D9883}.Debug.ActiveCfg = Debug|Win32
+		{80270384-C551-471F-86C2-D80FE61D9883}.Debug.Build.0 = Debug|Win32
+		{80270384-C551-471F-86C2-D80FE61D9883}.Release.ActiveCfg = Release|Win32
+		{80270384-C551-471F-86C2-D80FE61D9883}.Release.Build.0 = Release|Win32
+		{0969BEF1-77F5-468F-9497-8470FDEC615A}.Debug.ActiveCfg = Debug|Win32
+		{0969BEF1-77F5-468F-9497-8470FDEC615A}.Debug.Build.0 = Debug|Win32
+		{0969BEF1-77F5-468F-9497-8470FDEC615A}.Release.ActiveCfg = Release|Win32
+		{0969BEF1-77F5-468F-9497-8470FDEC615A}.Release.Build.0 = Release|Win32
+		{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}.Debug.ActiveCfg = Debug|Win32
+		{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}.Debug.Build.0 = Debug|Win32
+		{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}.Release.ActiveCfg = Release|Win32
+		{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}.Release.Build.0 = Release|Win32
+		{C41E324E-03FD-4483-92B1-B50F6E3B6B82}.Debug.ActiveCfg = Debug|Win32
+		{C41E324E-03FD-4483-92B1-B50F6E3B6B82}.Release.ActiveCfg = Release|Win32
+		{40412A73-43D3-4F1F-9078-DBD76705767D}.Debug.ActiveCfg = Debug|Win32
+		{40412A73-43D3-4F1F-9078-DBD76705767D}.Release.ActiveCfg = Release|Win32
+		{4F2E05FD-F87C-4325-8C2A-C1EEA21A483F}.Debug.ActiveCfg = Debug|Win32
+		{4F2E05FD-F87C-4325-8C2A-C1EEA21A483F}.Debug.Build.0 = Debug|Win32
+		{4F2E05FD-F87C-4325-8C2A-C1EEA21A483F}.Release.ActiveCfg = Release|Win32
+		{4F2E05FD-F87C-4325-8C2A-C1EEA21A483F}.Release.Build.0 = Release|Win32
+		{51E1F9C4-091E-43A0-97C1-E1B68700A5AF}.Debug.ActiveCfg = Debug|Win32
+		{51E1F9C4-091E-43A0-97C1-E1B68700A5AF}.Debug.Build.0 = Debug|Win32
+		{51E1F9C4-091E-43A0-97C1-E1B68700A5AF}.Release.ActiveCfg = Release|Win32
+		{51E1F9C4-091E-43A0-97C1-E1B68700A5AF}.Release.Build.0 = Release|Win32
+		{AB7AD55A-A521-42F2-A953-623E5F059C1A}.Debug.ActiveCfg = Debug|Win32
+		{AB7AD55A-A521-42F2-A953-623E5F059C1A}.Debug.Build.0 = Debug|Win32
+		{AB7AD55A-A521-42F2-A953-623E5F059C1A}.Release.ActiveCfg = Release|Win32
+		{AB7AD55A-A521-42F2-A953-623E5F059C1A}.Release.Build.0 = Release|Win32
+		{626AF6BD-0AAB-4019-929A-2DB5CAD0419E}.Debug.ActiveCfg = Debug|Win32
+		{626AF6BD-0AAB-4019-929A-2DB5CAD0419E}.Debug.Build.0 = Debug|Win32
+		{626AF6BD-0AAB-4019-929A-2DB5CAD0419E}.Release.ActiveCfg = Release|Win32
+		{626AF6BD-0AAB-4019-929A-2DB5CAD0419E}.Release.Build.0 = Release|Win32
+		{1975AEE8-05C5-42DE-8A8B-620168F9C1C9}.Debug.ActiveCfg = Debug|Win32
+		{1975AEE8-05C5-42DE-8A8B-620168F9C1C9}.Debug.Build.0 = Debug|Win32
+		{1975AEE8-05C5-42DE-8A8B-620168F9C1C9}.Release.ActiveCfg = Release|Win32
+		{1975AEE8-05C5-42DE-8A8B-620168F9C1C9}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff -Naur win32/vs7/libgstadder.vcproj win32/vs7/libgstadder.vcproj
--- win32/vs7/libgstadder.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstadder.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstadder"
+	ProjectGUID="{E54E1872-C90A-4FF8-A4F4-27C3F8750D44}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTADDER_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstadder.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstadder.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstadder.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTADDER_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstadder.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstadder.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\adder\gstadder.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstaudioconvert.vcproj win32/vs7/libgstaudioconvert.vcproj
--- win32/vs7/libgstaudioconvert.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstaudioconvert.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,151 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstaudioconvert"
+	ProjectGUID="{EA99F8DE-660D-42E9-B14D-08F34FA45AD1}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIOCONVERT_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudioconvert.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstaudioconvert.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstaudioconvert.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIOCONVERT_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudioconvert.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstaudioconvert.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\audioconvert\audioconvert.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioconvert\gstaudioconvert.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioconvert\gstchannelmix.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioconvert\plugin.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstaudiorate.vcproj win32/vs7/libgstaudiorate.vcproj
--- win32/vs7/libgstaudiorate.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstaudiorate.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstaudiorate"
+	ProjectGUID="{C51F9363-7DC1-40F7-84D3-C9D4FD67A3CA}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIORATE_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudiorate.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstaudiorate.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstaudiorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIORATE_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudiorate.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstaudiorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\audiorate\gstaudiorate.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstaudioresample.vcproj win32/vs7/libgstaudioresample.vcproj
--- win32/vs7/libgstaudioresample.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstaudioresample.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,163 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstaudioresample"
+	ProjectGUID="{0EE3173E-FCD3-4EC6-A28F-5AE5CE7196AC}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIORESAMPLE_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="liboil-0.3-0.lib libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudioresample.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstaudioresample.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstaudioresample.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIORESAMPLE_EXPORTS;HAVE_CONFIG_H;_USE_MATH_DEFINES"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="liboil-0.3-0.lib libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudioresample.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstaudioresample.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\audioresample\buffer.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\debug.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\functable.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\gstaudioresample.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\resample.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\resample_chunk.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\resample_functable.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\audioresample\resample_ref.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstaudiotestsrc.vcproj win32/vs7/libgstaudiotestsrc.vcproj
--- win32/vs7/libgstaudiotestsrc.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstaudiotestsrc.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstaudiotestsrc"
+	ProjectGUID="{B5CDFF9E-28E0-4915-8C3E-95EDAE2D9DE3}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIOTESTSRC_EXPORTS;_USE_MATH_DEFINES;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib libgstcontroller-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudiotestsrc.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstaudiotestsrc.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstaudiotestsrc.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIOTESTSRC_EXPORTS;_USE_MATH_DEFINES;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib libgstcontroller-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudiotestsrc.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstaudiotestsrc.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\audiotestsrc\gstaudiotestsrc.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstaudio.vcproj win32/vs7/libgstaudio.vcproj
--- win32/vs7/libgstaudio.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstaudio.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,183 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstaudio"
+	ProjectGUID="{BD17F145-422C-4EC0-A756-C7675A5626B2}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common,../../gst-libs/gst/audio"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIO_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudio-0.10.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstaudio.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstaudio-0.10.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstaudio-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="copy /y ..\common\audio-enumtypes.h ..\..\gst-libs\gst\audio
+copy /y ..\common\audio-enumtypes.c ..\..\gst-libs\gst\audio
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common,../../gst-libs/gst/audio"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTAUDIO_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstaudio-0.10.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstaudio.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstaudio-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="copy /y ..\common\audio-enumtypes.h ..\..\gst-libs\gst\audio
+copy /y ..\common\audio-enumtypes.c ..\..\gst-libs\gst\audio
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\audio.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstaudioclock.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstaudiofilter.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstaudiofiltertemplate.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstaudiosink.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstaudiosrc.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstbaseaudiosink.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstbaseaudiosrc.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\gstringbuffer.c">
+			</File>
+			<File
+				RelativePath="..\common\libgstaudio.def">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\audio-enumtypes.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\audio\multichannel.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstdecodebin.vcproj win32/vs7/libgstdecodebin.vcproj
--- win32/vs7/libgstdecodebin.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstdecodebin.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,169 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstdecodebin"
+	ProjectGUID="{0969BEF1-77F5-468F-9497-8470FDEC615A}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTDECODEBIN_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstdecodebin.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstdecodebin.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstdecodebin.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="if exist ..\..\gst\playback\gstplay-marshal.c goto HEADER
+echo #include &quot;glib-object.h&quot; &gt; gstplay-marshal.c.tmp
+echo #include &quot;gstplay-marshal.h&quot; &gt;&gt; gstplay-marshal.c.tmp
+glib-genmarshal --body --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.c.tmp
+move gstplay-marshal.c.tmp ..\..\gst\playback\gstplay-marshal.c
+:HEADER
+if exist ..\..\gst\playback\gstplay-marshal.h goto END
+echo #include &quot;gst/gstconfig.h&quot; &gt; gstplay-marshal.h.tmp
+glib-genmarshal --header --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.h.tmp
+move gstplay-marshal.h.tmp ..\..\gst\playback\gstplay-marshal.h
+:END
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTDECODEBIN_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstdecodebin.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstdecodebin.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="if exist ..\..\gst\playback\gstplay-marshal.c goto HEADER
+echo #include &quot;glib-object.h&quot; &gt; gstplay-marshal.c.tmp
+echo #include &quot;gstplay-marshal.h&quot; &gt;&gt; gstplay-marshal.c.tmp
+glib-genmarshal --body --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.c.tmp
+move gstplay-marshal.c.tmp ..\..\gst\playback\gstplay-marshal.c
+:HEADER
+if exist ..\..\gst\playback\gstplay-marshal.h goto END
+echo #include &quot;gst/gstconfig.h&quot; &gt; gstplay-marshal.h.tmp
+glib-genmarshal --header --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.h.tmp
+move gstplay-marshal.h.tmp ..\..\gst\playback\gstplay-marshal.h
+:END
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\playback\gstdecodebin.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\playback\gstplay-marshal.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstffmpegcolorspace.vcproj win32/vs7/libgstffmpegcolorspace.vcproj
--- win32/vs7/libgstffmpegcolorspace.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstffmpegcolorspace.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstffmpegcolorspace"
+	ProjectGUID="{BE2600A9-5BEB-42D9-8F13-FD38FCF5B801}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../common,../../gst/ffmpegcolorspace"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTFFMPEGCOLORSPACE_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstffmpegcolorspace.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstffmpegcolorspace.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstffmpegcolorspace.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../common,../../gst/ffmpegcolorspace"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTFFMPEGCOLORSPACE_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstffmpegcolorspace.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstffmpegcolorspace.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\dsputil.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\gstffmpeg.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\gstffmpegcodecmap.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\gstffmpegcolorspace.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\imgconvert.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\mem.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\ffmpegcolorspace\utils.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstinterfaces.vcproj win32/vs7/libgstinterfaces.vcproj
--- win32/vs7/libgstinterfaces.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstinterfaces.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,206 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstinterfaces"
+	ProjectGUID="{CF1687EC-9097-4A86-B7FB-C1ECF9E27EA4}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTINTERFACES_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstinterfaces-0.10.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstinterfaces.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstinterfaces-0.10.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstinterfaces-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="if exist ..\..\gst-libs\gst\interfaces\interfaces-marshal.c goto HEADER
+echo #include &quot;interfaces-marshal.h&quot; &gt;&gt; interfaces-marshal.c.tmp
+glib-genmarshal --body --prefix=gst_interfaces_marshal ..\..\gst-libs\gst\interfaces\interfaces-marshal.list &gt;&gt; interfaces-marshal.c.tmp
+move interfaces-marshal.c.tmp ..\..\gst-libs\gst\interfaces\interfaces-marshal.c
+:HEADER
+if exist ..\..\gst-libs\gst\interfaces\interfaces-marshal.h goto END
+echo #include &quot;gst/gstconfig.h&quot; &gt; interfaces-marshal.h.tmp
+glib-genmarshal --header --prefix=gst_interfaces_marshal ..\..\gst-libs\gst\interfaces\interfaces-marshal.list &gt;&gt; interfaces-marshal.h.tmp
+move interfaces-marshal.h.tmp ..\..\gst-libs\gst\interfaces\interfaces-marshal.h
+:END
+copy /y ..\common\interfaces-enumtypes.h ..\..\gst-libs\gst\interfaces
+copy /y ..\common\interfaces-enumtypes.c ..\..\gst-libs\gst\interfaces
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTINTERFACES_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstinterfaces-0.10.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstinterfaces.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstinterfaces-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="if exist ..\..\gst-libs\gst\interfaces\interfaces-marshal.c goto HEADER
+echo #include &quot;interfaces-marshal.h&quot; &gt;&gt; interfaces-marshal.c.tmp
+glib-genmarshal --body --prefix=gst_interfaces_marshal ..\..\gst-libs\gst\interfaces\interfaces-marshal.list &gt;&gt; interfaces-marshal.c.tmp
+move interfaces-marshal.c.tmp ..\..\gst-libs\gst\interfaces\interfaces-marshal.c
+:HEADER
+if exist ..\..\gst-libs\gst\interfaces\interfaces-marshal.h goto END
+echo #include &quot;gst/gstconfig.h&quot; &gt; interfaces-marshal.h.tmp
+glib-genmarshal --header --prefix=gst_interfaces_marshal ..\..\gst-libs\gst\interfaces\interfaces-marshal.list &gt;&gt; interfaces-marshal.h.tmp
+move interfaces-marshal.h.tmp ..\..\gst-libs\gst\interfaces\interfaces-marshal.h
+:END
+copy /y ..\common\interfaces-enumtypes.h ..\..\gst-libs\gst\interfaces
+copy /y ..\common\interfaces-enumtypes.c ..\..\gst-libs\gst\interfaces
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\colorbalance.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\colorbalancechannel.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\interfaces-marshal.c">
+			</File>
+			<File
+				RelativePath="..\common\libgstinterfaces.def">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\mixer.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\mixeroptions.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\mixertrack.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\navigation.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\propertyprobe.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\tuner.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\tunerchannel.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\tunernorm.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\interfaces\xoverlay.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstogg.vcproj win32/vs7/libgstogg.vcproj
--- win32/vs7/libgstogg.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstogg.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,154 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstogg"
+	ProjectGUID="{51E1F9C4-091E-43A0-97C1-E1B68700A5AF}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBOGG_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libogg.lib libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstogg.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstogg.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstogg.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBOGG_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libogg.lib libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstogg.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstogg.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\ext\ogg\gstogg.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\ogg\gstoggdemux.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\ogg\gstoggmux.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\ogg\gstoggparse.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\ogg\gstogmparse.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstplaybin.vcproj win32/vs7/libgstplaybin.vcproj
--- win32/vs7/libgstplaybin.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstplaybin.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,178 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstplaybin"
+	ProjectGUID="{7B296C12-D728-4CD8-8CF7-B8D7A433F85C}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTPLAYBIN_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstplaybin.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstplaybin.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstplaybin.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="if exist ..\..\gst\playback\gstplay-marshal.c goto HEADER
+echo #include &quot;glib-object.h&quot; &gt; gstplay-marshal.c.tmp
+echo #include &quot;gstplay-marshal.h&quot; &gt;&gt; gstplay-marshal.c.tmp
+glib-genmarshal --body --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.c.tmp
+move gstplay-marshal.c.tmp ..\..\gst\playback\gstplay-marshal.c
+:HEADER
+if exist ..\..\gst\playback\gstplay-marshal.h goto END
+echo #include &quot;gst/gstconfig.h&quot; &gt; gstplay-marshal.h.tmp
+glib-genmarshal --header --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.h.tmp
+move gstplay-marshal.h.tmp ..\..\gst\playback\gstplay-marshal.h
+:END
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTPLAYBIN_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstplaybin.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstplaybin.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"
+				CommandLine="if exist ..\..\gst\playback\gstplay-marshal.c goto HEADER
+echo #include &quot;glib-object.h&quot; &gt; gstplay-marshal.c.tmp
+echo #include &quot;gstplay-marshal.h&quot; &gt;&gt; gstplay-marshal.c.tmp
+glib-genmarshal --body --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.c.tmp
+move gstplay-marshal.c.tmp ..\..\gst\playback\gstplay-marshal.c
+:HEADER
+if exist ..\..\gst\playback\gstplay-marshal.h goto END
+echo #include &quot;gst/gstconfig.h&quot; &gt; gstplay-marshal.h.tmp
+glib-genmarshal --header --prefix=gst_play_marshal ..\..\gst\playback\gstplay-marshal.list &gt;&gt; gstplay-marshal.h.tmp
+move gstplay-marshal.h.tmp ..\..\gst\playback\gstplay-marshal.h
+:END
+"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\playback\gstplay-marshal.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\playback\gstplaybasebin.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\playback\gstplaybin.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\playback\gststreaminfo.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\playback\gststreamselector.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstriff.vcproj win32/vs7/libgstriff.vcproj
--- win32/vs7/libgstriff.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstriff.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,153 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstriff"
+	ProjectGUID="{3D36330F-1F68-44F6-A712-803E819A3DCD}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTRIFF_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstriff-0.10.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstriff.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstriff-0.10.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstriff-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTRIFF_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstriff-0.10.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstriff.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstriff-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\common\libgstriff.def">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\riff\riff-media.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\riff\riff-read.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\riff\riff.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstsubparse.vcproj win32/vs7/libgstsubparse.vcproj
--- win32/vs7/libgstsubparse.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstsubparse.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,134 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstsubparse"
+	ProjectGUID="{C41E324E-03FD-4483-92B1-B50F6E3B6B82}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;libgstsubparse_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/libgstsubparse.dll"
+				LinkIncremental="2"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstsubparse.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstsubparse.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;libgstsubparse_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/libgstsubparse.dll"
+				LinkIncremental="1"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstsubparse.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\subparse\gstsubparse.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgsttag.vcproj win32/vs7/libgsttag.vcproj
--- win32/vs7/libgsttag.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgsttag.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,150 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgsttag"
+	ProjectGUID="{626AF6BD-0AAB-4019-929A-2DB5CAD0419E}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTTAG_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgsttag-0.10.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgsttag.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgsttag-0.10.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgsttag-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTTAG_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgsttag-0.10.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgsttag.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgsttag-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst-libs\gst\tag\gstid3tag.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\tag\gstvorbistag.c">
+			</File>
+			<File
+				RelativePath="..\common\libgsttag.def">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgsttcp.vcproj win32/vs7/libgsttcp.vcproj
--- win32/vs7/libgsttcp.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgsttcp.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,160 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgsttcp"
+	ProjectGUID="{40412A73-43D3-4F1F-9078-DBD76705767D}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../gst-libs"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;libgsttcp_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/libgsttcp.dll"
+				LinkIncremental="2"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgsttcp.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgsttcp.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../gst-libs"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;libgsttcp_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="$(OutDir)/libgsttcp.dll"
+				LinkIncremental="1"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgsttcp.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\tcp\fdsetstress.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gstfdset.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gstmultifdsink.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gsttcp.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gsttcpclientsink.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gsttcpclientsrc.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gsttcpplugin.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gsttcpserversink.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\tcp\gsttcpserversrc.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgsttheora.vcproj win32/vs7/libgsttheora.vcproj
--- win32/vs7/libgsttheora.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgsttheora.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,148 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgsttheora"
+	ProjectGUID="{AB7AD55A-A521-42F2-A953-623E5F059C1A}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTTHEORA_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="theora_static.lib libogg.lib libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgsttheora.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgsttheora.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgsttheora.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTTHEORA_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="theora_static.lib libogg.lib libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgsttheora.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgsttheora.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\ext\theora\theora.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\theora\theoradec.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\theora\theoraenc.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgsttypefind.vcproj win32/vs7/libgsttypefind.vcproj
--- win32/vs7/libgsttypefind.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgsttypefind.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgsttypefind"
+	ProjectGUID="{F7558C2A-C1BC-453C-8FDE-84F33DB73915}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTTYPEFIND_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgsttypefind.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgsttypefind.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgsttypefind.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTTYPEFIND_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgsttypefind.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgsttypefind.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\typefind\gsttypefindfunctions.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstvideorate.vcproj win32/vs7/libgstvideorate.vcproj
--- win32/vs7/libgstvideorate.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstvideorate.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstvideorate"
+	ProjectGUID="{84F3B76C-4733-4032-B51E-F8E71022AFE6}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEORATE_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideorate.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstvideorate.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstvideorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEORATE_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideorate.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstvideorate.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\videorate\gstvideorate.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstvideoscale.vcproj win32/vs7/libgstvideoscale.vcproj
--- win32/vs7/libgstvideoscale.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstvideoscale.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,148 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstvideoscale"
+	ProjectGUID="{557CB36F-7F92-4B43-973D-05C6BF0A6414}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEOSCALE_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideoscale.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstvideoscale.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstvideoscale.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEOSCALE_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideoscale.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstvideoscale.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\videoscale\gstvideoscale.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\videoscale\vs_image.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\videoscale\vs_scanline.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstvideotestsrc.vcproj win32/vs7/libgstvideotestsrc.vcproj
--- win32/vs7/libgstvideotestsrc.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstvideotestsrc.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,145 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstvideotestsrc"
+	ProjectGUID="{7586DFA1-F847-4BEF-9105-724DD9F12C2A}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEOTESTSRC_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="liboil-0.3-0.lib libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideotestsrc.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstvideotestsrc.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstvideotestsrc.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEOTESTSRC_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="liboil-0.3-0.lib libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideotestsrc.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstvideotestsrc.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\videotestsrc\gstvideotestsrc.c">
+			</File>
+			<File
+				RelativePath="..\..\gst\videotestsrc\videotestsrc.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstvideo.vcproj win32/vs7/libgstvideo.vcproj
--- win32/vs7/libgstvideo.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstvideo.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,150 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstvideo"
+	ProjectGUID="{1975AEE8-05C5-42DE-8A8B-620168F9C1C9}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEO_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideo-0.10.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstvideo.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstvideo-0.10.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstvideo-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTVIDEO_EXPORTS"
+				RuntimeLibrary="0"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvideo-0.10.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				ModuleDefinitionFile="..\common\libgstvideo.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstvideo-0.10.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst-libs\gst\video\gstvideofilter.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\video\gstvideosink.c">
+			</File>
+			<File
+				RelativePath="..\..\gst-libs\gst\video\video.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstvolume.vcproj win32/vs7/libgstvolume.vcproj
--- win32/vs7/libgstvolume.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstvolume.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,142 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstvolume"
+	ProjectGUID="{80270384-C551-471F-86C2-D80FE61D9883}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTVOLUME_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib libgstcontroller-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvolume.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstvolume.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstvolume.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../../gstreamer/libs,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTVOLUME_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libgstreamer-0.10.lib libgstbase-0.10.lib libgstcontroller-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvolume.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstvolume.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\gst\volume\gstvolume.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -Naur win32/vs7/libgstvorbis.vcproj win32/vs7/libgstvorbis.vcproj
--- win32/vs7/libgstvorbis.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ win32/vs7/libgstvorbis.vcproj	2009-05-19 18:44:45.000000000 +0200
@@ -0,0 +1,151 @@
+<?xml version="1.0" encoding="windows-1251"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libgstvorbis"
+	ProjectGUID="{4F2E05FD-F87C-4325-8C2A-C1EEA21A483F}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBGSTVORBIS_EXPORTS;HAVE_CONFIG_H"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libvorbis.lib libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvorbis.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libgstvorbis.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libgstvorbis.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\debug\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="../../../gstreamer,../../gst-libs,../common"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBGSTVORBIS_EXPORTS;HAVE_CONFIG_H"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="libvorbis.lib libgstreamer-0.10.lib glib-2.0.lib gobject-2.0.lib"
+				OutputFile="$(OutDir)/libgstvorbis.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../../../gstreamer/win32/vs7/$(OutDir)"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libgstvorbis.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy /y &quot;$(TargetPath)&quot; c:\gstreamer\lib\gstreamer-0.10"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\..\ext\vorbis\vorbis.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\vorbis\vorbisdec.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\vorbis\vorbisenc.c">
+			</File>
+			<File
+				RelativePath="..\..\ext\vorbis\vorbisparse.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
