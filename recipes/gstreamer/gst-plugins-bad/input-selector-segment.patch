Index: gst/selector/gstinputselector.c
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-bad/gst/selector/gstinputselector.c,v
retrieving revision 1.15
diff -u -B -b -p -r1.15 gstinputselector.c
--- gst/selector/gstinputselector.c	15 Oct 2008 17:45:37 -0000	1.15
+++ gst/selector/gstinputselector.c	30 Oct 2008 11:54:05 -0000
@@ -98,7 +98,7 @@ static GstPad *gst_input_selector_activa
     GstPad * pad);
 static GstPad *gst_input_selector_get_linked_pad (GstPad * pad,
     gboolean strict);
-static gboolean gst_input_selector_check_eos (GstElement * selector);
+static gboolean gst_input_selector_check_eos (GstInputSelector * selector);
 
 #define GST_TYPE_SELECTOR_PAD \
   (gst_selector_pad_get_type())
@@ -154,6 +154,9 @@ static GstFlowReturn gst_selector_pad_ch
 static GstFlowReturn gst_selector_pad_bufferalloc (GstPad * pad,
     guint64 offset, guint size, GstCaps * caps, GstBuffer ** buf);
 
+static gboolean gst_input_selector_set_active_pad (GstInputSelector * self,
+    GstPad * pad, gint64 stop_time, gint64 start_time);
+
 static GType
 gst_selector_pad_get_type (void)
 {
@@ -346,13 +349,14 @@ gst_selector_pad_event (GstPad * pad, Gs
   sel = GST_INPUT_SELECTOR (gst_pad_get_parent (pad));
   selpad = GST_SELECTOR_PAD_CAST (pad);
 
-  /* only forward if we are dealing with the active sinkpad */
-  forward = gst_input_selector_is_active_sinkpad (sel, pad);
-
-  /* forward all events in select_all mode by default */
   if (sel->select_all) {
+    /* forward all events in select_all mode by default */
     forward = TRUE;
   }
+  else {
+    /* only forward if we are dealing with the active sinkpad */
+    forward = gst_input_selector_is_active_sinkpad (sel, pad);
+  }
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_FLUSH_START:
@@ -361,7 +365,9 @@ gst_selector_pad_event (GstPad * pad, Gs
     case GST_EVENT_FLUSH_STOP:
       GST_INPUT_SELECTOR_LOCK (sel);
       gst_selector_pad_reset (selpad);
+      gst_segment_init (&sel->segment, GST_FORMAT_UNDEFINED);
       sel->pending_close = FALSE;
+      sel->running_time = -1;
       GST_INPUT_SELECTOR_UNLOCK (sel);
       break;
     case GST_EVENT_NEWSEGMENT:
@@ -370,6 +376,7 @@ gst_selector_pad_event (GstPad * pad, Gs
       GstFormat format;
       gdouble rate, arate;
       gint64 start, stop, time;
+      gint64 sink_running;
 
       gst_event_parse_new_segment_full (event, &update, &rate, &arate, &format,
           &start, &stop, &time);
@@ -381,14 +388,40 @@ gst_selector_pad_event (GstPad * pad, Gs
           G_GINT64_FORMAT, update, rate, arate, format, start, stop, time);
 
       GST_INPUT_SELECTOR_LOCK (sel);
+      /* we take the object lock so that we can also take the running_time
+       * without taking the SELECTOR_LOCK */
       GST_OBJECT_LOCK (selpad);
       gst_segment_set_newsegment_full (&selpad->segment, update,
           rate, arate, format, start, stop, time);
       GST_OBJECT_UNLOCK (selpad);
-      /* we are not going to forward the segment, mark the segment as
-       * pending */
-      forward = FALSE;
+
+      sink_running = gst_segment_to_running_time (&selpad->segment, 
+		selpad->segment.format, selpad->segment.last_stop);
+
+      GST_DEBUG_OBJECT (pad, "sink running_time %"GST_TIME_FORMAT,
+	     GST_TIME_ARGS (sink_running));
+
+      if (sel->active_sinkpad == NULL) { 
+	/* no active pad, see if we have a running time that is bigger than what
+	 * we have on the srcpad. */
+	if (sink_running > sel->running_time) {
+	  /* activate this pad */
+          GST_DEBUG_OBJECT (pad, "activating pad");
+
+          sel->active_sinkpad = gst_object_ref (pad);
+	  forward = TRUE;
+	}
+      }
+      if (forward) {
+        gst_segment_set_newsegment_full (&sel->segment, update, rate,
+            arate, format, start, stop, time);
+        sel->running_time = gst_segment_to_running_time (&sel->segment, 
+		sel->segment.format, sel->segment.last_stop);
+        selpad->segment_pending = FALSE;
+      }
+      else {
       selpad->segment_pending = TRUE;
+      }
       GST_INPUT_SELECTOR_UNLOCK (sel);
 
       break;
@@ -412,7 +445,7 @@ gst_selector_pad_event (GstPad * pad, Gs
       selpad->eos = TRUE;
       GST_DEBUG_OBJECT (pad, "received EOS");
       /* don't forward eos in select_all mode until all sink pads have eos */
-      if (sel->select_all && !gst_input_selector_check_eos (GST_ELEMENT (sel))) {
+      if (sel->select_all && !gst_input_selector_check_eos (sel)) {
         forward = FALSE;
       }
       break;
@@ -558,7 +591,7 @@ gst_selector_pad_chain (GstPad * pad, Gs
     GstSegment *cseg = &sel->segment;
 
     GST_DEBUG_OBJECT (sel,
-        "pushing NEWSEGMENT update %d, rate %lf, applied rate %lf, "
+        "pushing close NEWSEGMENT update %d, rate %lf, applied rate %lf, "
         "format %d, "
         "%" G_GINT64_FORMAT " -- %" G_GINT64_FORMAT ", time %"
         G_GINT64_FORMAT, TRUE, cseg->rate, cseg->applied_rate, cseg->format,
@@ -573,7 +606,7 @@ gst_selector_pad_chain (GstPad * pad, Gs
   /* if we have a pending segment, push it out now */
   if (G_UNLIKELY (selpad->segment_pending)) {
     GST_DEBUG_OBJECT (pad,
-        "pushing NEWSEGMENT update %d, rate %lf, applied rate %lf, "
+        "pushing pending NEWSEGMENT update %d, rate %lf, applied rate %lf, "
         "format %d, "
         "%" G_GINT64_FORMAT " -- %" G_GINT64_FORMAT ", time %"
         G_GINT64_FORMAT, FALSE, seg->rate, seg->applied_rate, seg->format,
@@ -820,6 +853,7 @@ gst_input_selector_init (GstInputSelecto
   sel->active_sinkpad = NULL;
   sel->padcount = 0;
   gst_segment_init (&sel->segment, GST_FORMAT_UNDEFINED);
+  sel->running_time = -1;
 
   sel->lock = g_mutex_new ();
   sel->cond = g_cond_new ();
@@ -1262,6 +1296,7 @@ gst_input_selector_reset (GstInputSelect
   /* reset segment */
   gst_segment_init (&sel->segment, GST_FORMAT_UNDEFINED);
   sel->pending_close = FALSE;
+  sel->running_time = -1;
   /* reset each of our sinkpads state */
   for (walk = GST_ELEMENT_CAST (sel)->sinkpads; walk; walk = g_list_next (walk)) {
     GstSelectorPad *selpad = GST_SELECTOR_PAD_CAST (walk->data);
@@ -1362,14 +1397,16 @@ gst_input_selector_switch (GstInputSelec
 }
 
 static gboolean
-gst_input_selector_check_eos (GstElement * selector)
+gst_input_selector_check_eos (GstInputSelector * selector)
 {
-  GstIterator *it = gst_element_iterate_sink_pads (selector);
+  GstIterator *it;
   GstIteratorResult ires;
   gpointer item;
   gboolean done = FALSE, is_eos = FALSE;
   GstSelectorPad *pad;
 
+  it = gst_element_iterate_sink_pads (GST_ELEMENT_CAST (selector));
+
   while (!done) {
     ires = gst_iterator_next (it, &item);
     switch (ires) {
Index: gst/selector/gstinputselector.h
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-bad/gst/selector/gstinputselector.h,v
retrieving revision 1.4
diff -u -B -b -p -r1.4 gstinputselector.h
--- gst/selector/gstinputselector.h	20 Mar 2008 16:48:46 -0000	1.4
+++ gst/selector/gstinputselector.h	30 Oct 2008 11:54:05 -0000
@@ -58,6 +58,8 @@ struct _GstInputSelector {
   guint padcount;
 
   GstSegment segment;      /* the output segment */
+  gint64 running_time;
+
   gboolean pending_close;  /* if we should push a close first */
 
   GMutex *lock;
