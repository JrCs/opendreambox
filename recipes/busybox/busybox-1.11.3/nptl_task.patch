diff -auNr busybox-1.11.3/libbb/procps.c busybox-1.11.3-nptl/libbb/procps.c
--- busybox-1.11.3/libbb/procps.c	2008-09-28 20:04:12.000000000 +0200
+++ busybox-1.11.3-nptl/libbb/procps.c	2008-12-28 15:33:09.000000000 +0100
@@ -166,236 +166,268 @@
 procps_status_t *procps_scan(procps_status_t* sp, int flags)
 {
 	struct dirent *entry;
+	static DIR *taskdir;
 	char buf[PROCPS_BUFSIZE];
 	char filename[sizeof("/proc//cmdline") + sizeof(int)*3];
 	char *filename_tail;
 	long tasknice;
 	unsigned pid;
+	static unsigned parentpid;
 	int n;
 	struct stat sb;
 
 	if (!sp)
 		sp = alloc_procps_scan();
 
-	for (;;) {
-		entry = readdir(sp->dir);
-		if (entry == NULL) {
-			free_procps_scan(sp);
-			return NULL;
-		}
-		pid = bb_strtou(entry->d_name, NULL, 10);
-		if (errno)
-			continue;
-
-		/* After this point we have to break, not continue
-		 * ("continue" would mean that current /proc/NNN
-		 * is not a valid process info) */
+	if(taskdir){
+		for(;;) {
+			entry = readdir(taskdir);
+			if(entry == NULL) {
+				closedir(taskdir);
+				taskdir = 0;
+				break;
+			}
+			pid = bb_strtou(entry->d_name, NULL, 10);
+			if (errno)
+				continue;
+
+			/* After this point we have to break, not continue
+			 * ("continue" would mean that current /proc/NNN
+			 * is not a valid process info) */
 
-		memset(&sp->vsz, 0, sizeof(*sp) - offsetof(procps_status_t, vsz));
+			memset(&sp->vsz, 0, sizeof(*sp) - offsetof(procps_status_t, vsz));
 
-		sp->pid = pid;
-		if (!(flags & ~PSSCAN_PID)) break;
+			sp->pid = pid;
+			if (!(flags & ~PSSCAN_PID)) break;
 
 #if ENABLE_SELINUX
-		if (flags & PSSCAN_CONTEXT) {
-			if (getpidcon(sp->pid, &sp->context) < 0)
-				sp->context = NULL;
-		}
+			if (flags & PSSCAN_CONTEXT) {
+				if (getpidcon(sp->pid, &sp->context) < 0)
+					sp->context = NULL;
+			}
 #endif
 
-		filename_tail = filename + sprintf(filename, "/proc/%d", pid);
+			filename_tail = filename + sprintf(filename, "/proc/%d/task/%d", parentpid, pid);
 
-		if (flags & PSSCAN_UIDGID) {
-			if (stat(filename, &sb))
-				break;
-			/* Need comment - is this effective or real UID/GID? */
-			sp->uid = sb.st_uid;
-			sp->gid = sb.st_gid;
-		}
+			if (flags & PSSCAN_UIDGID) {
+				if (stat(filename, &sb))
+					break;
+				/* Need comment - is this effective or real UID/GID? */
+				sp->uid = sb.st_uid;
+				sp->gid = sb.st_gid;
+			}
 
-		if (flags & PSSCAN_STAT) {
-			char *cp, *comm1;
-			int tty;
+			if (flags & PSSCAN_STAT) {
+				char *cp, *comm1;
+				int tty;
 #if !ENABLE_FEATURE_FAST_TOP
-			unsigned long vsz, rss;
+				unsigned long vsz, rss;
 #endif
 
-			/* see proc(5) for some details on this */
-			strcpy(filename_tail, "/stat");
-			n = read_to_buf(filename, buf);
-			if (n < 0)
-				break;
-			cp = strrchr(buf, ')'); /* split into "PID (cmd" and "<rest>" */
-			/*if (!cp || cp[1] != ' ')
-				break;*/
-			cp[0] = '\0';
-			if (sizeof(sp->comm) < 16)
-				BUG_comm_size();
-			comm1 = strchr(buf, '(');
-			/*if (comm1)*/
-				safe_strncpy(sp->comm, comm1 + 1, sizeof(sp->comm));
+				/* see proc(5) for some details on this */
+				strcpy(filename_tail, "/stat");
+				n = read_to_buf(filename, buf);
+				if (n < 0)
+					break;
+				cp = strrchr(buf, ')'); /* split into "PID (cmd" and "<rest>" */
+				/*if (!cp || cp[1] != ' ')
+					break;*/
+				cp[0] = '\0';
+				if (sizeof(sp->comm) < 16)
+					BUG_comm_size();
+				comm1 = strchr(buf, '(');
+				/*if (comm1)*/
+					safe_strncpy(sp->comm, comm1 + 1, sizeof(sp->comm));
 
 #if !ENABLE_FEATURE_FAST_TOP
-			n = sscanf(cp+2,
-				"%c %u "               /* state, ppid */
-				"%u %u %d %*s "        /* pgid, sid, tty, tpgid */
-				"%*s %*s %*s %*s %*s " /* flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
-				"%lu %lu "             /* utime, stime */
-				"%*s %*s %*s "         /* cutime, cstime, priority */
-				"%ld "                 /* nice */
-				"%*s %*s "             /* timeout, it_real_value */
-				"%lu "                 /* start_time */
-				"%lu "                 /* vsize */
-				"%lu "                 /* rss */
-			/*	"%lu %lu %lu %lu %lu %lu " rss_rlim, start_code, end_code, start_stack, kstk_esp, kstk_eip */
-			/*	"%u %u %u %u "         signal, blocked, sigignore, sigcatch */
-			/*	"%lu %lu %lu"          wchan, nswap, cnswap */
-				,
-				sp->state, &sp->ppid,
-				&sp->pgid, &sp->sid, &tty,
-				&sp->utime, &sp->stime,
-				&tasknice,
-				&sp->start_time,
-				&vsz,
-				&rss);
-			if (n != 11)
-				break;
-			/* vsz is in bytes and we want kb */
-			sp->vsz = vsz >> 10;
-			/* vsz is in bytes but rss is in *PAGES*! Can you believe that? */
-			sp->rss = rss << sp->shift_pages_to_kb;
-			sp->tty_major = (tty >> 8) & 0xfff;
-			sp->tty_minor = (tty & 0xff) | ((tty >> 12) & 0xfff00);
+				n = sscanf(cp+2,
+					"%c %u "               /* state, ppid */
+					"%u %u %d %*s "        /* pgid, sid, tty, tpgid */
+					"%*s %*s %*s %*s %*s " /* flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
+					"%lu %lu "             /* utime, stime */
+					"%*s %*s %*s "         /* cutime, cstime, priority */
+					"%ld "                 /* nice */
+					"%*s %*s "             /* timeout, it_real_value */
+					"%lu "                 /* start_time */
+					"%lu "                 /* vsize */
+					"%lu "                 /* rss */
+				/*	"%lu %lu %lu %lu %lu %lu " rss_rlim, start_code, end_code, start_stack, kstk_esp, kstk_eip */
+				/*	"%u %u %u %u "         signal, blocked, sigignore, sigcatch */
+				/*	"%lu %lu %lu"          wchan, nswap, cnswap */
+					,
+					sp->state, &sp->ppid,
+					&sp->pgid, &sp->sid, &tty,
+					&sp->utime, &sp->stime,
+					&tasknice,
+					&sp->start_time,
+					&vsz,
+					&rss);
+				if (n != 11)
+					break;
+				/* vsz is in bytes and we want kb */
+				sp->vsz = vsz >> 10;
+				/* vsz is in bytes but rss is in *PAGES*! Can you believe that? */
+				sp->rss = rss << sp->shift_pages_to_kb;
+				sp->tty_major = (tty >> 8) & 0xfff;
+				sp->tty_minor = (tty & 0xff) | ((tty >> 12) & 0xfff00);
 #else
 /* This costs ~100 bytes more but makes top faster by 20%
  * If you run 10000 processes, this may be important for you */
-			sp->state[0] = cp[2];
-			cp += 4;
-			sp->ppid = fast_strtoul_10(&cp);
-			sp->pgid = fast_strtoul_10(&cp);
-			sp->sid = fast_strtoul_10(&cp);
-			tty = fast_strtoul_10(&cp);
-			sp->tty_major = (tty >> 8) & 0xfff;
-			sp->tty_minor = (tty & 0xff) | ((tty >> 12) & 0xfff00);
-			cp = skip_fields(cp, 6); /* tpgid, flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
-			sp->utime = fast_strtoul_10(&cp);
-			sp->stime = fast_strtoul_10(&cp);
-			cp = skip_fields(cp, 3); /* cutime, cstime, priority */
-			tasknice = fast_strtoul_10(&cp);
-			cp = skip_fields(cp, 2); /* timeout, it_real_value */
-			sp->start_time = fast_strtoul_10(&cp);
-			/* vsz is in bytes and we want kb */
-			sp->vsz = fast_strtoul_10(&cp) >> 10;
-			/* vsz is in bytes but rss is in *PAGES*! Can you believe that? */
-			sp->rss = fast_strtoul_10(&cp) << sp->shift_pages_to_kb;
+				sp->state[0] = cp[2];
+				cp += 4;
+				sp->ppid = fast_strtoul_10(&cp);
+				sp->pgid = fast_strtoul_10(&cp);
+				sp->sid = fast_strtoul_10(&cp);
+				tty = fast_strtoul_10(&cp);
+				sp->tty_major = (tty >> 8) & 0xfff;
+				sp->tty_minor = (tty & 0xff) | ((tty >> 12) & 0xfff00);
+				cp = skip_fields(cp, 6); /* tpgid, flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
+				sp->utime = fast_strtoul_10(&cp);
+				sp->stime = fast_strtoul_10(&cp);
+				cp = skip_fields(cp, 3); /* cutime, cstime, priority */
+				tasknice = fast_strtoul_10(&cp);
+				cp = skip_fields(cp, 2); /* timeout, it_real_value */
+				sp->start_time = fast_strtoul_10(&cp);
+				/* vsz is in bytes and we want kb */
+				sp->vsz = fast_strtoul_10(&cp) >> 10;
+				/* vsz is in bytes but rss is in *PAGES*! Can you believe that? */
+				sp->rss = fast_strtoul_10(&cp) << sp->shift_pages_to_kb;
 #endif
 
-			if (sp->vsz == 0 && sp->state[0] != 'Z')
-				sp->state[1] = 'W';
-			else
-				sp->state[1] = ' ';
-			if (tasknice < 0)
-				sp->state[2] = '<';
-			else if (tasknice) /* > 0 */
-				sp->state[2] = 'N';
-			else
-				sp->state[2] = ' ';
+				if (sp->vsz == 0 && sp->state[0] != 'Z')
+					sp->state[1] = 'W';
+				else
+					sp->state[1] = ' ';
+				if (tasknice < 0)
+					sp->state[2] = '<';
+				else if (tasknice) /* > 0 */
+					sp->state[2] = 'N';
+				else
+					sp->state[2] = ' ';
 
-		}
+			}
 
 #if ENABLE_FEATURE_TOPMEM
-		if (flags & (PSSCAN_SMAPS)) {
-			FILE *file;
+			if (flags & (PSSCAN_SMAPS)) {
+				FILE *file;
 
-			strcpy(filename_tail, "/smaps");
-			file = fopen(filename, "r");
-			if (!file)
-				break;
-			while (fgets(buf, sizeof(buf), file)) {
-				unsigned long sz;
-				char *tp;
-				char w;
+				strcpy(filename_tail, "/smaps");
+				file = fopen(filename, "r");
+				if (!file)
+					break;
+				while (fgets(buf, sizeof(buf), file)) {
+					unsigned long sz;
+					char *tp;
+					char w;
 #define SCAN(str, name) \
 	if (strncmp(buf, str, sizeof(str)-1) == 0) { \
 		tp = skip_whitespace(buf + sizeof(str)-1); \
 		sp->name += fast_strtoul_10(&tp); \
 		continue; \
 	}
-				SCAN("Shared_Clean:" , shared_clean );
-				SCAN("Shared_Dirty:" , shared_dirty );
-				SCAN("Private_Clean:", private_clean);
-				SCAN("Private_Dirty:", private_dirty);
+					SCAN("Shared_Clean:" , shared_clean );
+					SCAN("Shared_Dirty:" , shared_dirty );
+					SCAN("Private_Clean:", private_clean);
+					SCAN("Private_Dirty:", private_dirty);
 #undef SCAN
-				// f7d29000-f7d39000 rw-s ADR M:m OFS FILE
-				tp = strchr(buf, '-');
-				if (tp) {
-					*tp = ' ';
-					tp = buf;
-					sz = fast_strtoul_16(&tp); /* start */
-					sz = (fast_strtoul_16(&tp) - sz) >> 10; /* end - start */
-					// tp -> "rw-s" string
-					w = tp[1];
-					// skipping "rw-s ADR M:m OFS "
-					tp = skip_whitespace(skip_fields(tp, 4));
-					// filter out /dev/something (something != zero)
-					if (strncmp(tp, "/dev/", 5) != 0 || strcmp(tp, "/dev/zero\n") == 0) {
-						if (w == 'w') {
-							sp->mapped_rw += sz;
-						} else if (w == '-') {
-							sp->mapped_ro += sz;
+					// f7d29000-f7d39000 rw-s ADR M:m OFS FILE
+					tp = strchr(buf, '-');
+					if (tp) {
+						*tp = ' ';
+						tp = buf;
+						sz = fast_strtoul_16(&tp); /* start */
+						sz = (fast_strtoul_16(&tp) - sz) >> 10; /* end - start */
+						// tp -> "rw-s" string
+						w = tp[1];
+						// skipping "rw-s ADR M:m OFS "
+						tp = skip_whitespace(skip_fields(tp, 4));
+						// filter out /dev/something (something != zero)
+						if (strncmp(tp, "/dev/", 5) != 0 || strcmp(tp, "/dev/zero\n") == 0) {
+							if (w == 'w') {
+								sp->mapped_rw += sz;
+							} else if (w == '-') {
+								sp->mapped_ro += sz;
+							}
 						}
-					}
 //else printf("DROPPING %s (%s)\n", buf, tp);
-					if (strcmp(tp, "[stack]\n") == 0)
-						sp->stack += sz;
+						if (strcmp(tp, "[stack]\n") == 0)
+							sp->stack += sz;
+					}
 				}
+				fclose(file);
 			}
-			fclose(file);
-		}
 #endif /* TOPMEM */
 
 #if 0 /* PSSCAN_CMD is not used */
-		if (flags & (PSSCAN_CMD|PSSCAN_ARGV0)) {
-			free(sp->argv0);
-			sp->argv0 = NULL;
-			free(sp->cmd);
-			sp->cmd = NULL;
-			strcpy(filename_tail, "/cmdline");
-			/* TODO: to get rid of size limits, read into malloc buf,
-			 * then realloc it down to real size. */
-			n = read_to_buf(filename, buf);
-			if (n <= 0)
-				break;
-			if (flags & PSSCAN_ARGV0)
-				sp->argv0 = xstrdup(buf);
-			if (flags & PSSCAN_CMD) {
-				do {
-					n--;
-					if ((unsigned char)(buf[n]) < ' ')
-						buf[n] = ' ';
-				} while (n);
-				sp->cmd = xstrdup(buf);
+			if (flags & (PSSCAN_CMD|PSSCAN_ARGV0)) {
+				free(sp->argv0);
+				sp->argv0 = NULL;
+				free(sp->cmd);
+				sp->cmd = NULL;
+				strcpy(filename_tail, "/cmdline");
+				/* TODO: to get rid of size limits, read into malloc buf,
+				 * then realloc it down to real size. */
+				n = read_to_buf(filename, buf);
+				if (n <= 0)
+					break;
+				if (flags & PSSCAN_ARGV0)
+					sp->argv0 = xstrdup(buf);
+				if (flags & PSSCAN_CMD) {
+					do {
+						n--;
+						if ((unsigned char)(buf[n]) < ' ')
+							buf[n] = ' ';
+					} while (n);
+					sp->cmd = xstrdup(buf);
+				}
 			}
-		}
 #else
-		if (flags & (PSSCAN_ARGV0|PSSCAN_ARGVN)) {
-			free(sp->argv0);
-			sp->argv0 = NULL;
-			strcpy(filename_tail, "/cmdline");
-			n = read_to_buf(filename, buf);
-			if (n <= 0)
-				break;
-			if (flags & PSSCAN_ARGVN) {
-				sp->argv_len = n;
-				sp->argv0 = xmalloc(n + 1);
-				memcpy(sp->argv0, buf, n + 1);
-				/* sp->argv0[n] = '\0'; - buf has it */
-			} else {
-				sp->argv_len = 0;
-				sp->argv0 = xstrdup(buf);
+			if (flags & (PSSCAN_ARGV0|PSSCAN_ARGVN)) {
+				free(sp->argv0);
+				sp->argv0 = NULL;
+				strcpy(filename_tail, "/cmdline");
+				n = read_to_buf(filename, buf);
+				if (n <= 0)
+					break;
+				if (flags & PSSCAN_ARGVN) {
+					sp->argv_len = n;
+					sp->argv0 = xmalloc(n + 1);
+					memcpy(sp->argv0, buf, n + 1);
+					/* sp->argv0[n] = '\0'; - buf has it */
+				} else {
+					sp->argv_len = 0;
+					sp->argv0 = xstrdup(buf);
+				}
 			}
-		}
 #endif
+			break;
+		}
+		if(taskdir)
+			return sp;
+	}
+
+	for (;;) {
+		entry = readdir(sp->dir);
+		if (entry == NULL) {
+			free_procps_scan(sp);
+			return NULL;
+		}
+		pid = bb_strtou(entry->d_name, NULL, 10);
+		if (errno)
+			continue;
+
+		filename_tail = filename + sprintf(filename, "/proc/%d", pid);
+
+		if (!taskdir) {
+			strcpy(filename_tail, "/task");
+			taskdir = xopendir(filename);
+			if(!taskdir)
+				// ignore processes without taskdir
+				continue;
+			parentpid = pid;
+			return procps_scan(sp, flags);
+		}
+
 		break;
 	}
 	return sp;
